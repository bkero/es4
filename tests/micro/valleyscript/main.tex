 \documentclass{article}
\usepackage{amssymb}
%\usepackage{gastex}
\usepackage{graphics}
\input{brackets}
\input{restate.sty}

\newcommand{\myclearpage}{}
\setlength{\textwidth}{6.5in}
\setlength{\oddsidemargin}{0in}
\setlength{\textheight}{8.5in}
\setlength{\topmargin}{0in}
\setlength{\topskip}{0in}

\newcommand{\fun}[1]{\mbox{\it #1\/}}
\newcommand{\eg}{\emph{e.g.}}
\newcommand{\ie}{\emph{i.e.}}
\newcommand{\meaningf}[1]{\ensuremath{[\![ #1 ]\!]}}
\newcommand{\judge}[2]{\ensuremath{\Gamma\vdash{#1}:{#2}}}
\newcommand{\setc}[2]{ \{ #1 ~|~ #2 \}}
\newcommand{\setz}[1]{ \{ #1 \}}
\newcommand{\nt}[1]{\ba#1\ea}
\newcommand{\comment}[1]{}
\newcommand{\fs}[1]{\mbox{\it #1}}

%%%%%%%% language %%%%%%%%%%%%%%%

\newcommand{\safe}{\bullet}
\newcommand{\unsafe}{\circ}

\newcommand{\slam}[3]{\lambda#1\!:\!#2.\,\,#3}
\newcommand{\lam}[5]{\lambda\!^{#1}\,#2\!:\!#3.\,\,#5:#4}
\newcommand{\lete}[4]{\t{let}~{#1}:{#2}={#3}~\t{in}~{#4}} 
\newcommand{\lamt}[2]{#1\rightarrow #2}
\newcommand{\appl}[3]{(\app{}{#2}{#3})^{#1}}
\newcommand{\appt}[3]{(\app{}{#2}{#3}):{#1}}
\newcommand{\app}[3]{(#2~#3)^{#1}}
\newcommand{\deltaf}[2]{\meaningf{#1}(#2)}
\newcommand{\Nat}{\t{N}}
\newcommand{\Int}{\t{Int}}
\newcommand{\Bool}{\t{Bool}}
\newcommand{\dynamic}{\t{*}} 
\newcommand{\true}{\t{true}}
\newcommand{\false}{\t{false}}
\newcommand{\hole}{\safe}
\newcommand{\Lam}[3]{\Lambda #1.\,#2:#3}
\newcommand{\App}[2]{#1[#2]}
\newcommand{\Forall}[2]{\forall #1.\,#2}

\newcommand{\letexp}[3]{\t{let}~{#1}={#2}~\t{in}~{#3}}
\newcommand{\lett}[4]{\t{letXXX}~{#1}:{#2}={#3}~\t{in}~{#4}}
\newcommand{\cast}[3]{#2~\t{as}^{#1}~#3}
\newcommand{\arrowt}[2]{#1\rightarrow #2}
\newcommand{\defeq}{\stackrel{\mathrm{def}}{=}}

\newcommand{\convertible}[2]{#1 \prec #2}
\newcommand{\subtypeword}{\,<\,}
\newcommand{\subtype}[2]{#1 \subtypeword #2}
\newcommand{\compatible}[2]{#1 \leadsto #2}
\newcommand{\comsubtype}[2]{#1 <\!\!\leadsto #2}
\newcommand{\csupertype}[2]{#1 >\leadsto #2}

\newcommand{\consistent}[2]{#1 \sim #2}
\newcommand{\consubtype}[2]{#1 <\!\!\sim #2}

\newcommand{\convert}[2]{{#1}\convertword{#2}}
\newcommand{\convertword}{\mbox{\,\,$\sim :$\,\,}}

\newcommand{\implies}[2]{#1\Implies #2}

\renewcommand{\t}[1]{{\tt #1}}

%%%%%%%%%%% math %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\Or}{\vee}
\newcommand{\meet}{\sqcap}
\newcommand{\join}{\sqcup}
\newcommand{\And}[0]{\wedge}
\newcommand{\Implies}[0]{\Rightarrow}
\newcommand{\Iff}[0]{\Leftrightarrow}

%======= judgments ===============
\renewcommand{\judge}[3]{#1\vdash #2\,:\,#3}
\newcommand{\judgeE}[1]{\vdash #1}
\newcommand{\judgeT}[2]{#1\vdash #2}
\newcommand{\red}[0]{\longrightarrow}  % reduction
\newcommand{\lred}[0]{\red}  % local reduction
\newcommand{\judgers}[3]{#2 \rightarrow^{#1} #3}
\newcommand{\compilesymbol}{\hookrightarrow}
\newcommand{\judgec}[4]{#1 \vdash #2 \,\compilesymbol\, #3 \,:\, #4 }

\newcommand{\judges}[3]{#1\vdash\!\!\!\vdash #2\,:\,#3}
 
%=== objects
\newcommand{\objty}[1]{\{#1\}}
\newcommand{\obje}[3]{\{#2\}^{#1}:{#3}}
\newcommand{\objv}[1]{\{#1\}}
\newcommand{\objget}[3]{#2.#3^{#1}}
%\newcommand{\objcall}[2]{#1.#2()}
\newcommand{\objset}[4]{#2.#3^{#1}:=#4} 

	
\newcommand{\wrapty}[1]{\t{wrap}~#1}
\newcommand{\likety}[1]{\t{like}~#1}
\newcommand{\wrapv}[2]{#1~\t{wrapped}~#2}
%\renewcommand{\wrapv}[2]{\wrap{#1}{#2}}
 
\newcommand{\wrap}[2]{#1~\t{wrap}~#2}
%\newcommand{\assignable}[2]{#1<#2}
\newcommand{\likev}[2]{#1 \sqsubset_{\sigma} #2 }
\renewcommand{\likev}[2]{#1 ~\fun{XXXX like}_{\sigma}~ #2 }
%\newcommand{\compatible}[2]{#1 XXX \sim: #2 }
 
%\newcommand{\allocty}[2]{#1:_{\sigma}#2}
\newcommand{\allocty}[1]{ty(#1)}
\newcommand{\curty}[1]{cty_{\sigma}(#1)}
\renewcommand{\convert}[2]{\fun{convert}_{\sigma}(#1,#2)}
\newcommand{\istype}[2]{#1~\t{is}_{\sigma}~ #2}
 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%				   

\begin{document}


\title{ValleyScript: It's Like Static Typing
}
\author{Cormac Flanagan}


%\date{\today}
\maketitle

\begin{abstract}
We formalize the ES4 notion of gradual typing for a small language with functions and objects, and with \t{like}, \t{wrap}, and dynamic types.
We present a ``strict mode'' verifier for this language.
We also present a type-based analysis that statically identifies which run-time type checks are redundant, 
and prove the soundness of this analysis. 
This soundness proof provides a crucial sanity check.
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\comment{
\section{Change Log}
\begin{itemize}
\item
6 Oct: extended with generic function, as a warm-up for implementing all this in the verifier.
\item
8 Nov: extended with conversion from $\Int$ to $\Bool$.
\item
14 Nov: extended with generic functions.
\item
14 Nov: added wrap as a type constructor.
\item 
20 Nov: rework based on allocated and current types
\item
26 Nov: rework with two subtype relations
\item
27 Nov: rework with ideas from Siek+Taha
\item
todo: check proofs for like, wrap, and int to bool conversions
\item
todo: added typedefs and generics
\item
todo: resolve contravariant subtyping on function domains
\end{itemize}
}
\myclearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Language Overview}

We consider the implementation of a \emph{gradual typed} language that supports both
typed and untyped terms, which interoperate in a flexible manner.
We begin by defining the syntax of terms and types in the language: see Figure~\ref{fig:syntax}.
The language extends  the lambda calculus (variables, abstractions, and application)
with object allocation, dereference, and update. 
It also includes \t{as} expressions, which check that a value has a particular type.
%and \t{wrap} expressions, which, if necessary, wrap the given value to ensure that it behaves like it has that type. 

Some expression forms (variable references, function definitions and applications, and object allocation, dereference, and update, and cast expressions) are annotated with a \emph{check mark} $c\in\setz{\circ,\safe}$,
where $\safe$ means that that expression has been proven \emph{safe} and that no run-time type check is required.
These check marks are inferred/verified by the analysis of Section~\ref{sec:opt}; for now we mostly ignore these check marks, and omit them if they are irrelevant.

The type language includes integers, function types, object types,
and the  type $\dynamic$, which  indicates that no static type information is known.
%The type $\dynobjty$ denotes an object type, where no static type information
%is known about the names of fields of that object.
\comment{
The type $\likety{T}$ describes values whose value components match $T$, but whose type components may be more vague than $T$, due to the presence of the type $\dynamic$. (Due to imperative constructs, that matching-value guarantee does not persist, and so \t{like} types are helpful for debugging but do not provide strong guarantees.)

We include generic function definition, generic function application, and the associated polymorphic types and type variables.
}
%Any value of type $\likety{T}$ can be assigned to a variable to type $\wrapty{T}$,
%but that value is immediate wrapped (if necessary) so that the resulting value is guaranteed to have type $T$. 


\begin{displayfigure}{h}{\label{fig:syntax}Syntax}
\[
\begin{array}{llr}
	\mydefhead{e ::=\qquad\qquad\qquad\qquad\qquad}{Terms:} 
	\mydefcase{n								}{integer constants} 
	\mydefcase{x^c								}{variable} 
	\mydefcase{\lam{c}{x}{S}{T}{e} 				}{abstraction} 
	\mydefcase{\app{c}{e}{e} 					}{application} 
	\mydefcase{\obje{c}{\bar{l}=\bar{e}}{T}		}{object allocation}
	\mydefcase{\objget{c}{e}{l}					}{member selection}
	\mydefcase{\objset{c}{e}{l}{e}				}{member update}
	\mydefcase{\cast{c}{e}{T}					}{runtime type check}
\\
	\mydefhead{S,T::=}{Types:} 
	\mydefcase{\Int 							}{integers}
%	\mydefcase{\Bool							}{booleans}
	\mydefcase{\lamt{S}{T} 					}{function type}
	\mydefcase{\objty{\bar{l}:\bar{T}}	   	}{object types}
	\mydefcase{\dynamic 		    				}{dynamic type}
\end{array}
\]
\end{displayfigure}

%------------------------------------------

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\myclearpage
\section{Type Relations}


\begin{displayfigure}{th}{Subtyping and Compatibility}
\label{fig:subtype}
\begin{trules}
\headtrule{$\subtype{S}{T}$}{Subtyping}
\trule{Sub-Refl}{
	}{
		\subtype{T}{T}
	}
\trule{Sub-Arrow}{
		%\subtype{T_1}{S_1} \qquad
		S_1=T_1 \qquad
		\subtype{S_2}{T_2}
	}{
		\subtype{(\lamt{S_1}{S_2})}{(\lamt{T_1}{T_2})}
	}
\trule{Sub-Obj}{
		%\subtype{T_i}{S_i}\qquad
		%\subtype{S_i}{T_i} 
		S_i=T_i \qquad\mbox{for $i\in 1..n$}
	}{
		\subtype{\objty{l_i:S_i^{i\in 1..n+m}}}
				{\objty{l_i:T_i^{i\in 1..n}}}
	}
\headtrule{$\compatible{S}{T}$}{Compatibility}
\trule{Com-Refl}{
	}{
		\compatible{T}{T}
	}
\trule{Com-Dyn}{
	}{
		\compatible{T}{\dynamic}
	}
\trule{Com-Arrow}{
		\compatible{S_1}{T_1} \qquad
		\compatible{S_2}{T_2}
	}{
		\compatible{(\lamt{S_1}{S_2})}{(\lamt{T_1}{T_2})}
	}
\trule{Com-Obj}{
		\compatible{S_i}{T_i} \qquad\mbox{for $i\in 1..n$}
	}{
		\compatible{\objty{l_i:S_i^{i\in 1..n}}}
				{\objty{l_i:T_i^{i\in 1..n}}}
	}
\end{trules}
\end{displayfigure}

The type system is based in part on the usual subtype relation $\subtype S T$.
We write $S=T$ to mean that $\subtype S T$ and $\subtype T S$.
For technical reasons, function subtyping is \emph{invariant} in the argument position.

In addition, to support a notion of gradual typing, we also have a compatibility relation $\compatible S T$,
which holds provided that $S$ and $T$ are identical except that $T$ may include $\dynamic$ in places where $S$ does not. 
%Unlike the consistency relation of earlier work~\cite{SiekTaha}, o
The compatibility relation is asymmetric since $\compatible \Int \dynamic $ but $\dynamic\not \compatible{}{} \Int$, but is transitive. 

The \emph{compatible-subtyping} relation $\comsubtype S T$ is then the composition of these two relations: $\comsubtype S T$ holds if there exists $U$ such that $\subtype S U$ and $\compatible U T$.

%Similarly, the \emph{consistent-supertype} relation $\csupertype S T$ holds if there exists $U$ such that $S>U$ and $\compatible U T$. These two relations can be defined directly via mutual
 
\begin{lemma}
Subtyping is transitive.
\end{lemma}
\begin{lemma}
Compatibility is transitive.
\end{lemma}
\begin{lemma}
Subtyping and compatibility commute, that is, $(\subtype{}{}\circ \compatible{}{} )=( \compatible{}{}\circ \subtype{}{})$.
\end{lemma}
PROVEME.
\begin{lemma}
Compatible-subtyping is transitive.
\end{lemma}


We have:
\[
\begin{array}{rcl}
	(\lamt{S}{T})  		&\comsubtype{}{}&  (\lamt\dynamic\dynamic) \\
	\objty{l:T,\dots}		& \comsubtype{}{}&  \objty{l:\dynamic} \\
	\objty{\dots}	   	& \comsubtype{}{}&  \objty{} \\
\end{array}
\]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\myclearpage
\section{Evaluation}

We next describe the evaluation semantics of the language. 
The set of values in the language is given by:
\[
\begin{array}{llr}
	\mydefhead{v ::=\qquad\qquad\qquad\qquad\qquad}{Values:} 
	\mydefcase{n								}{integer constant} 
	\mydefcase{\lam{c}{x}{S}{T}{e} 				}{abstraction} 
	\mydefcase{a_T							}{object address with type $T$}
\end{array}
\]
Each object address $a$ is annotated with the type $T$ of the object it points to.
A \emph{object store} $\sigma$ maps object addresses $a_T$ to object values of the form $\objv{\bar{l}=\bar v}$.
Values and object values in the store are \emph{closed} in that they do not contain free program variables $x$;
though they may contain object addresses.

Every value has an \emph{allocated type} according to the function $\allocty{v}$:
\[
\begin{array}{rcll}
		\allocty{n}&=&\Int \\
%		\allocty{b}&=&\Bool\\
		\allocty{\lam{c}{x}{S}{T}{e}}&=&(\lamt{S}{T})\\
		\allocty{a_T}&=&T   
\end{array}
\]
The allocated type of an object is invariant and independent of the store $\sigma$. 
A \emph{type tag} is a type that can be returned by $\allocty{v}$; it includes $\Int$, function, and object types, but excludes $\dynamic$. 
We use the notation $T.l$ to denote $S$ if $T=\objty{l:S,\dots}$, and to denote $\dynamic$ if $T$ is a different object type; in all other cases $T.l$ is undefined.

An evaluation context is:
\[
C ~~::=
\begin{array}[t]{@{}l}
		~~~\hole
%	~|~ 	\lam{}{x}S{C}
	~|~	\app{}{C}{t} 
	~|~	\app{}{v}{C}
%	~|~	\App{C}{T} 
	~|~ \cast{}{C}{T} 
%	~|~ \wrap{C}{T} \\
	~|~ \obje{}{\bar l=\bar v,l=C, \bar l =\bar e}{T}
	~|~ \objget{}{C}{l}
%	~|~ \objcall{C}{l}
	~|~ \objset{}{C}{l}{e}
	~|~ \objset{}{v}{l}{C} 
\end{array}
\]
A \emph{state} is a pair of an object store and a current expression.
The evaluation relation on states is defined by the rules in Figure~\ref{fig:eval}.
For now, these rules ignore the check marks, and always perform dynamic type checks by calling the function $\convert{v}{T}$, which checks if the value $v$ can be converted to the type $T$. 

\begin{displayfigure}{th}{Operational Semantics}
\label{fig:eval} 
\label{fig:convert} 
\footnotesize
{\bf Evaluation Rules}
\[
\begin{array}{@{}rclll}
	\sigma,C[{\app{d}{(\lam{c}{x}{S}{T}{t})}{v}}]
	&\lred&
	\sigma,C[\cast{c}{t[x:=v']}{T}]
	&\mbox{if $v'=\convert v S$}
	&\rel{E-Beta}
\\~\\
	\sigma,C[\cast{c}{v}{T}]
	&\lred&
	\sigma,C[v']
	&\mbox{if $v'=\convert v T$}
	&\rel{E-As}
\\~\\
	\sigma,C[\obje{c}{l_i=v_i^{i\in 1..n}}{T}]
	&\lred&
	\sigma[a_T:=(\objv{l_i=v'_i})],C[a_T] 
	&\mbox{if $v_i'=\convert{v_i}{T.l_i}$, $a_T$ fresh, $T=\objty{\dots}$}
	&\rel{E-Alloc} 
	%&&&\mbox{$T=\objty{l_i:T_i^{i\in 1..n}}$, }
\\~\\
	\sigma,C[\objget{c}{a_T}{l}]
	&\lred&
	\sigma,C[v]
	&\mbox{if $\sigma(a_T)=\objv{l=v,\dots}$}
	&\rel{E-Get}
\\~\\
	\sigma,C[\objset{c}{a_T}{l}{v}]
	&\lred&
	\sigma[a_T,l:=v'],C[v] 
	&\mbox{if $v'=\convert v {T.l}$}
	&\rel{E-Assign} 
\\~\\
\end{array}
\]
{\bf Dynamic Type Checks}
\[
\begin{array}{rcl}
	\convert{v}{T} = v &\mbox{iff}&%\mbox{$\istype v T$} \\
	%\istype{v}{T}      &\mbox{iff}&
	 \mbox{$\comsubtype{\allocty v}{T}$} \\
\end{array}
\]
 \end{displayfigure} 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\myclearpage
\section{Check Optimization}
\label{sec:opt}

In a traditional statically typed language, the type system both detects errors and eliminates dynamic checks.
This presentation separates these two components, primarily so that the check elimination phase 
can be run even in   \t{standard} mode.
 
We first extend the operational semantics to omit \emph{convert} checks on operations labelled with the check mark $\safe$: see Figure~\ref{fig:eval2}. Thus, even though the original rule \rel{E-Beta} can evaluate all applications, \rel{E-Beta-Safe1} provides an optimized evaluation rules for a safe application of a safe function, and \rel{E-Beta-Safe2} and \rel{E-Beta-Safe3} provide alternative rules if only the application or the called function is safe, respectively.

\begin{displayfigure}{h}{Extended Operational Semantics}
\label{fig:eval2} 
\footnotesize
{\bf Evaluation Rules (in addition to those of Figure~\ref{fig:eval})}
\[
\begin{array}{@{}rclll}
	\sigma,C[{\app{\safe}{(\lam{c}{x}{S}{T}{t})}{v}}]
	&\lred&
	\sigma,C[\cast{c}{t[x:=v]}{T}]
	&&\rel{E-Beta-Safe}
\\~\\
	\sigma,C[\cast{\safe}{v}{T}]
	&\lred&
	\sigma,C[v]
	&&\rel{E-As-Safe}
\\~\\
	\sigma,C[\obje{\safe}{l_i=v_i^{i\in 1..n}}{T}]
	&\lred&
	\sigma[a_T:=\objv{l_i=v_i}],C[a_T] 
	&\mbox{$a_T$ fresh}
	&\rel{E-Alloc-Safe} 
	%&&&\mbox{$T=\objty{l_i:T_i^{i\in 1..n}}$, }
\\~\\
	\sigma,C[\objset{\safe}{a_T}{l}{v}]
	&\lred&
	\sigma[a_T,l:=v],C[v] 
	& 
	&\rel{E-Assign-Safe} 
\end{array}
\]
 \end{displayfigure} 


We now sketch a type-based analysis that statically verifies that the check mark $\safe$ is only used in places where the
corresponding dynamic type check is redundant: see Figure~\ref{fig:typerulesopt}. (It is straightforward to rephrase this process to infer check marks.)
These rules rely on the relation $S\Implies T$, which is defined to hold if $\subtype S T$ and $T$ is $\dynamic$-free.
\[
\frac{\subtype S T \qquad \mbox{$T$ is $\dynamic$-free}}
	{\implies S T}
\]

The following lemma states that if a value of allocated type $V$ is in a variable of static type $S$,
and is passed to a context with a static requirement $T$ but underlying dynamic requirement $U$,
then if $\implies S T$ then we know that the value also has type $U$.
 
\begin{lemma}
If $\comsubtype V {S}$ and $S\Implies T$ and $U > U'$ and $\compatible {U'} T$ then $\comsubtype V U$.
\end{lemma}

\begin{lemma}
The $\Implies$ relation is transitive. 
\end{lemma}


\begin{lemma}[No Failure]
For any term $e$ with no $\safe$ annotations, there exists $T$ such that
$\judges{\emptyset}{e}{T}$ .
\end{lemma}
Proof: By induction on the structure of $e$.

\begin{lemma}[Preservation]
If $\judges{}{\sigma,e}{ok}$ and $\sigma,e\lred \sigma',e'$ then $\judges{}{\sigma',e'}{ok}$.
\end{lemma}
PROVEME

\begin{lemma}[Soundness]
If $\judges{}{\sigma,e}{ok}$ then operations marked with $\safe$ can never get stuck.
\end{lemma}
PROVEME

\begin{lemma}[Determinism]
If $\judges{}{\sigma,e}{ok}$ and $\sigma,e\lred \sigma_1,e_1$ and $\sigma,e\lred \sigma_2,e_2$ then (modulo consistent address renamings) $\sigma_1=\sigma_2$ and $e_1=e_2$.
\end{lemma}
PROVEME

\begin{displayfigure}{thp}{Type Rules for Optimization}
\label{fig:typerulesopt}
\footnotesize
\begin{trules}
\headtrule{$\judges{E}{e}{T}$}{\underline{O}ptimization rules for expressions\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\mbox{}}
\trule{O-Var-Safe}{
		(x:T)\in E
	}{
		\judges{E}{x}{T}
	}
\trule{O-Var-Unsafe}{
	}{
		\judges{E}{x}{\dynamic}
	}
\trule{O-Int}{
	}{
		\judges{E}{n}{Int}
	}
\trule{O-Fun-Safe}{
		\judges{E,x:S}{e}{T'} \qquad
		{T'} \Implies {T} 
	}{
		\judges{E}{(\lam{\safe}{x}{S}{T}{e})}{(\lamt{S}{T})}
	}
\trule{O-Fun-Unsafe}{
		\judges{E,x:S}{e}{T'}  
	}{
		\judges{E}{(\lam{\unsafe}{x}{S}{T}{e})}{(\lamt{S}{T})}
	}
\trule{O-App-Safe}{
		\judges{E}{t_1}{(\lamt{S}{T})}\qquad
		\judges{E}{t_2}{S'} \qquad
		{S'}\Implies{S} \\
	%	(k,k')\in\setz{(\likety{},\likety{\!\!}),(\wrapty{},\epsilon),(\epsilon,\epsilon)} \\
	}{
		\judges{E}{\app{\safe}{t_1}{t_2}}{T}
	}
\trule{O-App-Unsafe}{
		\judges{E}{t_1}{S}\qquad
		\judges{E}{t_2}{S'}  
	}{
		\judges{E}{\app{\unsafe}{t_1}{t_2}}{\dynamic}
	}
\trule{O-As}{
		\judges{E}{t}{S}%\qquad 
		%\compatible{S}{T}
	}{
		\judges{E}{\cast{}{t}{T}}{T}
	}
\trule{O-Alloc-Safe}{
		T=\objty{l_i:T_i^{i\in 1..n}} \qquad
		\judges{E}{t_i}{S_i} \qquad
		{S_i}\Implies{T_i}
	}{
		\judges{E}{{(\obje{\safe}{l_i=t_i^{i\in 1..n}}{T})}}{T}
	}
\trule{O-Alloc-Unsafe}{
		\judges{E}{t_i}{S_i} 
	}{
		\judges{E}{(\obje{\unsafe}{l_i=t_i^{i\in 1..n}}{T})}{T}
	}
\trule{O-Get-Safe}{
		\judges{E}{e}{\objty{l:T,\dots}}  
		%k\in\setz{\likety{},\wrapty{},\epsilon}
	}{
		\judges{E}{{\objget{\safe}{e}{l}}}{T}
	}
\trule{O-Get-Unsafe}{
		\judges{E}{e}{S}
	}{
		\judges{E}{\objget{\unsafe}{e}{l}}{\dynamic}
	}
\trule{O-Set-Safe}{
		\judges{E}{e_1}{\objty{l:T,\dots}} \qquad
		\judges{E}{e_2}{S} \qquad
		{S}\Implies{T}  
	}{
		\judges{E}{{(\objset{\safe}{e_1}{l}{e_2})}}{S}
	}
\trule{O-Set-Unsafe}{
		\judges{E}{e_1}{\dynamic} \qquad
		\judges{E}{e_2}{S}
	}{
		\judges{E}{(\objset{\unsafe}{e_1}{l}{e_2})}{S}
	}
\headtrule{$\judges{E}{\sigma,e}{ok}$}{\underline{O}ptimization rules for states}
\trule{O-State}{
		\begin{array}{l}
		\mbox{if~} \sigma(a_T)=\objv{l_i=v_i^{i\in 1..m}} 
		\mbox{~and~} T=\objty{l_i:T_i^{i\in 1..n}}\\
		\mbox{then~}n\leq m
		\mbox{~and~}\forall i\in 1..n.~\judges{\emptyset}{v_i}{S_i}
		\mbox{~and~}\comsubtype{S_i}{T_i} 
		\end{array}
		\qquad\qquad
		\judges{\emptyset}{e}{S}
	}{
		\judges{}{\sigma,e}{ok}
	}
\end{trules}
\end{displayfigure}



%------------------------------------------



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\myclearpage
\section{Strict Mode Type System}

\begin{displayfigure}{th}{Convertibility and Consistency}
\label{fig:convert}
\begin{trules}
\headtrule{$\convertible{S}{T}$}{Convertibility}
\trule{Con-Refl}{
		\subtype S U \qquad
		\consistent U T
	}{
		\convertible{S}{T}
	}
\headtrule{$\consistent{S}{T}$}{Consistency}
\trule{Con-Refl}{
	}{
		\consistent{T}{T}
	}
\trule{Con-Dyn}{
	}{
		\consistent{T}{\dynamic}
	}
\trule{Con-Dyn}{
	}{
		\consistent{\dynamic}{T}
	}
\trule{Con-Arrow}{
		\consistent{S_1}{T_1} \qquad
		\consistent{S_2}{T_2}
	}{
		\consistent{(\lamt{S_1}{S_2})}{(\lamt{T_1}{T_2})}
	}
\trule{Con-Obj}{
		\consistent{S_i}{T_i} \qquad\mbox{for $i\in 1..n$}
	}{
		\consistent{\objty{l_i:S_i^{i\in 1..n}}}
				{\objty{l_i:T_i^{i\in 1..n}}}
	}
\end{trules}
\end{displayfigure}


The strict mode type system is based on a judgement $\judge{E}{e}{T}$,
stating that expression $e$ has type $T$ in environment $E$.
Note that the type $T$ \emph{only} indicates that $e$ \emph{is intended to} produce values of type $T$; it provides no guarantees, 
and the sole purpose of the strict mode type system is to heuristically detect errors at verification time.

The type system is based on the \emph{convertibility relation} $\convertible{S}{T}$ (shown in Figure~\ref{fig:convert})
to see if an expression of static type $S$ can be passed to a context expecting a type $T$.
The relation $\convertible S T$ holds if there exists $U$ such that $\subtype S U$ and $\consistent U T$. 
In turn, the \emph{consistency relation} $\consistent U T$ checks if types $U$ and $T$ are identical, where $\dynamic$ in either $U$ or $T$ matches any type. Thus, consistency extends the compatibility relation, and it is symmetric but not transitive.

\begin{displayfigure}{thp}{Type Rules for Strict Mode}
\label{fig:typerules}
\begin{trules}
\headtrule{$\judge{E}{t}{T}$}{\underline{T}ype rules\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\mbox{}}
\trule{T-Var}{
		(x: T)\in E
	}{
		\judge{E}{x}{T}
	}
\trule{T-Int}{
	}{
		\judge{E}{n}{\Int}
	}
\trule{T-Fun}{
		\judge{E,x:S}{e}{T'} \qquad
		\convertible{T'}{T} 
	}{
		\judge{E}{(\lam{}{x}{S}{T}{e})}{(\lamt{S}{T})}
	}
\trule{T-App1}{
		\judge{E}{t_1}{(\lamt{S}{T})}\qquad
		\judge{E}{t_2}{S'} \qquad
		\convertible{S'}{S} \\
	%	(k,k')\in\setz{(\likety{},\likety{\!\!}),(\wrapty{},\epsilon),(\epsilon,\epsilon)} \\
	}{
		\judge{E}{(\app{}{t_1}{t_2})}{T}
	}
\trule{T-App2}{
		\judge{E}{t_1}{\dynamic}\qquad
		\judge{E}{t_2}{S'}  
	}{
		\judge{E}{(\app{}{t_1}{t_2})}{\dynamic}
	}
\trule{T-As}{
		\judge{E}{t}{S}%\qquad 
		%\compatible{S}{T}
	}{
		\judge{E}{\cast{}{t}{T}}{T}
	}
%\trule{T-Let}{
%		\judge{E}{t_1}{S}\qquad
%		\judge{E,x:S}{t_2}{T} 
%	}{
%		\judge{E}{\letexp{x}{t_1}{t_2}}{T}
%	}
\trule{T-Alloc}{
		\judge{E}{t_i}{S_i} \qquad
		\convertible{S_i}{T_i} \qquad
		T=\objty{l_i:T_i^{i\in 1..n}}
	}{
		\judge{E}{(\obje{}{l_i=t_i^{i\in 1..n}}{T})}{T}
	}
\trule{T-Get1}{
		\judge{E}{e}{\objty{l:T,\dots}}  
		%k\in\setz{\likety{},\wrapty{},\epsilon}
	}{
		\judge{E}{\objget{}{e}{l}}{T}
	}
\trule{T-Get2}{
		\judge{E}{e}{\dynamic}
	}{
		\judge{E}{\objget{}{e}{l}}{\dynamic}
	}
\trule{T-Set1}{
		\judge{E}{e_1}{\objty{l:T,\dots}} \qquad
		\judge{E}{e_2}{S} \qquad
		\convertible{S}{T}  
	}{
		\judge{E}{\objset{}{e_1}{l}{e_2}}{S}
	}
\trule{T-Set2}{
		\judge{E}{e_1}{\dynamic} \qquad
		\judge{E}{e_2}{S}
	}{
		\judge{E}{\objset{}{e_1}{l}{e_2}}{S}
	}
\end{trules}
\end{displayfigure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\myclearpage
\section{Extensions}

We now extend the language and type language with \t{like} types, \t{wrap} types, and implicit int-to-boolean conversions:
\[
\begin{array}{llr}
	\mydefhead{e ::=~\dots\qquad\qquad\qquad\qquad\qquad}{Terms:} 
	\mydefcase{b								}{boolean constants} 
	\mydefcase{\wrap e T						}{wrap operation} 
\\
	\mydefhead{v::=~\dots}{Values:} 
	\mydefcase{b								}{boolean constants} 
	\mydefcase{\wrapv{v}{T} 					}{wrapped value}
\\
	\mydefhead{C::=~\dots}{Evaluation Contexts:} 
	\mydefcase{\wrap{C}{T} 					}{wrap operation}
\\
	\mydefhead{S,T::=~\dots}{Types:} 
	\mydefcase{\Bool							}{booleans}
	\mydefcase{\likety{T} 					}{like type}
	\mydefcase{\wrapty{T} 					}{wrap type}
\end{array}
\]
We add the following evaluation rules. Note that when operating on a wrapped value, the check mark $c$ on the operation is irrelevant and so ignored.
\[
\begin{array}{@{}rcllr}
	\sigma,C[\wrap v T]
	&\lred&
	\sigma,C[\wrapv v T]
	&\mbox{($T$ a fn or obj type)}
	&\rel{E-Wrap}
\\
	\sigma,C[{\app{c}{(\wrapv{w}{(\lamt{S}{T})})}
	              {v}}]
	&\lred&
	\sigma,C[\wrap{\app{\unsafe}{w}{(\wrap{v}{S})}}{T}]
	&&\rel{E-Beta-w}
\\
	\sigma,C[\objget{c}{(\wrapv{w}{\objty{l:T,\dots}})}{l}]
	&\lred&
	\sigma,C[\wrap{(\objget{\unsafe}{w}{l})}{T}] 
	&&\rel{E-Get-w}
\\
	\sigma,C[\objset{c}{(\wrapv{w}{\objty{l:T,\dots}})}{l}{v}]
	&\lred&
	\sigma,C[\objset{\unsafe}{w}{l}{(\wrap v T)}]
	&&\rel{E-Assign-w} \\
\end{array}
\]
The allocated types of the additional values is given by:
\[
\begin{array}{rcll}
		\allocty{b}&=&\Bool\\
		\allocty{\wrapv v T}&=&T   
\end{array}
\]
For subtyping, $\likety{S}$ is a supertype of $S$ (describes more values) and is covariant. $\wrapty T$ is a subtype of $T$, since it describes certain kinds of $T$ values. 
%
\begin{trules}
%\headtrule{$\subtype{S}{T}$}{Subtyping}
\trule{Sub-Like-Inc}{
		\subtype S T 
	}{
		\subtype S {\likety T}
	}
\trule{Sub-Like-Cov}{
		\subtype S T 
	}{
		\subtype {\likety S} {\likety T}
	}
\trule{Sub-Wrap}{
		\subtype S T
	}{
		\subtype {\wrapty S} T
	}
\end{trules}
%
We extend compatibility and consistency to \t{like} and \t{wrap} types.
%
\begin{trules}
%\headtrule{$\compatible{S}{T}$}{Compatibility}
\trule{Com-Like}{
		\compatible S T
	}{
		\compatible{\likety S}{\likety T}
	}
\trule{Com-Like}{
		\compatible S T
	}{
		\compatible{\wrapty S}{\wrapty T}
	}
\trule{Con-Like}{
		\consistent S T
	}{
		\consistent{\likety S}{\likety T}
	}
\trule{Con-Like}{
		\consistent S T
	}{
		\consistent{\wrapty S}{\wrapty T}
	}
\end{trules} 
%
We extend the convertibility relation to allow int-to-boolean conversions:
%
\begin{trules}
\trule{Conv-Int-Bool}{
	}{
		\convertible{\Int}{\Bool}
	}
\end{trules}
We extend \fun{convert} as follows:
\[
\begin{array}{rcll}
	\convert{v}{T} 		&=& v 		&\mbox{if $\istype v T$} \\
	\convert{0}{\Bool} &=& \false \\
	\convert{n}{\Bool} &=& \true 	 &n\not=0\\
	\convert{v}{\wrapty T} &=& v	&\mbox{if $\istype v T$} \\
	\convert{v}{\wrapty T} &=& \wrap{v}{T}	&\mbox{if $\istype v {\likety T}$} \\
%	\\
%	\istype{v}{T}   &\mbox{if}& \comsubtype{\allocty v}{T} \\
%	\istype{a_S}{T} &\mbox{if}& \sigma(a)=\objv{l_i:v_i} \mbox{ and }T=\objty{l_i:T_i} \mbox{ and } \istype {v_i}{\likety{T_i}}
\end{array}
\]
The new relation $\istype{v}{T}$ checks if the value $v$ matches the type $T$:
\begin{trules}
%\headtrule{$\istype{v}{T}$}{Dynamic type check}
\trule{Is-Ok}{
		\comsubtype{\allocty{v}}{T}
	}{
		\istype{v}{T}
	}
\trule{Is-Like}{
		\sigma(a_S) = \objv{l_i=v_i^{i\in 1..n+m}} \\
	%	\compatible{S}{\objty{l_i:T_i^{i\in 1..n}}} \\
		\istype{v_i}{\likety{T_i}} \mbox{ ~for~} {i\in 1..n}
	}{
		\istype{a_S}{\likety \objty{l_i:T_i^{i\in 1..n}}}
	}
\end{trules}
%
We add the type checking and optimization rules for the wrap operation and boolean constants:
\begin{trules}
\trule{O-Bool}{
	}{
		\judges{E}{b}{\Bool}
	}
\trule{O-Wrap}{
		\judges{E}{t}{S}%\qquad 
		%\compatible{S}{T}
	}{
		\judges{E}{\wrap{t}{T}}{T}
	}
\trule{T-Bool}{
	}{
		\judge{E}{b}{\Bool}
	}
\trule{T-Wrap}{
		\judge{E}{t}{S}%\qquad 
		%\compatible{S}{T}
	}{
		\judge{E}{\wrap{t}{T}}{T}
	}
\end{trules}
We conjecture (but have not proved!) that the resulting system then behaves as intended. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}
 
