ECMAScript 4th Edition Grammar			
			
ID		SURFACE SYNTAX	
			
LEXICAL STRUCTURE			
			
		ReservedIdentifier [one of]	
1			break case catch class continue default delete do else enum extends false 
2			finally for function if in instanceof new null return super switch this throw
3			true try typeof var void while with 
			
		ContextuallyReservedIdentifier [one of]	
4			call cast const debugger decimal double dynamic each eval final get goto has
5			implements import include int interface internal intrinsic is let namespace 
6			native Number override package precision private protected prototype public 
7			rounding standard strict to set static to type uint undefined use xml yield
			
		Punctuator [one of]	
8			.   ..   …   !   !=   !==   %   %=   &   &=   &&   &&=   *   *=   +   +=   ++   -   --   -=   
9			/   /=   ,   :   ::   ;   <   <=   <<   <<=   =   ==   ===   >   >=   >>   >>=   >>>   >>>=   
10			^   ^=   |   |=   ||   ||=   ?   (   )   [   ]   {   }   ~   @   </   />   .<
			
		VirtualSemicolon	
11			[If the first through the nth tokens of an ECMAScript program form are grammatically valid but the first through the n+1st tokens are not and there is a line break between the nth tokens and the n+1st tokens, then the parser tries to parse the program again after inserting a VirtualSemicolon token between the nth and the n+1st tokens]
			
		Identifier	
12			[see Ecma-262 section 7.6]
			
		StringLiteral	
13			[see Ecma-262 section 7.8.4]
			[see Triple-quoted strings: http://developer.mozilla.org/es4/proposals/triple_quotes.html]
			
		NumberLiteral	
14			[see Ecma-262 section 7.8.3] todo: type suffixes
			
		RegularExpression	
15			[see Ecma-262 section 7.8.5]
16			[see Extend RegExp: http://developer.mozilla.org/es4/proposals/extend_regexps.html]
			
		XMLMarkup	
17			[see Ecma-357 section 8.3]
			
		XMLText	
18			[see Ecma-357 section 8.3]
			
		XMLWhitespace	
19			[see Ecma-357 section 8.3]
			
		XMLName	
20			[see Ecma-357 section 8.3]
			
		XMLAttributeValue	
21			[see Ecma-357 section 8.3]
			
SYNTACTIC STRUCTURE			
			
		EXPRESSIONS	
			
		a = { allowList, noList }	
		b = { allowIn, noIn }	
		g = { allowExpr, noExpr }	
			
		Identifier	
1			Identifier
2			ContextuallyReservedIdentifier
			
		Qualifier	
3			*
4			ReservedNamespace
5			Identifier
			
		ReservedNamespace	
6			internal
7			intrinsic
8			private
9			protected
10			public
			
		SimpleQualifiedIdentifier	
11			*
12			Identifier
13			Qualifier  ::  *
14			Qualifier  ::  Identifier
15			Qualifier  ::  ReservedIdentifier
16			Qualifier  ::  Brackets
17			intrinsic  ::  OverloadedOperator
			
		ExpressionQualifiedIdentifier	
18			ParenListExpression  ::  *
19			ParenListExpression  ::  Identifier
20			ParenListExpression  ::  ReservedIdentifier
21			ParenListExpression  ::  Brackets
			
		NonAttributeQualifiedIdentifier	
22			SimpleQualifiedIdentifier
23			ExpressionQualifiedIdentifier
			
		AttributeIdentifier	
24			@  Brackets
25			@  NonAttributeQualifiedIdentifier
			
		QualifiedIdentifier	
26			AttributeIdentifier
27			NonAttributeQualifiedIdentifier
			
		PropertyIdentifier	
28			NonAttributeQualifiedIdentifier
29			NonAttributeQualifiedIdentifier  .<  TypeExpressionList  >
30			(  TypeExpression  )  .<  TypeExpressionList  >
			
		PrimaryIdentifier	
31			Path  .  PropertyIdentifier
32			PropertyIdentifier
			
		Path	
33			Identifier
34			Path  .  Identifier
			
		ParenExpression	
35			(  AssignmentExpressionallowList, allowIn  )
			
		ParenListExpression	
36			(  ListExpressionallowIn  )
			
		FunctionExpressionallowList, b	
37			function  Identifier  FunctionSignature  FunctionBodyb
38			function  FunctionSignature  FunctionBodyb
			
		FunctionExpressionnoList, b	
39			function  Identifier  FunctionSignature  FunctionBodyb
40			function  FunctionSignature  FunctionBodyb
			
		ObjectLiteral	
41			{  Fields  }
42			{  Fields  }  :  TypeExpression
			
		Fields	
43			«empty»
44			FieldList
			
		FieldList	
45			LiteralField
46			LiteralField  ,  FieldList
			
		LiteralField	
47			FieldKind  FieldName  :  AssignmentExpressionnoList, allowIn
48			get  Identifier  FunctionSignature  FunctionBody
49			set  Identifier  FunctionSignature  FunctionBody
			
		FieldKind	
50			«empty»
51			const
			
		FieldName	
52			Identifier
53			StringLiteral
54			NumberLiteral
55			ReservedIdentifier
			
		ArrayLiteral	
56			[  Elements  ]
57			[  Elements  ]  :  TypeExpression
			
		Elements	
58			ElementList
59			ElementComprehension
			
		ElementList	
60			«empty»
61			LiteralElement
62			,  ElementList
63			LiteralElement  ,  ElementList
			
		LiteralElement	
64			AssignmentExpressionnoList, allowIn
			
		ElementComprehension	
65			LiteralElement  ForExpressionList  IfExpression
			
		ForInExpressionList	
66			ForExpression
67			ForExpressionList  ForExpression
			
		ForInExpression	
68			for  (  ForInBinding  in  ListExpressionallowIn  )
69			for  each  (  ForInBinding  in  ListExpressionallowIn  )
			
		XMLInitialiser	
70			XMLMarkup
71			XMLElement
72			<  >  XMLElementContent  </  >
			
		XMLElementContent	
73			XMLMarkup  XMLElementContentopt
74			XMLText  XMLElementContentopt
75			XMLElement  XMLElementContentopt
76			{  ListExpressionallowIn  }  XMLElementContentopt
			
		XMLElement	
77			<  XMLTagContent  XMLWhitespaceopt  />
78			<  XMLTagContent  XMLWhitespaceopt  >  XMLElementContent
79			              </  XMLTagName  XMLWhitespaceopt  >
			
		XMLTagContent	
80			XMLTagName  XMLAttributes
			
		XMLTagName	
81			{  ListExpressionallowIn  }
82			XMLName
			
		XMLAttributes	
83			XMLWhitespace  {  ListExpressionallowIn  }
84			XMLAttribute  XMLAttributes
85			«empty»
			
		XMLAttribute	
86			XMLWhitespace  XMLName  XMLWhitespaceopt  =  XMLWhitespaceopt  {  ListExpressionallowIn  }
87			XMLWhitespace  XMLName  XMLWhitespaceopt  =  XMLWhitespaceopt  XMLAttributeValue
			
		XMLElementContent	
88			{  ListExpressionallowIn  }  XMLElementContent
89			XMLMarkup  XMLElementContent
90			XMLText  XMLElementContent
91			XMLElement  XMLElementContent
92			«empty»
			
		PrimaryExpressiona, b	
93			null
94			true
95			false
96			NumberLiteral
97			StringLiteral
98			this
99			RegularExpression
100			XMLInitialiser
101			ParenListExpression
102			ArrayLiteral
103			ObjectLiteral
104			FunctionExpressiona, b
105			AttributeIdentifier
106			PrimaryIdentifier
			
		SuperExpression	
107			super
108			super  ParenExpression
			
		MemberExpressiona, b	
109			PrimaryExpressiona, b
110			new  MemberExpressiona, b  Arguments
111			SuperExpression  PropertyOperator
112			MemberExpressiona, b  PropertyOperator
			
		CallExpressiona, b	
113			MemberExpressiona, b  Arguments
114			CallExpressiona, b  Arguments
115			CallExpressiona, b  PropertyOperator
			
		NewExpressiona, b	
116			MemberExpressiona, b
117			new  NewExpressiona, b
			
		Arguments	
118			(  )
119			(  ArgumentList  )
			
		ArgumentList	
120			AssignmentExpressionnoList, allowIn
121			ArgumentList  ,  AssignmentExpressionnoList, allowIn
			
		PropertyOperator	
122			.  ReservedIdentifier
123			.  PropertyIdentifier
124			.  AttributeIdentifier
125			..  QualifiedIdentifier
126			.  ParenListExpression
127			.  ParenListExpression  ::  *
128			.  ParenListExpression  ::  Identifier
129			.  ParenListExpression  ::  ReservedIdentifier
130			.  ParenListExpression  ::  Brackets
131			Brackets
			
		Brackets	
132			[  ListExpressionallowIn  ]
133			[  SliceExpression   ]
			
		SliceExpression	
134			OptionalExpression  :  OptionalExpression
135			OptionalExpression  :  OptionalExpression  :  OptionalExpression
			
		OptionalExpression	
136			ListExpressionallowIn
137			«empty»
			
		LeftHandSideExpressiona, b	
138			NewExpressiona, b
139			CallExpressiona, b
			
		PostfixExpressiona, b	
140			LeftHandSideExpressiona, b
141			LeftHandSideExpressiona, b  [no line break]  ++
142			LeftHandSideExpressiona, b  [no line break]  --
			
		UnaryExpressiona, b	
143			PostfixExpressiona, b
144			delete  PostfixExpressiona, b
145			void  UnaryExpressiona, b
146			typeof  UnaryExpressiona, b
147			++   PostfixExpressiona, b
148			--  PostfixExpressiona, b
149			+  UnaryExpressiona, b
150			-  UnaryExpressiona, b
151			~  UnaryExpressiona, b
152			!  UnaryExpressiona, b
153			type  NullableTypeExpression
			
		MultiplicativeExpressiona, b	
154			UnaryExpressiona, b
155			MultiplicativeExpressiona, b  *  UnaryExpressiona, b
156			MultiplicativeExpressiona, b  /  UnaryExpressiona, b
157			MultiplicativeExpressiona, b  %  UnaryExpressiona, b
			
		AdditiveExpressiona, b	
158			MultiplicativeExpressiona, b
159			AdditiveExpressiona, b  +  MultiplicativeExpressiona, b
160			AdditiveExpressiona, b  -  MultiplicativeExpressiona, b
			
		ShiftExpressiona, b	
161			AdditiveExpressiona, b
162			ShiftExpressiona, b  <<  AdditiveExpressiona, b
163			ShiftExpressiona, b  >>  AdditiveExpressiona, b
164			ShiftExpressiona, b  >>>  AdditiveExpressiona, b
			
		RelationalExpressiona, allowIn	
165			ShiftExpressiona, b
166			RelationalExpressiona, allowIn  <  ShiftExpressiona, b
167			RelationalExpressiona, allowIn  >  ShiftExpressiona, b
168			RelationalExpressiona, allowIn  <=  ShiftExpressiona, b
169			RelationalExpressiona, allowIn  >=  ShiftExpressiona, b
170			RelationalExpressiona, allowIn  in  ShiftExpressiona, b
171			RelationalExpressiona, allowIn  instanceof  ShiftExpressiona, b
172			RelationalExpressiona, allowIn  cast  TypeExpression
173			RelationalExpressiona, allowIn  to  TypeExpression
174			RelationalExpressiona, allowIn  is  TypeExpression
			
		RelationalExpressiona, noIn	
175			ShiftExpressiona, b
176			RelationalExpressiona, noIn  <  ShiftExpressiona, b
177			RelationalExpressiona, noIn  >  ShiftExpressiona, b
178			RelationalExpressiona, noIn  <=  ShiftExpressiona, b
179			RelationalExpressiona, noIn  >=  ShiftExpressiona, b
180			RelationalExpressiona, noIn  instanceof  ShiftExpressiona, b
181			RelationalExpressiona, noIn  cast  TypeExpression
182			RelationalExpressiona, noIn  to  TypeExpression
183			RelationalExpressiona, noIn  is  TypeExpression
			
		EqualityExpressiona, b	
184			RelationalExpressiona, b
185			EqualityExpressiona, b  ==  RelationalExpressiona, b
186			EqualityExpressiona, b  !=  RelationalExpressiona, b
187			EqualityExpressiona, b  ===  RelationalExpressiona, b
188			EqualityExpressiona, b  !==  RelationalExpressiona, b
			
		BitwiseAndExpressiona, b	
189			EqualityExpressiona, b
190			BitwiseAndExpressionra, b  &  EqualityExpressiona, b
			
		BitwiseXorExpressiona, b	
191			BitwiseAndExpressiona, b
192			BitwiseXorExpressiona, b  ^  BitwiseAndExpressiona, b
			
		BitwiseOrExpressiona, b	
193			BitwiseXorExpressiona, b
194			BitwiseOrExpressiona, b  |  BitwiseXorExpressiona, b
			
		LogicalAndExpressiona, b	
195			BitwiseOrExpressiona, b
196			LogicalAndExpressiona, b  &&  BitwiseOrExpressiona, b
			
		LogicalOrExpressiona, b	
197			LogicalAndExpressiona, b
198			LogicalOrExpressiona, b  ||  LogicalOrExpressiona, b
			
		ConditionalExpressionallowList, b	
199			LetExpressionb
200			YieldExpressionb
201			LogicalOrExpressiona, b
202			LogicalOrExpressionallowList, b  ?  AssignmentExpressionallowList, b  
203			                                                :  AssignmentExpressionallowList, b
			
		ConditionalExpressionnoList, b	
204			SimpleYieldExpression
205			LogicalOrExpressionnoList, b
206			LogicalOrExpressionnoList, b  ?  AssignmentExpressionnoList, b
207			                                             :  AssignmentExpressionnoList, b
			
		NonAssignmentExpressionallowList, b	
208			LetExpressionb
209			YieldExpressionb
210			LogicalOrExpressionallowList, b
211			LogicalOrExpressionallowList, b  ?  NonAssignmentExpressionallowList, b  
212			                                                :  NonAssignmentExpressionallowList, b
			
		NonAssignmentExpressionnoList, b	
213			SimpleYieldExpression
214			LogicalOrExpressionnoList, b
215			LogicalOrExpressionnoList, b  ?  NonAssignmentExpressionnoList, b
216			                                             :  NonAssignmentExpressionnoList, b
			
		LetExpressionb	
217			let  (  LetBindingList  )  ListExpressionb
			
		LetBindingList	
218			«empty»
219			NonemptyLetBindingListallowList
			
		NonemptyLetBindingLista	
220			VariableBindinga, allowIn
221			VariableBindingnoList, allowIn  ,  NonemptyLetBindingLista
			
		YieldExpressionb	
222			yield
223			yield  [no line break]  ListExpressionb
			
		SimpleYieldExpression	
224			yield
			
		AssignmentExpressiona, b	
225			ConditionalExpressiona, b
226			Patterna, b, allowExpr  =  AssignmentExpressiona, b
227			SimplePatterna, b, allowExpr  CompoundAssignmentOperator  AssignmentExpressiona, b
			
		CompoundAssignmentOperator	
228			*=
229			/=
230			%=
231			+=
232			-=
233			<<=
234			>>=
235			>>>=
236			&=
237			^=
238			|=
239			&&=
240			||=
			
		ListExpressionb	
241			AssignmentExpressionallowList, b
242			ListExpressionb  ,  AssignmentExpressionallowList, b
			
		PATTERNS	
			
		Patterna, b, g	
243			SimplePatterna, b, g
244			ObjectPatterng
245			ArrayPatterng
			
		SimplePatterna, b, noExpr	
246			Identifier
			
		SimplePatterna, b, allowExpr	
247			LeftHandSideExpressiona, b
			
		ObjectPatterng	
248			{  DestructuringFieldListg  }
			
		DestructuringFieldListg	
249			«empty»
250			DestructuringFieldg
251			DestructuringFieldListg  ,  DestructuringFieldg
			
		DestructuringFieldg	
252			FieldName  :  PatternnoList, allowIn, g
			
		ArrayPatterng	
253			[  DestructuringElementListg  ]
			
		DestructuringElementListg	
254			«empty»
255			DestructuringElementg
256			, DestructuringElementListg
257			DestructuringElementg  ,  DestructuringElementListg
			
		DestructuringElementg	
258			PatternnoList, allowIn, g
			
		TypedIdentifier	
259			SimplePatternnoList, noIn, noExpr
260			SimplePatterna, b, noExpr  :  TypeExpression
			
		TypedPatterna, b	
261			SimplePatterna, b, noExpr
262			SimplePatterna, b, noExpr  :  NullableTypeExpression
263			ObjectPatternnoExpr
264			ObjectPatternnoExpr  :  TypeExpression
265			ArrayPatternnoExpr
266			ArrayPatternnoExpr  :  TypeExpression
			
		TYPE EXPRESSIONS	
			
		NullableTypeExpression	
267			null
268			undefined
269			TypeExpression
270			TypeExpression  ?
271			TypeExpression  !
			
		TypeExpression	
272			FunctionType
273			UnionType
274			RecordType
275			ArrayType
276			PrimaryIdentifier
			
		FunctionType	
277			function  FunctionSignatureType
			
		FunctionSignatureType	
278			TypeParameters  (  ParametersType  )  ResultType
279			TypeParameters  (  this  :  PrimaryIdentifier  )  ResultType
280			TypeParameters  (  this  :  PrimaryIdentifier  ,  NonemptyParametersType  )  ResultType
			
		ParametersType	
281			«empty»
282			NonemptyParametersType
			
		NonemptyParametersType	
283			ParameterInitType
284			ParameterInitType  ,  NonemptyParametersType
285			RestParameterType
			
		ParameterInitType	
286			ParameterType
287			ParameterType  =
			
		ParameterType	
288			NullableTypeExpression
			
		RestParameterType	
289			...
290			...  ParameterType
			
		UnionType	
291			(  TypeExpressionList  )
			
		RecordType	
292			{  FieldTypeList  }
			
		FieldTypeList	
293			«empty»
294			NonemptyFieldTypeList
			
		NonemptyFieldTypeList	
295			FieldType
296			FieldType  ,  NonemptyFieldTypeList
			
		FieldType	
297			FieldName  :  NullableTypeExpression
			
		ArrayType	
298			[  ElementTypeList  ]
			
		ElementTypeList	
299			«empty»
300			NullableTypeExpression
301			,  ElementTypeList
302			NullableTypeExpression  ,  ElementTypeList
			
		TypeExpressionList	
303			NullableTypeExpression
304			TypeExpressionList  ,  NullableTypeExpression
			
		STATEMENTS	
		w =  {abbrev, noShortIf, full}	
			
		Statementt, w	
305			BlockStatementt
306			BreakStatement Semicolonw
307			ContinueStatement Semicolonw
308			DefaultXMLNamespaceStatement Semicolonw
309			DoStatement Semicolonw
310			ExpressionStatement Semicolonw
311			ForStatementw
312			IfStatementw
313			LabeledStatementw
314			LetStatementw
315			ReturnStatement Semicolonw
316			SwitchStatement
317			ThrowStatement Semicolonw
318			TryStatement
319			WhileStatementw
320			WithStatementw
			
		Substatementw	
321			EmptyStatement
322			Statementw
			
		Semicolonabbrev 	
323			;
324			VirtualSemicolon
325			«empty»
			
		SemicolonnoShortIf	
326			;
327			VirtualSemicolon
328			«empty»
			
		Semicolonfull	
329			;
330			VirtualSemicolon
			
		EmptyStatement 	
331			;
			
		ExpressionStatement	
332			[lookahead !{ function, { }] ListExpressionallowIn
			
		BlockStatementt	
333			Blockt
			
		LabeledStatementw	
334			Identifier  :  Substatementw
			
		IfStatementabbrev	
335			if ParenListExpression Substatementabbrev
336			if ParenListExpression SubstatementnoShortIf else Substatementabbrev
			
		IfStatementfull	
337			if ParenListExpression Substatementfull
338			if ParenListExpression SubstatementnoShortIf else Substatementfull
			
		IfStatementnoShortIf	
339			if ParenListExpression SubstatementnoShortIf else SubstatementnoShortIf
			
		SwitchStatement	
340			switch ParenListExpression  {  CaseElements  }
341			switch  type  (  ListExpressionallowList, allowIn  :  TypeExpression  ) 
342			     {  TypeCaseElements  }
			
		CaseElements	
343			«empty»
344			CaseLabel
345			CaseLabel CaseElementsPrefix CaseLabel
346			CaseLabel CaseElementsPrefix Directiveabbrev
			
		CaseElementsPrefix	
347			«empty»
348			CaseElementsPrefix  CaseLabel
349			CaseElementsPrefix  Directivefull
			
		CaseLabel	
350			case ListExpressionallowIn :
351			default :
			
		TypeCaseElements	
352			TypeCaseElement
353			TypeCaseElements  TypeCaseElement
			
		TypeCaseElement	
354			case  (  TypedPatternnoList, noIn  )  Blocklocal
355			default  Blocklocal
			
		DoStatement	
356			do Substatementabbrev while ParenListExpression
			
		WhileStatementw	
357			while ParenListExpression Substatementw
			
		ForStatementw	
358			for  (  ForInitialiser  ;  OptionalExpression  ;  OptionalExpression  )  Substatementw
359			for  (  ForInBinding  in  ListExpressionallowIn  )  Substatementw
360			for  each  ( ForInBinding  in  ListExpressionallowIn  )  Substatementw
			
		ForInitialiser	
361			«empty»
362			ListExpressionnoIn
363			VariableDefinitionnoIn
			
		ForInBinding	
364			PatternallowList, noIn, allowExpr
365			VariableDefinitionKind VariableBindingallowList, noIn
			
		LetStatementw	
366			let  (  LetBindingList  )  Substatementw
			
		WithStatementw	
367			with  (  ListExpressionallowIn  )  Substatementw
368			with  (  ListExpressionallowIn  :  TypeExpression  )  Substatementw
			
		ContinueStatement	
369			continue
370			continue [no line break] Identifier
			
		BreakStatement	
371			break
372			break [no line break] Identifier
			
		ReturnStatement	
373			return
374			return [no line break] ListExpressionallowIn
			
		ThrowStatement 	
375			throw  ListExpressionallowIn
			
		TryStatement	
376			try  Blocklocal  CatchClauses
377			try  Blocklocal  CatchClauses  finally  Blocklocal
378			try  Blocklocal  finally  Blocklocal
			
		CatchClauses	
379			CatchClause
380			CatchClauses CatchClause
			
		CatchClause	
381			catch  (  Parameter  )  Blocklocal
			
		DefaultXMLNamespaceStatement	
382			default  xml  namespace  =  NonAssignmentExpressionallowList, allowIn
			
		DIRECTIVES	
			
		t = { global, class, interface, local }	
			
		Directivest	
383			«empty»
384			DirectivesPrefixt  Directivet, abbrev
			
		DirectivesPrefixt	
385			«empty»
386			Pragmas
387			DirectivesPrefixt  Directivet, full
			
		Directivet, w	
388			EmptyStatement
389			Statementw
390			AnnotatableDirectivet, w
391			Attributest  [no line break]  AnnotatableDirectivet, w
			
		AnnotatableDirectiveglobal, w	
392			VariableDefinitionallowIn  Semicolonw
393			FunctionDefinitionglobal
394			ClassDefinition
395			InterfaceDefinition
396			NamespaceDefinition  Semicolonw
397			TypeDefinition  Semicolonw
			
		AnnotatableDirectiveinterface, w	
398			FunctionDeclaration  Semicolonw
399			TypeDefinition  Semicolonw
			
		AnnotatableDirectivet, w	
400			VariableDefinitionallowIn  Semicolonw
401			FunctionDefinitiont
402			NamespaceDefinition  Semicolonw
403			TypeDefinition  Semicolonw
			
		Attributest	
404			Attributet
405			Attributet  [no line break]  Attributest
			
		Attributeglobal	
406			NamespaceAttribute
407			dynamic
408			final
409			native
410			[  AssignmentExpressionallowList, allowIn  ]
			
		Attributeclass	
411			NamespaceAttribute
412			final
413			native
414			override
415			prototype
416			static
417			[  AssignmentExpressionallowList, allowIn  ]
			
		Attributeinterface	
418			«empty»
			
		Attributelocal	
419			«empty»
			
		NamespaceAttributeglobal	
420			public
421			internal
422			intrinsic
423			Path  .  Identifier
424			Identifier
			
		NamespaceAttributeclass	
425			ReservedNamespace
426			Path  .  Identifier
427			Identifier
			
		DEFINITIONS	
			
		VariableDefinitionb	
428			VariableDefinitionKind  VariableBindingListallowList, b
			
		VariableDefinitionKind	
429			const
430			let
431			let const
432			var
			
		VariableBindingLista, b	
433			VariableBindinga, b
434			VariableBindingListnoList, b  ,  VariableBindinga, b
			
		VariableBindinga, b	
435			TypedIdentifier
436			TypedPatternnoList, noIn  VariableInitialisationa, b
			
		VariableInitialisationa, b	
437			=  AssignmentExpressiona, b
			
		FunctionDeclaration	
438			function  FunctionName  FunctionSignature
			
		FunctionDefinitionclass	
439			function  ClassName  ConstructorSignature  FunctionBodyallowIn
440			function  FunctionName  FunctionSignature  FunctionBodyallowIn
			
		FunctionDefinitiont	
441			function  FunctionName  FunctionSignature  FunctionBodyallowIn
442			let  function  FunctionName  FunctionSignature  FunctionBodyallowIn
443			const  function  FunctionName  FunctionSignature  FunctionBodyallowIn
			
		FunctionName	
444			Identifier
445			OverloadedOperator
446			get  Identifier
447			set  Identifier
			
		OverloadedOperator  [one of]	
448			+   -   ~   *   /   %   <   >   <=   >=   ==   <<   >>   >>>   &   |   ===   !=   !==
			
		FunctionSignature	
449			TypeParameters  (  Parameters  )  ResultType
450			TypeParameters  (  this  :  PrimaryIdentifier  )  ResultType
451			TypeParameters  (  this  :  PrimaryIdentifier  ,  NonemptyParameters  )  ResultType
			
		TypeParameters	
452			«empty»
453			.<  TypeParameterList  >  
			
		TypeParametersList	
454			Identifier
455			Identifier  ,  TypeParameterList
			
		Parameters	
456			«empty»
457			NonemptyParameters
			
		NonemptyParameters	
458			ParameterInit
459			ParameterInit  ,  NonemptyParameters
460			RestParameter
			
		ParameterInit	
461			Parameter
462			Parameter  =  NonAssignmentExpressionnoList, allowIn
			
		Parameter	
463			ParameterKind TypedPatternnoList, noIn
			
		ParameterKind	
464			«empty»
465			const
			
		RestParameter	
466			...
467			...  Parameter
			
		ResultType	
468			«empty»
469			:  void
470			:  NullableTypeExpression
			
		ConstructorSignature	
471			TypeParameters  (  Parameters  )
472			TypeParameters  (  Parameters  )  :  ConstructorInitialiser
			
		ConstructorInitialiser	
473			InitialiserList
474			InitialiserList  SuperInitialiser
475			SuperInitialiser
			
		ToSignature	
476			TypeParameters  (  Parameters  )
			
		InitaliserList	
477			Initialiser
478			InitialiserList  ,  Initialiser
			
		Initialiser	
479			PatternnoList, noIn, noExpr  VariableInitialisationnoList, allowIn
			
		SuperInitialiser	
480			super Arguments
			
		FunctionBodyb	
481			Blocklocal
482			ListExpressionb
			
		ClassDefinition	
483			class  ClassName  ClassInheritance  ClassBody
			
		ClassName	
484			ParameterisedTypeName
485			ParameterisedTypeName  !
			
		ParameterisedTypeName	
486			Identifier
487			Identifier  TypeParameters
			
		ClassInheritance	
488			«empty»
489			extends  PrimaryIdentifier
490			implements  TypeIdentifierList
491			extends  PrimaryIdentifier  implements  TypeIdentifierList
			
		TypeIdentifierList	
492			PrimaryIdentifier
493			PrimaryIdentifier  ,  TypeIdentifierList
			
		ClassBody	
494			Blockclass
			
		InterfaceDefinition	
495			interface  ClassName  InterfaceInheritance  InterfaceBody
			
		InterfaceInheritance	
496			«empty»
497			extends  TypeIdentifierList
			
		InterfaceBody	
498			Blockinterface
			
		NamespaceDefinition	
499			namespace  Identifier  NamespaceInitialisation
			
		NamespaceInitialisation	
500			«empty»
501			=  StringLiteral
502			=  SimpleQualifiedIdentifier
			
		TypeDefinition	
503			type  ParameterisedTypeName  TypeInitialisation
			
		TypeInitialisation	
504			=  NullableTypeExpression
			
		PRAGMAS	
			
		Pragmas	
505			Pragma
506			Pragmas  Pragma
			
		Pragma	
507			UsePragma  Semicolonfull
508			ImportPragma  Semicolonfull
			
		UsePragma	
509			use  PragmaItems
			
		PragmaItems	
510			PragmaItem
511			PragmaItems  ,  PragmaItem
			
		PragmaItem	
512			decimal
513			namespace  SimpleQualifiedIdentifier
514			double
515			int
516			default  namespace  SimpleQualifiedIdentifier
517			Number
518			precision  NumberLiteral
519			rounding  Identifier
520			standard
521			strict
522			uint
			
		ImportPragma	
523			import  ImportName
524			import  Identifier  =  ImportName
			
		ImportName	
525			PackageName  .  *
526			PackageName  .  Identifier
			
		BLOCKS AND PROGRAMS	
			
		Blockt	
527			{  Directivest  }
			
		Program	
528			Directivesglobal
529			Packages  Directivesglobal
			
		Packages	
530			Packages
531			Package Packages
			
		Package	
532			PackageAttributes  package  PackageNameOpt  PackageBody
			
		PackageAttributes	
533			internal
534			«empty»
			
		PackageNameOpt	
535			«empty»
536			PackageName
			
		PackageName	
537			Identifier
538			PackageName  .  Identifier
			
		PackageBody	
539			Blockglobal
			
			
Change History:			
			26-Apr-2007: Add 'to' to ContextuallyReservedIdentifiers; Remove stale reference to LogicalAssignmentOperator
			10-Apr-2007: Fix several typos; Add to SimpleQualifiedIdentifier syntax for calling global intrinsic overloadable operators
			06-Apr-2007: Replace errant references to TypeIdentifier with PropertyIdentifier; Move from ReservedIdentifiers to ContextuallyReservedIdentifiers: cast const implements import interface internal intrinsic is let package private protected public to use; Remove ReservedIdentifier: as; Add missing allowIn argument to uses of FunctionBody; Remove lexical non-terminal PackageIdentifiers
			30-Mar-2007: Replace TypeIdentifier in PrimaryExpression with PrimaryIdentifier; Inline PropertyIdentifier production; Rename TypeIdentifier to PropertyIdentifier; Remove function names with embedded *;
			29-Mar-2007: Revert previous restriction that 'use default namespace' argument must be a particular reserved namespace; Add tau parameter to BlockStatement and Block to allow top-level blocks with hoisted definitions; Rename ParameterisedClassName to ParameterisedTypeName; Change Identifier in TypeDefinition to ParameterisedTypeName; Replace the lexeme PackageIdentifier with the nonterminal Path, which gets resolved to a PackageName or an object referece by the definer; Move the ListExpression form of function body into FunctionBody; Add PrimaryIdentifier production and move Path qualified references out of TypeIdentifier to PrimaryIdentifier; Change right side of PropertyOperator from QualifiedIdentifier to TypeIdentifier; Add 'has' to the ContextuallyReservedIdentifiers; Update FunctionName to include 'call' and 'has' functions; Remove 'invoke' from ContextuallyReservedIdentifiers
			13-Mar-2007: Add SuperInitialiser to as optional final constituent of ConstructorInitialiser; Erase SuperStatement; Erase ''const function'' from the class context (all methods are const); Restrict use default namespace argument to public, internal and intrinsic; Remove 'in' from ContextuallyReservedIdentifiers; Define 'function to' so that no return type is allowed; Remove 'construct' from ContextuallyReservedIdentifiers; Add 'invoke' to ContextuallyReservedIdentifiers
			02-Mar-2007: Erase gamma parameter from TypedPattern (always noExpr), Add syntax for array comprehension; Rename ElementList to Elements; Rename FieldList to Fields; Rename NonemptyFieldList to FieldList; Add ''const function'' definition syntax; Change PropertyIdentifier to * in function call definitions; Rename call to invoke in non-catchall definitions; Remove 'construct' function; Update PackageIdentifier; Remove '^^' and '^^=' punctuators; Fork FunctionSignatureType from FunctionSignature; Fix bug which allowed ''this : T ,'' in FunctionSignature; Make 'null' and 'undefined' NullableTypeExpressions; Add 'undefined' to ContextuallyReservedIdentifiers
			18-Jan-2007: Add syntactic parameter t to distinguish between contexts that allow / exclude certain kinds of definitions; Add syntax for constructor definitions, including ConstructorInitialiser; Add syntax to FunctionSignature to constrain type of 'this'; Dinstinguish between nullable/nonnullable and orther type expression; Allow any TypeExpression in TypedPattern
			08-Dec-2006: Add FieldKind to LiteralField; Change NonAttributeQualifiedIdentifier to PropertyIdentifier in FieldName; Remove [no line break] constraint from FunctionName; Add to FunctionName productions for 'construct' and for 'call' and 'to' without a name; Add 'construct' to ContextuallyReservedIdentifiers
			06-Dec-2006: Add BlockStatement non-terminal, minor refactoring of the Program productions; Rename PackageDefinition as Package; Change NonAttributeQualifiedIdentifier to FieldName in DestructuringField; Change SwitchTypeStatement to take a ListExpression and TypeExpression in its head rather than a binding form; Merge LogicalAssignmnetOperator into CompoundAssignmentOperator; Rename Inheritance to ClassInheritance; Rename ExtendsList to InterfaceInheritance; Refactor InterfaceDefinition to have a more specific syntax;
			29-Nov-2006: Update AST nodes for VariableDefinition; Update AST nodes for Pragmas; Change rhs of SimplePattern from PostfixExpression to LeftHandSideExpression; Tighten the syntax of definition attributes that are reference to namespaces; Add AST nodes for SwitchStatement and SwitchTypeStatement
			21-Nov-2006: Make the 'cast' operator a peer of the infx 'to' operator; Propagate the a parameter to FunctionExpression; Unify TypedIdentifier and TypedPattern, and lhs postfix expressions and Pattern; Remove logical xor operator; Add 'precision' to PragmaIdentifier and ContextuallyReservedIdentifier; Add AST node types for expressions; Refactor slice syntax; Remove empty bracket syntax
			14-Nov-2006: Move 'yield' from Reserved to contextually reserved; Add ReservedIdentifier after '::' in ExpressionQualifiedIdentifier; Refactor RestParameter; Remove abstract function declaration from FunctionCommon; Add accessors to ObjectLiteral; Move TypedIdentifier and TypedPattern to the Expressions section; Remove FieldName : ParenExpression; Remove ExpressionClosure; Add expression closure syntax to FunctionExpression; Propagate the b parameter down to FunctionExpression; Distinguish between RecordType and ArrayType in TypedPattern; Rename noLet and allowLet to noList and allowList, respectively; Add «empty» to DestructuringFieldList; Added links to 'triple quotes' and 'extend regexp' proposals
			26-Sep-2006: Add ReservedIdentifier after '::'; Parameterise productions to restrict the context where LetExpression and YieldExpression can be used; Change the body of LetExpression and YieldExpression from AssignmentExpression to ListExpression
			21-Sep-2006: Rename lexical non-terminals 'String' to 'StringLiteral' and 'Number' to 'NumberLiteral'; Remove infix 'cast' expressions; Remove prefix 'to' expressions; Change the rhs of 'to' to be a TypeExpression; Move 'yield' to 'AssignmentExpression' (again); Replace Arguments with ParenExpression in SuperExpression
			15-Sep-2006: Add rules for tagging an object or array literal with a structural type; Add “decimal”, “double”, “int”, “uint”, “Number”, “rounding”, “strict”, and “standard” to the list of ContextuallyReservedIdentifiers; Fix capitalisation of PackageIdentifier (409); Add definition of lexical Identifier; Remove redundant productions referring to ContextuallyReservedIdentifier; Add "Number" as a PragmaArgument; Refactor YieldExpression to be used by MultiplicativeExpression and use UnaryExpression
			30-Aug-2006: Remove 'native' from ReservedIdentifier; Add lexical non-terminals for missing literal forms and VirtualSemicolon; Replace productions for Identifier with one that uses lexical symbol ContextuallyReservedIdentifiers; Replace RestParameters with RestParameter (57); Replace Expression with ListExpression (94,99,101,106); Replace NonAssignmentExpression with LogicalOrExpression (219); Remove unused production for DestructuringAssignmentExpression (250); Remove Statement production for SwitchTypeStatement (291); Sort Statement productions; Remove unused productions for Substatements and SubstatementsPrefix; Replace use of VariableInitialiser with AssignmetExpression (441); Replace uses of TypeName with TypeIdentifier (462,463); Rename TypeNameList as TypeIdentifierList
			15-Jun-2006: Add 'yield' expression without subexpression; Remove Semicolon after PragmaItems in UsePragma; Remove parens around PragmaARgument in PragmaItem; Change SimpleQualifiedIdentifier to SimpleTypeIdentifier in PragmaArgument; Add SimpleTypeIdentifier to NamespaceInitialisation
			07-Jun-2006: Remove AttributeCombination from Attributes; Remove true and false from Attributes (they are a carryover from the NS proposal and have never been proposed here); Added comment on the creation of a lexical PackageIdentifier from a syntactic PackageName; Allow 'let' on VariableDefinition and FunctionDefinition; Merge SwitchType into SwitchStatement; Add 'call' to context keywords and syntactic identifier; Replace ListExpression in Arguments with ArgumentList; Reuse VariableBinding for LetBinding; Add ParameterAttributes to Pattern in Parameter; Add TypedParameter to RestParameter; Change Identifier to TypedIdentifier in RestParameter; Add TypedPattern to TypeCaseElement; Rename 'private' to 'internal' in PackageAttributes
			01-Jun-2006: Add '!' to ClassName; Remove 'as'; Replace TypeExpression on the rhs of 'is' and 'to' with ShiftExpression; Rename AttributeQualifiedIdentifier to AttributeIdentifier; Add 'type' operator to UnaryExpression; Change yield construct from YieldStatement to YieldExpression; Add 'yield' to the list of reserved identifiers; Add TypedPattern everywhere that TypedIdentifier is used to defined a variable, except in switch-type; Define the meaning of the lexical symbol PackageIdentifier; Add primary expression for "to" and binary expression for "cast"
			23-May-2006: Add 'super' to reserved words; Refactor TypeIdentifier; Use simpler E3 syntax for PostfixExpression; Rename LPattern and children to Pattern etc.; Move DestructuringAssignmentExpression out of AssignmentExpresion; Move LetExpression to AssignmentExpression; Remove attribute blocks; Remove variable initialiser with multiple attributes on the rhs; Add parens around pragma arguments; Add prama identifiers 'default namespace' and 'default package'; Add PackageAttribute to PackageDefinition; Sort rules for readability
			16-May-2006: Added '.' before '<…>' in type definitions; removed ReservedNamespace from PrimaryExpression since it is already include via QualifiedIdentifier; simplified PostfixExpression; changed qualifier on ExpressionQualifiedIdentifier from ParenExpression to ParentListExpression; Refactored TypeIdentifier; replaced QualifiedIdentifier with TypeIdentifier and added AttributeQualifiedIdentifier in PrimaryExpression; made .< a token rather than two; Redefined TypeParameters to include the .< and > delimiters
			15-May-2006: Moved 'PackageIdentifier . Identifier' from PrimaryExpression to QualifiedIdenfier; Added dot to left angle brace for parameterized type expressions in TypeExpression
			12-May-2006: Initial draft. First attempt to capture the whole grammar of ES4. Current with the latest proposals