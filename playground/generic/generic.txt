= Generic functions for ECMAScript 4 =

2007-07-27 / lhansen@adobe.com / rev 2


== Motivation ==

Our current operator overloading proposal is very weak.  We ought to
have something with proper type dispatch.  Instead of putting
something ad-hoc into classes we should just provide for generic
functions (multimethods).


== Overview ==

Generic functions are function objects each with a set of attached
methods.  A call to a generic function matches the number and types of
the actual arguments to the signatures of the attached methods and
dispatches to the most appropriate method following deterministic
rules.

Generic functions can be defined whereever other functions can be
defined: at the top level of programs, packages, and functions, and as
static and instance methods in classes.

Methods can be attached to top-level generic functions at any time.

Methods can be attached to instance and static generic functions on
classes only inside the class definition containing the generic
function definition.

At the time a generic function is called, applicable methods
(determined by the manifest types of the actual arguments) are
selected and ordered by specificity.  Methods that cannot be ordered
cannot be invoked, and if the set of ordered methods is empty the
function cannot be invoked at all and an error is signalled.  The most
specific member of the set of ordered methods is invoked; the method
can ask that control be passed to the next most specific method, and
so on.


== Proposal ==

=== Defining functions ===

A generic function is defined by a body-less function definition using
the contextual keyword pair "generic function":

  generic function f(x, y);

The arguments in generic function definitions can be annotated with
types, and the functions can be annotated with return types; these act
as constraints on any methods defined on the function later:

  generic function <=(a: Real, b: Real): Real;

Types default to ''*''.

Optional arguments are not allowed in generic function definitions,
but may be present in method definitions.

Rest arguments may be present in generic function definitions.

  generic function g(a, b, ...xs);

The //shape// of a generic function is taken to be the list of
parameters and return type.

A generic function can have multiple shapes.  New shapes are
introduced to a generic function by adding a generic function
definition with the same name but a different shape:

  generic function f(x, y);
  generic function f(x);

Now f accepts one or two arguments.

The //arity// of a generic function is the highest number of non-rest
arguments in any signature defined for the function.

The //restness// of a generic function says whether the argument takes
a rest argument or not.  (Awful term, I know.)

A new shape must be different from an existing shape in arity or
restness, not in any of the type constraints.

It's legal to add a shape to a generic function with the same number
of arguments provided the shape matches exactly the already existing
shape.  This has no effect and aids separate development.

A shape with rest arguments can coexist with shapes without only if
the shape with rest arguments has arity at least as large as any other
shape in the generic function.


=== Defining methods ===

A //method// is defined on an already defined generic function by
matching one of the function's shapes exactly and providing (a) types
for some or all of the arguments and (b) optionally for the return
type and (c) a method body.

  generic function f(x:int, y:boolean): string {
      if (y)
          return string(x);
      else
          return "37";
  }

  generic function f(x:int): string {
      return "42";
  }

If there are type constraints on the generic function then the method
must have argument types that are subtypes of the parameter type
constraints and a supertype of the return type constraint, or an error
is signalled.

The types in the signature must all be either nominal types (class or
interface types) or union types of nominal types, plus ''null'',
''undefined'', and ''*''.

A method discriminating on a union type can be seen as defining a set
of methods simultaneously, one method per type in the union.  This is
actually somewhat important; a generic method

  generic function +(x:Numeric,y:Numeric) { ... }

actually prevents later addition of this method:

  generic function +(x:int, y:int) { ... }

because Numeric is a union containing ''int''

A method discriminating on ''*'' can be seen as less specific than any
other method.

The method can supply default values for its trailing fixed
parameters.


=== Generic functions in classes ===

Generic functions can be defined inside classes ("generic instance
functions", "generic static functions").  All generic methods defined
in the same class body as the generic function are attached to that
function.  Methods outside the class body cannot extend generic class
functions.

Generic functions in classes can be static.  The methods must be
declared static as well:

  generic static function fn(x);

  generic static function fn(x:int) x+5;

Generic instance functions can override methods in the superclass,
provided the generic function supplies at least one shape that is
equal to the signature of the overridden method (in the normal sense
for overriding).

Generic instance functions can be overridden by methods in a subclass,
provided the generic function has only one shape and that the shape of
the overriding function matches the shape of the overridden function
precisely.


=== Invocation ===

Generic functions are invoked using the normal function invocation
syntax.

When the function is invoked, the manifest number and of types of its
arguments are compared to the shapes of the methods, and a set of
applicable methods is computed (see below).

The applicable methods are then ordered as described below, this
yields a set of totally ordered methods and a set of unordered
methods.

If the set of totally ordered methods is empty, an error is thrown.
Otherwise, the first such method is invoked on the arguments.  If the
method returns normally or throws an exception then the generic
function terminates in the same way.  If the method invokes its "next
method", then the next method in the ordered set is invoked.  If there
is no next method, an error is thrown.


==== Computing the applicable methods ====

The set of applicable methods is determined from the number of actual
arguments to the generic function.  A method is applicable if it is
defined on a shape that has the same length as the number of
arguments, or if it is defined on a shape with more fixed arguments
but where there are methods with optional arguments s.t. there is a
method taking the number of arguments passed in the current call, or
if it is defined on a shape with fewer arguments but with a provision
for a rest argument.

For any of these, if a method parameter is constrained by a type then
the method is only applicable if the acutal arguments' manifest types
are all subtypes of the type constraints.


==== Sorting the applicable methods ====

Observe that since structural types are not allowed, rest arguments
are always untyped.  We will ignore optional arguments that are given
default values when actual arguments are not supplied.  This leaves us
with a set of method signatures all of the same length.

At this point, we use Dylan's algorithm for Method Specificity
computation (DRM pp 96-98).

For this we need to construct the class precedence list for classes
and interfaces.  We take the local precedence order of a class to be
the base class followed by the list of implemented interfaces in the
order they are present in the class definition, and the local
precedence order of an interface to be the list of base interfaces in
the order they are present in the interface definition.  We then use
Dylan's algorithm for computing the class precedence list (DRM pp
54-56).

This yields a set of totally ordered methods and a set of unordered
methods as desired.

(Details are needed here, obviously, and a proof that the precedence
list computation has properties like monotonicity even in ES4 would be
good.)


==== nextMethod ====

Inside the method body the function ''nextMethod'' is defined (it is
passed as an additional argument to the method); it can be called
without arguments to invoke the next method in the list of unambiguous
applicable methods on the argument values on which the present method
was invoked.  (Stating the obvious: a function is invoked on a set of
values v1, ..., vn, which are assigned to formal parameters inside the
function.  Assignments to these formal parameters by the functions do
not affect the values v1, ..., vn obviously; those same values are
passed to ''nextMethod''.)

''nextMethod'' can also be invoked on a list of arguments, these
arguments will be passed to the next method.  Normal type checking
applies on entry to the next method in this case.

The invocation of ''nextMethod'' causes control to exit from the
current method, so any finally handlers wrapping the call to
''nextMethod'' will be executed, and no exception handlers wrapping
the call to ''nextMethod'' will handle an exception thrown by any
subsequent method.

In fact, it may be better to think of (or even specify) ''nextMethod''
as syntax: ''throw nextMethod'' is not obviously worse, since it
clearly shows what's going on.  But it may leave a good implementation
less room to play in.


=== Types ===

Generic functions respond to "typeof" with "function"; if f is a
generic function then "f is Function" is true, as is "f instanceof
Function".

I don't yet know if there needs to be a new visible class
"GenericFunction".

Seen as a typed entity, a generic function could be said to have a
structual type that is is the union of its method types:

  (function (int, *): int, function (string, MyClass): [double])

Thus it should be possible for the generic function to be used in
contexts that require the signature of a particular method of the
function.

Currently we have no objects whose manifest type is a union type, so
there will need to be some slight hackery in the type system.  I don't
think this should be too bad.  In the mean time, we can just assume
the function to have type (function (...*):*).

The meta-object proposal will need to be extended to accomodate
generic functions.


=== Error reporting ===

Violations of constraints in the definition of generic functions and
methods shall be reported at compile time as a SyntaxError for generic
functions defined inside classes.

Ditto violations shall be reported at run-time as a TypeError at the
time when a violating shape or method is added to the generic
function.  The function shall be left in a state as if the violating
operation was never started.


=== Meta-object protocols ===

One of the strengths of generic functions is their ability to extend
built-in facilities in a seamless way by means of adding methods to
predefined protocols.

For example, in ECMAScript one might think of each of the built-in
functions (eg Number) as a generic function because these functions
perform conversion based on the input type; it might be useful for
user code to extend the meaning of each such conversion by adding
methods to the converter functions.

The definition of a coherent and useful MOP for ECMAScript does not
fit into the ES4 timeframe, unfortunately, though I would like not to
take the language in a direction that prevents us from adding a MOP in
the future.

However, the following global generic functions are predefined with
the listed methods; they can be extended by user code:

  generic function +(a);
  generic function +(a:Numeric):Numeric { ... }

  generic function +(a,b);
  generic function +(a:*,b:*):Numeric { ... }
  generic function +(a:Numeric,b:Numeric):Numeric { ... }
  generic function +(a:String,b:*):String { ... }
  generic function +(a:*,b:String):String { ... }

  generic function -(a);
  generic function -(a:Numeric):Numeric { ... }

... and ditto for all of the operator names defined in the operator
overloading proposal, with methods for signatures defined by E262-3
and the proposals and probably some additional performance
considerations.

FIXME: elaborate this fully.

In practice, the signatures are defined so that eg for ''+'', the
system can take a fast path if it sees a built-in number type.


== Open issues ==

How do we do Function.toString() on these things?


== Non-features ==

Generic functions are not implicitly defined when a method is defined
on a non-existing function.  I suspect they probably ought to be, but
I'm not sure how crucial this is in practice.

There are no generic function expressions.

The Function constructor can't be used to create generic functions.

There is no way to seal global generic functions.  This may however be
worked around by scoping generic functions inside local packages or
other functions, and then exporting those functions.

There is no way to add methods at run-time, in particular, "eval"
can't do it.

The current proposal does not allow for removing methods or redefining
them; but the intent is that it does not preclude these operations
being added in the future.  eg, non-removable methods on top-level
generic functions could be designated "final", every other method
could be removable.

Structural types do not participate in dispatch, and we don't want
methods to be annotated with structural types that are treated as
''*'' even if that were convenient, since we may want structural types
to participate in dispatch in the future.


== Background material ==

* Andrew Shalit, "The Dylan Reference Manual", Addison Wesley 1996


