<html>
<head>
<title>Proposed ECMAScript 4th Edition -- Predefined ECMAScript Objects </title>
<style>
/* -*- indent-tabs-mode: nil -*- */
.fixme { font-size: smaller; padding-left: 1em; color: red }
.note { font-size: smaller; padding-left: 1em }
.part { font-size: 24pt }
.grammar { font-style: italic }
.indented { padding-left: 3em }
.nonterm { padding-top: 1em }
.xref { border: thin solid red; }
.section { margin-bottom: -1em; font-family: sans-serif; font-size: smaller }
.implsection { margin-bottom: -1em; padding-bottom: 0.3em; font-family: sans-serif; font-size: smaller }
.literal { font-style: normal; font-weight: bold }
H1,H2,H3,H4,H5,H6 { font-family: sans-serif }
H1 { font-size: 14pt }
H2 { font-size: 12pt }
H3 { font-size: 11pt }
H4 { font-size: 10pt }

P code { font-size: 10pt }
code { font-style: normal; font-weight: normal }

pre { font-size: 8pt }

body { counter-reset: chapter section subsection subsubsection;
       font-size: 11pt; 
       margin: 0.75in }

table { font-size: inherit }

.pcounter:before {
    content: counter(para); 
}

.pcounter {
    position: absolute; left: 0.5in;
    counter-increment: para
}

H1:before {
    padding-right: 1em;
    content: counter(chapter) "  ";
    counter-increment: chapter }

H1 {
    counter-reset: section para;
}

H2:before {
    padding-right: 1em;
    content: counter(chapter) "." counter(section) "  ";
    counter-increment: section }

H2 {
    counter-reset: subsection para;
}

H3:before {
    padding-right: 1em;
    content: counter(chapter) "." counter(section) "." counter(subsection) "  ";
    counter-increment: subsection }

H3 {
    counter-reset: subsubsection para;
}

H4:before {
    padding-right: 1em;
    content: counter(chapter) "." counter(section) "." counter(subsection) "." counter(subsubsection) "  ";
    counter-increment: subsubsection }

H4 {
    counter-reset: para;
}

@media print {
    H1 { page-break-before: always }
    .copyright { page-break-before: always }
}

</style>
</head>

<body>
<center class="part">
Proposed ECMAScript 4th Edition<br>
<br>
Part III: Predefined ECMAScript Objects
<br>
<b>ROUGH INCOMPLETE DRAFT</b><br>
<br>
<br>
<br>
</center>
<div class="copyright">

<P class="none">The following licensing terms and conditions apply and must be
accepted in order to use this Document:

<OL>
<LI> This Document is made available to all
interested persons on the same terms as Ecma makes available its
standards and technical reports, as set forth at
http://www.ecma-international.org/publications/.

<LI> All liability and responsibility for any use of this Document
rests with the user, and not with any of the parties
who contribute to, or who own or hold any copyright in, this Reference
Implementation.

<LI> THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT
HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</OL>

<P class="none">End of Terms and Conditions

<P class="none"> Copyright (c) 2007 Adobe Systems Inc., The Mozilla Foundation, Opera
Software ASA, and others.

</div>


<h1>Introduction</h1>

<pre>
FILE:                       spec/library/intro.html
DRAFT STATUS:               DRAFT 1 - ROUGH - 2007-09-19
REVIEWED AGAINST ES3:       NO
REVIEWED AGAINST ERRATA:    NO
REVIEWED AGAINST BASE DOC:  NO
REVIEWED AGAINST PROPOSALS: NO
REVIEWED AGAINST CODE:      NO
</pre>

<P><span class="pcounter"></span> There are certain built-in objects available whenever an
ECMAScript program begins execution.  One, the global object, is in
the scope chain of the executing program.  Others are accessible as
initial properties of the global object.

<P><span class="pcounter"></span> ECMAScript execution environments may provide multiple global
objects, each of which may be accessible from the others.  Whether
each of these global objects has separate intial values for the
initial properties described in this section, or whether the values
are shared, is implementation-defined.

<P><span class="pcounter"></span>Many built-in objects behave like functions: they can be invoked
with arguments.  Some of them furthermore are constructors: they are
classes intended for use with the <code>new</code> operator. For each built-in
class, this specification describes the arguments required by that
class's constructor and properties of the Class object. For each
built-in class, this specification furthermore describes properties of
the prototype object of that class and properties of specific object
instances returned by a <code>new</code> expression that constucts instances of
that class.

<p class="note"><b>COMPATIBILITY NOTE</b>&nbsp;&nbsp; The 3rd Edition of this Standard did not provide classes, and
all built-in objects provided as classes in 4th Edition were
previously provided as functions.  The change from functions to
classes is observable to programs that convert the built-in class
objects to strings.

<P><span class="pcounter"></span>Built-in classes have four kinds of functions, collectively called
methods: constructors, static methods, prototype methods, and
intrinsic instance methods.  Non-class built-in objects may
additionally hold non-method functions.

<p class="note"><b>COMPATIBILITY NOTE</b>&nbsp;&nbsp; The 3rd Edition of this standard provided only
constructors and prototype methods.  The new methods are not visible
to 3rd Edition code being executed by a 4th Edition implementation.

<P><span class="pcounter"></span>Unless otherwise specified in the description of a particular
class, if a constructor, prototype method, or ordinary function described
in this section is given fewer arguments than the function is
specified to require, the function shall behave exactly as if it had
been given sufficient additional arguments, each such argument being
the <code>undefined</code> value.

<P><span class="pcounter"></span>Unless otherwise specified in the description of a particular
class, if a constructor, prototype method, or ordinary function described
in this section is given more arguments than the function is specified
to allow, the behaviour of the function is undefined. In particular,
an implementation is permitted (but not required) to throw a
<code>TypeError</code> exception in this case.

<p class="note"><b>NOTE</b>&nbsp;&nbsp; Implementations that add additional capabilities to the set of
built-in classes are encouraged to do so by adding new functions and
methods rather than adding new parameters to existing functions and
methods.

<P><span class="pcounter"></span>Every built-in function has the Function prototype object, which is
the initial value of the expression <code>Function.prototype</code> (<span class="xref">Function.prototype</span>), as the value of its internal
<code>[[Prototype]]</code> property.

<P><span class="pcounter"></span>Every built-in class has the Object prototype object, which is the initial
value of the expression <code>Object.prototype</code> (<span class="xref">Object.prototype</span>),
as the value of its internal <code>[[Prototype]]</code> property.

<p class="note"><b>COMPATIBILITY NOTE</b>&nbsp;&nbsp; In the 3rd Edition of this Standard every constructor
function that is represented as a class in 4th Edition also had the
Function prototype object as the value of its internal <code>[[Prototype]]</code>
property.  This change is observable to programs that attempt to call
methods defined on the Function prototype object through a class
object.

<P><span class="pcounter"></span>Every built-in prototype object has the Object prototype object,
which is the initial value of the expression <code>Object.prototype</code>
(<span class="xref">Object.prototype</span>), as the value of its internal
<code>[[Prototype]]</code> property, except the Object prototype object itself.

<P><span class="pcounter"></span>None of the built-in functions described in this section shall
implement the internal <code>[[Construct]]</code> method unless otherwise specified
in the description of a particular function. None of the built-in
functions described in this section shall initially have a
<code>prototype</code> property unless otherwise specified in the description
of a particular function. Every built-in Function object described in
this section--whether as a constructor, an ordinary function, or a
method--has a <code>length</code> property whose value is an integer. Unless
otherwise specified, this value is equal to the largest number of
named arguments shown in the section headings for the function
description, including optional parameters.

<p class="note"><b>NOTE</b>&nbsp;&nbsp; For example, the Function object that is the initial
value of the <code>slice</code> property of the String prototype object is
described under the section heading <code>String.prototype.slice (start ,
end)</code> which shows the two named arguments start and end; therefore
the value of the length property of that Function object is 2.



<P><span class="pcounter"></span>The built-in objects and functions are defined in terms of
ECMAScript packages, namespaces, classes, types, methods, properties,
and functions, with the help from a small number of implementation
hooks.

<p class="note"><b>NOTE</b>&nbsp;&nbsp; Though the behavior and structure of built-in objects and
functions is expressed in ECMAScript terms, implementations are not
required to implement them in ECMAScript, only to preserve the
behavior as it is defined in this Standard.

<P><span class="pcounter"></span>Implementation hooks manifest themselves as functions in the
<code>magic</code> namespace, as in the definition of the intrinsic
<code>toString</code> method on <code>Object</code> objects:

<PRE>
intrinsic function toString() : string
    "[object " + magic::getClassName(this) + "]";
</PRE>

<P><span class="pcounter"></span>All magic function definitions are collected in section <span class="xref">library-magic</span>.

<P><span class="pcounter"></span>The definitions of the built-in objects and functions also leave
some room for the implementation to choose strategies for certain
auxiliary and primitive operations.  These variation points manifest
themselves as functions in the <code>informative</code> namespace, as in the
definition of the intrinsic global function <code>hashcode</code>:

<PRE>
intrinsic const function hashcode(o): uint {
    switch type (o) {
    &#x0085;
    case (x: String)    { return informative::stringHash(string(x)) }
    case (x: *)         { return informative::objectHash(x) }
    }
}
</PRE>

<P><span class="pcounter"></span>Informative methods and functions are defined non-operationally in
the sections that make use of them.

<P><span class="pcounter"></span>The definitions of the built-in objects and functions also make use
of internal helper functions and properties, written in ECMAScript.
These helper functions and properties are not available to user
programs and are included in this Standard for expository purposes, as
they help to define the semantics of the functions that make use of
them.  Helper functions and properties manifest themselves as
definitions in the <code>helper</code> namespace, as in the definition of the
global <code>encodeURI</code> function:

<PRE>
intrinsic const function encodeURI(uri: string): string
    helper::encode(uri, helper::uriReserved + helper::uriUnescaped + "#")
</PRE>

<P><span class="pcounter"></span>Helper functions and properties are defined where they are first
used, but are sometimes referenced from multiple sections in this
Standard.

<P><span class="pcounter"></span>Unless noted otherwise in the description of a particular class or
function, the behavior of built-in objects is unaffected by
definitions or assignments performed by the user program.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  This can be accomplished first by defining all built-in
objects, classes, functions, and properties inside a package whose
name is private to the implementation, second by the built-in methods
always preferring intrinsic methods and functions to prototype methods
and unqualified functions, and finally by importing the public names
of the package containing the built-ins into the global environment of
the user program.

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #169). Does the above provide us with the correct
semantics?  If we do it as described, a user program can create a new
binding for "Object" that shadows our "Object".  This is not a problem
for the builtins; it may or may not be a benefit to the user program.
It may or may not be backwards compatible (what happens if the user
program contains <code>var isNaN</code> -- does this redundantly state that
there is a binding for <code>isNaN</code> or does it create a new binding?)

<PRE>
package ...
{
    use default namespace public;
    use namespace intrinsic;

    // All global definitions, see section &#60;XREF target="global-object">
}
</PRE>

<P><span class="pcounter"></span> In some cases the built-in functions construct new error objects
that are then thrown as exceptions.  For purposes of documentation an
informative string is passed to the constructors of the error objects.
These strings are never to be considered normative.


<h1>Assumptions and notational conveniences</h1>

<P><span class="pcounter"></span> (This section will be removed eventually.)

<P><span class="pcounter"></span> The following assumptions are made throughout the description of
the builtins.  I believe they are correct for the language, but they
need to be specified / cleaned up elsewhere; some of the descriptions
here need to be merged into the foregoing sections.


<h2>Classes</h2>

<P><span class="pcounter"></span> Classes are reified as singleton class objects <code>C</code> which behave
like ECMAScript objects in all respects.  We do <i>not</i> assume here
that these class objects are instances of yet other classes; they can
be assumed just to exist.  Class objects have some set of fixtures
(always including the <code>prototype</code> property) and a <code>[[Prototype]]</code>
chain, at a minimum.

<P><span class="pcounter"></span> The <code>Function</code> prototype object is on the <code>[[Prototype]]</code> chain of
every class object, whether native or user defined.  This was true for
all constuctor functions in ES3; it does not seem reasonable to be
incompatible for native objects in ES4, and it does not seem
reasonable to have a special case for native objects in ES4 (though that
would be possible).

<P><span class="pcounter"></span> <i>Consequence:</i> It will be assumed that the <code>Function</code> prototype
object is on the prototype chain of every class object, and this will not
be described explicitly for each object, unlike 3rd Edition.


<h2>Prototype chains</h2>

<P><span class="pcounter"></span> Every class object <code>C</code> has a constant <code>C.prototype</code> fixture
property, with fixed type <code>Object</code>.  Unless specified otherwise,
<code>C.prototype</code> references an object <code>PC</code> that appears to be an
instance of <code>C</code> except for the value of <code>PC.<code>[[Prototype]]</code></code>, which
is normally a reference to <code>B.prototype</code> where <code>B</code> is the base
class of <code>C</code>.  (Thus the prototype hierarchy mirrors the class
hierarchy, and inheritance of prototype properties mirrors the
inheritance of class properties.)

<P><span class="pcounter"></span> <i>Consequence:</i> It will be assumed that every class object has a
<code>prototype</code> property and that that property will reference the
prototype object for that class, which is always described separately.
The fact that there is a <code>prototype</code> property will not be described
explicitly for each object, unlike 3rd Edition.

<P><span class="pcounter"></span> Every <code>[[Prototype]]</code> property of an object <code>O</code> of class described
by class object <code>C</code>, unless specified otherwise, is initialized from
the value of <code>C.prototype</code>. 

<P><span class="pcounter"></span> <i>Consequence:</i> The structure of the prototype chain is elided
from the description of the native classes except where it diverges
from the standard behavior.


<h2>Constant-initialized properties</h2>

<P><span class="pcounter"></span> Several properties on both class objects and prototype objects are
initialized by references to constants, for example <code>length</code>
properties on class objects and <code>constructor</code> properties on
prototype objects.  These properties are trivially described in the
synopsis and normally do not get a separate section in the body of the
class description.

<P><span class="pcounter"></span> As far as <code>constructor</code> is concerned, it is a standard feature of
the prototype object and its initial value is always the class object,
so it does not have to be described either.  So it isn't.

<h2>Special cases</h2>

<P><span class="pcounter"></span> This is a list of all the special cases I'm aware of in the sections
following.

<UL>
  <LI> Object.prototype.<code>[[Prototype]]</code> is null
  <LI> Math.<code>[[Prototype]]</code> does not have a constructor
  <LI> Math is an instance of a class that is not constructable through the meta-objects system
  <LI> int.prototype === Number.prototype and int.<code>[[Prototype]]</code> === Number.<code>[[Prototype]]</code>
  <LI> uint.prototype === Number.prototype and uint.<code>[[Prototype]]</code> === Number.<code>[[Prototype]]</code>
  <LI> double.prototype === Number.prototype and double.<code>[[Prototype]]</code> === Number.<code>[[Prototype]]</code>
  <LI> decimal.prototype === Number.prototype and decimal.<code>[[Prototype]]</code> === Number.<code>[[Prototype]]</code>
  <LI> string.prototype === String.prototype and string.<code>[[Prototype]]</code> === String.<code>[[Prototype]]</code>
  <LI> boolean.prototype === Boolean.prototype and boolean.<code>[[Prototype]]</code> === Boolean.<code>[[Prototype]]</code>
</UL>

<h1>The Global Object</h1>

<pre>
FILE:                       spec/library/global.html
DRAFT STATUS:               DRAFT 1 - ROUGH - 2007-09-20
REVIEWED AGAINST ES3:       NO
REVIEWED AGAINST ERRATA:    NO
REVIEWED AGAINST BASE DOC:  NO
REVIEWED AGAINST PROPOSALS: NO
REVIEWED AGAINST CODE:      NO
</pre>

<P><span class="pcounter"></span> The global object is an instance of an implementation-dependent
class.  In particular, its the name of this class and the contents of
the class's prototype object are implementation-dependent.

<P><span class="pcounter"></span> The class describing the global object does not have an accessible
constructor function; it is not possible to use the global object as a
constructor with the <code>new</code> operator.

<P><span class="pcounter"></span> The class describing the global object does not have a
<code>meta::invoke</code> method; it is not possible to call the global object
as a function.

<h2>Synopsis</h2>

<P><span class="pcounter"></span>The global object contains the following properties, functions,
types, and class definitions.

<PRE>
namespace __ES4__

class Object &#x0085;
class Function &#x0085;
class Array &#x0085;
class String &#x0085;
class Boolean &#x0085;
class Number &#x0085;
class Date &#x0085;
class RegExp &#x0085;
class Error &#x0085;
class EvalError &#x0085;
class RangeError &#x0085;
class ReferenceError &#x0085;
class SyntaxError &#x0085;
class TypeError &#x0085;
class URIError &#x0085;

__ES4__ class string &#x0085;
__ES4__ class boolean
__ES4__ class int &#x0085;
__ES4__ class uint &#x0085;
__ES4__ class double &#x0085;
__ES4__ class decimal &#x0085;
__ES4__ class Name &#x0085;
__ES4__ class Namespace &#x0085;
__ES4__ class ByteArray &#x0085;
__ES4__ class Map.&#60;K,V> &#x0085;
__ES4__ class Vector.&#60;T> &#x0085;
__ES4__ class EncodingError &#x0085;

__ES4__ type EnumerableId = &#x0085;
__ES4__ type Numeric = &#x0085;
__ES4__ type Strings = &#x0085;
__ES4__ type Booleans = &#x0085;

__ES4__ namespace intrinsic = &#x0085;

intrinsic interface Field &#x0085;
intrinsic interface FieldValue &#x0085;
intrinsic interface Type &#x0085;
intrinsic interface NominalType &#x0085;
intrinsic interface InterfaceType &#x0085;
intrinsic interface ClassType &#x0085;
intrinsic interface AnyType &#x0085;
intrinsic interface NullType &#x0085;
intrinsic interface UndefinedType &#x0085;
intrinsic interface UnionType &#x0085;
intrinsic interface RecordType &#x0085;
intrinsic interface FunctionType &#x0085;
intrinsic interface ArrayType &#x0085;

intrinsic type FieldIterator = &#x0085;
intrinsic type FieldValueIterator = &#x0085;
intrinsic type TypeIterator = &#x0085;
intrinsic type InterfaceIterator = &#x0085;

intrinsic class ControlInspector.&#60;T> &#x0085;

const NaN: double = &#x0085;
const Infinity: double = &#x0085;
const undefined: undefined = &#x0085;
const __ECMASCRIPT_VERSION__ = &#x0085;
const Math: Object = &#x0085;

__ES4__ const global: Object = &#x0085;

intrinsic const function eval(s: string) &#x0085;
intrinsic const function parseInt(s: string, r: (int,undefined)=undefined): Numeric &#x0085;
intrinsic const function parseFloat(s: string): Numeric &#x0085;
intrinsic const function isNaN(n: Numeric): boolean &#x0085;
intrinsic const function isFinite(n: Numeric): boolean &#x0085;
intrinsic const function decodeURI(s: string): string &#x0085;
intrinsic const function decodeURIComponent(s: string): string &#x0085;
intrinsic const function encodeURI(s: string): string &#x0085;
intrinsic const function encodeURIComponent(s: string): string &#x0085;
intrinsic const function hashcode(x): uint &#x0085;

function eval(x) &#x0085;
function parseInt(s, r=undefined) &#x0085;
function parseFloat(s) &#x0085;
function isNaN(x) &#x0085;
function isFinite(x) &#x0085;
function decodeURI(x) &#x0085;
function decodeURIComponent(x) &#x0085;
function encodeURI(x) &#x0085;
function encodeURIComponent(x) &#x0085;

__ES4__ function hashcode(x) &#x0085;
</PRE>

<h2>Namespace for types</h2>

<P><span class="pcounter"></span> All new classes and type definitions in the global object are
defined in the namespace <code>__ES4__</code>.  This namespace is automatically
opened by the implementation for code that is to be treated as 4th
Edition code, but not for code that is to be treated as 3rd Edition
code.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The risk of polluting the name space for 3rd Edition code with
new names is deemed too great to always open the <code>__ES4__</code> name
space.

<P><span class="pcounter"></span> The means by which an implementation determines whether to treat
code according to 3rd Edition or 4th Edition is outside the scope of
this Standard.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  This standard makes recommendations for how mime types should
be used to tag script content in a web browser.  See <span class="xref">appendix-mime-types</span>.


<h2>Value Properties of the Global Object</h2>

<h3>NaN</h3>

<P><span class="pcounter"></span>The value of <code>NaN</code> is <b>NaN</b> (section 8.5).

<p class="note"><b>COMPATIBILITY NOTE</b>&nbsp;&nbsp; This property was not marked ReadOnly in 3rd Edition.

<h3>Infinity</h3>

<P><span class="pcounter"></span>The value of <code>Infinity</code> is +&#x221E; (section 8.5).

<p class="note"><b>COMPATIBILITY NOTE</b>&nbsp;&nbsp; This property was not marked ReadOnly in 3rd Edition.

<h3>undefined</h3>

<P><span class="pcounter"></span>The value of undefined is <b>undefined</b> (section 8.1).

<p class="note"><b>COMPATIBILITY NOTE</b>&nbsp;&nbsp; This property was not marked ReadOnly in 3rd Edition.

<h3>__ECMASCRIPT_VERSION__</h3>

<P><span class="pcounter"></span>The value of <code>__ECMASCRIPT_VERSION__</code> is the version of this
Standard to which the implementation conforms.  For this 4th Edition
of the Standard, the value of <code>__ECMASCRIPT_VERSION__</code> is 4.

<p class="note"><b>NOTE</b>&nbsp;&nbsp; This property is new in 4th Edition.


<h2>Function Properties of the Global Object</h2>

<h3>eval</h3>

<h4>The <code>eval</code> operator</h4>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> When the intrinsic and non-intrinsic <code>eval</code> functions are called
directly by name (that is, by the explicit use of the name <code>eval</code> as
an unqualified Identifier which is the MemberExpression in a
CallExpression) they are treated like operators in the language.  See
<span class="xref">eval-operator</span>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>eval</code> operator returns an ECMAScript value.

<h4>intrinsic::eval&nbsp;(s)</h4>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> When the intrinsic <code>eval</code> function is called as a method on
the global objects in whose scope it is closed then it evaluates its
argument as a program in the global scope that is the receiver object
in the call.

<P><span class="pcounter"></span> When the intrinsic <code>eval</code> function is called as an ordinary
function under other names than <code>eval</code> then it evaluates its
argument as a program in a global scope that is the scope in which the
<code>eval</code> function was closed.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>eval</code> function returns the value computed by
the program that's evaluated.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span> The <code>eval</code> method is implementation-dependent.

<h4>eval&nbsp;(s)</h4>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The non-intrinsic <code>eval</code> function can be called as a method
on the global object in whose scope it is closed, or it can be called
as an ordinary function under another name, just like the intrinsic
<code>eval</code> function.

<P><span class="pcounter"></span> If the argument to <code>eval</code> is a string, then the program
represented by that string is evaluated.  Otherwise the argument is
returned unchanged.

<PRE>
function eval(x) {
    if (!(x is AnyString))
        return x;
    return intrinsic::eval(string(x));
}
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The behavior of this function depends on the fact that the
non-intrinsic <code>eval</code> function is closed in the same global object as
the intrinsic <code>eval</code> function.  Thus there's no need to capture and
pass the <code>this</code> parameter.

<h4>Restrictions on the use of the <code>eval</code> property</h4>

<P><span class="pcounter"></span> If the value of the <code>eval</code> property is used in any way other
than than the three listed previously, or if the <code>eval</code> property is
assigned to, an <code>EvalError</code> exception may be thrown.

<p class="note"><b>COMPATIBILITY NOTE</b>&nbsp;&nbsp;  The 3rd Edition of this Standard restricted the use of <code>eval</code>
to the first case listed previously.


<h3>intrinsic::parseInt&nbsp;(s,&nbsp;r=&#x0085;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>parseInt</code> function computes an integer value
dictated by interpretation of the contents of the string argument
<i>s</i> according to the specified radix <i>r</i> (which defaults to zero).  Leading whitespace in
<i>s</i> is ignored.  If <i>r</i> is zero, it is assumed to be 10 except when
the number begins with the character pairs 0x or 0X, in which case a
radix of 16 is assumed.  Any radix-16 number may also optionally begin
with the character pairs 0x or 0X.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>parseInt</code> function returns a number.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic const function parseInt(s: string, r: int=0): AnyNumber {
    let i;

    for ( i=0 ; i &#60; s.length && Unicode.isTrimmableSpace(s[i]) ; i++ )
        ;
    s = s.substring(i);

    let sign = 1;
    if (s.length >= 1 && s[0] == '-')
        sign = -1;
    if (s.length >= 1 && (s[0] == '-' || s[0] == '+'))
        s = s.substring(1);

    let maybe_hexadecimal = false;
    if (r == 0) {
        r = 10;
        maybe_hexadecimal = true;
    }
    else if (r == 16)
        maybe_hexadecimal = true;
    else if (r &#60; 2 || r > 36)
        return NaN;

    if (maybe_hexadecimal && s.length >= 2 && s[0] == '0' && (s[1] == 'x' || s[1] == 'X')) {
        r = 16;
        s = s.substring(2);
    }

    for ( i=0 ; i &#60; s.length && helper::isDigitForRadix(s[i], r) ; i++ )
        ;
    s = s.substring(0,i);

    if (s == "")
        return NaN;

    return sign * informative::numericValue(s, r);
}
</PRE>

<P><span class="pcounter"></span> The helper function <code>isDigitForRadix(c,r)</code> computes whether
<code>c</code> is a valid digit for the radix <code>r</code>, see <span class="xref">helper:isDigitForRadix</span>.

<P><span class="pcounter"></span>The informative function <code>numericValue(s, r)</code> computes the
numeric value of a radix-<code>r</code> string <code>s</code>.  If <code>r</code> is 10 and <code>s</code>
contains more than 20 significant digits, every significant digit
after the 20th may be replaced by a 0 digit, at the option of the
implementation; and if <code>r</code> is not 2, 4, 8, 10, 16, or 32, then the
returned value may be an implementation-dependent approximation to the
mathematical integer value that is represented by <code>s</code> in radix-<code>r</code>
notation.

<p class="note"><b>COMPATIBILITY NOTE</b>&nbsp;&nbsp; In the 3rd Edition of this Standard, the <code>parseInt</code> function was
allowed to, though not encouraged to, interpret a string with a
leading <code>0</code> but no leading <code>0x</code> or <code>0X</code> as a base-8 number if
the radix was not supplied in the call or was supplied as zero.  This
is no longer allowed; the function must interpret such a number as a
base-10 number.

<p class="note"><b>NOTE</b>&nbsp;&nbsp; <code>parseInt</code> may interpret only a leading portion of the string as an
integer value; it ignores any characters that cannot be interpreted as
part of the notation of an integer, and no indication is given that
any such characters were ignored.

<h4 id="helper:isDigitForRadix">isDigitForRadix </h4>

<PRE>
helper function isDigitForRadix(c, r) {
    c = c.toUpperCase();
    if (c >= '0' && c &#60;= '9')
        return (c.charCodeAt(0) - '0'.charCodeAt(0)) &#60; r;
    else if (c >= 'A' && c &#60;= 'Z')
        return (c.charCodeAt(0) - 'A'.charCodeAt(0) + 10) &#60; r;
    else
        return false;
}
</PRE>


<h3>parseInt&nbsp;(&nbsp;s,&nbsp;r=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span>The <code>parseInt</code> function converts its first argument to
<code>string</code> and its second argument to <code>int</code>, and then calls its
intrinsic counterpart.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span>The <code>parseInt</code> function returns a number.

<P class="implsection"><b>Implementation</b>
<PRE>
function parseInt(s, r=0)
    intrinsic::parseInt(string(s), int(r));
</PRE>


<h3>intrinsic::parseFloat&nbsp;(s)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span>The intrinsic <code>parseFloat</code> function computes a number value
dictated by interpretation of the contents of the string argument <i>s</i> as a
decimal literal.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>parseFloat</code> function returns a number.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic const function parseFloat(s: string) {
    FIXME: Needs implementation
}
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp; <code>parseFloat</code> may interpret only a leading portion of <i>s</i> as a
number value; it ignores any characters that cannot be interpreted as
part of the notation of an decimal literal, and no indication is given
that any such characters were ignored.

<h3>parseFloat&nbsp;(s)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span>The <code>parseFloat</code> function converts its argument to <code>string</code>,
then calls its intrinsic counterpart.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span>The <code>parseFloat</code> function returns a number.

<P class="implsection"><b>Implementation</b>
<PRE>
function parseFloat(s)
    intrinsic::parseFloat(string(s));
</PRE>


<h3>intrinsic::isNaN&nbsp;(number)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span>The intrinsic <code>isNaN</code> function tests whether a numeric value <i>number</i> is an
IEEE not-a-number value.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span>The intrinsic <code>isNaN</code> function returns 
<b>true</b> if <i>number</i> is <b>NaN</b>, and otherwise returns <b>false</b>.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic const function isNaN(n: AnyNumber): boolean
    (!(n === n));
</PRE>

<h3>isNaN&nbsp;(number)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span>The <code>isNaN</code> function converts its argument to a number, then
calls its intrinsic counterpart.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span>The <code>isNaN</code> function returns <b>true</b> if <i>number</i> is
<b>NaN</b>, and otherwise returns <b>false</b>.

<P class="implsection"><b>Implementation</b>
<PRE>
function isNaN(number)
    intrinsic::isNaN(Number(number));
</PRE>


<h3>intrinsic::isFinite&nbsp;(number)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span>The intrinsic <code>isFinite</code> function tests whether a numeric value <i>number</i> is
finite (neither not-a-number nor an infinity).

<P class="section"><b>Returns</b> <P><span class="pcounter"></span>The intrinsic <code>isFinite</code> function returns <b>true</b> if <i>number</i> is
finite, and otherwise returns <b>false</b>.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic const function isFinite(n: AnyNumber): boolean {
    return !isNaN(n) && n != -Infinity && n != Infinity;
}
</PRE>


<h3>isFinite&nbsp;(number)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span>The <code>isFinite</code> function converts its argument to a number,
then calls its intrinsic counterpart.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span>The <code>isFinite</code> function returns <b>true</b> if <i>number</i> is
finite, and otherwise returns <b>false</b>.

<P class="implsection"><b>Implementation</b>
<PRE>
function isFinite(x)
    intrinsic::isFinite(Number(x));
</PRE>


<h3>URI Handling Function Properties</h3>

<P><span class="pcounter"></span>Uniform Resource Identifiers, or URIs, are strings that identify
resources (e.g. web pages or files) and transport protocols by which
to access them (e.g. HTTP or FTP) on the Internet. The ECMAScript
language itself does not provide any support for using URIs except for
functions that encode and decode URIs as described in sections <span class="xref">decodeURI</span>, <span class="xref">decodeURIComponent</span>, <span class="xref">encodeURI</span>, and <span class="xref">encodeURIComponent</span>.

<p class="note"><b>NOTE</b>&nbsp;&nbsp; Many implementations of ECMAScript provide additional
functions and methods that manipulate web pages; these functions are
beyond the scope of this standard.

<P><span class="pcounter"></span>A URI is composed of a sequence of components separated by component separators. The general form is:
<div class="indented">
<i>Scheme <code>:</code> First <code>/</code> Second <code>;</code> Third <code>?</code> Fourth</i>
</div>

<P><span class="pcounter"></span>where the italicised names represent components and the ":", "/",
";" and "?" are reserved characters used as separators.  The
<code>encodeURI</code> and <code>decodeURI</code> functions are intended to work with
complete URIs; they assume that any reserved characters in the URI are
intended to have special meaning and so are not encoded.  The
<code>encodeURIComponent</code> and <code>decodeURIComponent</code> functions are
intended to work with the individual component parts of a URI; they
assume that any reserved characters represent text and so must be
encoded so that they are not interpreted as reserved characters when
the component is part of a complete URI.  The following lexical
grammar specifies the form of encoded URIs.

<div class="grammar">
<div class="nonterm">uri :::</div>
<div class="indented">uriCharacters<sub>opt</sub></div>

<div class="nonterm">uriCharacters :::</div>
<div class="indented">uriCharacter uriCharacters<sub>opt</sub></div>

<div class="nonterm">uriCharacter :::</div>
<div class="indented">uriReserved<br>
uriUnescaped<br>
uriEscaped</div>

<div class="nonterm">uriReserved ::: <b>one of</b></div>
<div class="indented"><code>; / ? : @ & = + $ ,</code></div>

<div class="nonterm">uriUnescaped :::</div>
<div class="indented">uriAlpha<br>
DecimalDigit<br>
uriMark</div>

<div class="nonterm">uriEscaped :::</div>
<div class="indented">% HexDigit HexDigit</div>

<div class="nonterm">uriAlpha ::: <b>one of</b></div>
<div class="indented"><code>a b c d e f g h i j k l m n o p q r s t u v w x y z</code><br>
<code>A B C D E F G H I J K L M N O P Q R S T U V W X Y Z</code></div>

<div class="nonterm">uriMark ::: <b>one of</b></div>
<div class="indented"><code>- _ . ! ~ * ' ( )</code></div>
</div>

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #170.)  Upgrade to Unicode 5 in the following
sections, and upgrade to handling the entire (21-bit) Unicode
character set.

<P><span class="pcounter"></span>When a character to be included in a URI is not listed above or is
not intended to have the special meaning sometimes given to the
reserved characters, that character must be encoded. The character is
first transformed into a sequence of octets using the UTF-8
transformation, with surrogate pairs first transformed from their
UCS-2 to UCS-4 encodings. (Note that for code points in the range
[0,127] this results in a single octet with the same value.)  The
resulting sequence of octets is then transformed into a string with
each octet represented by an escape sequence of the form "<code>%xx</code>".

<P><span class="pcounter"></span>The encoding and escaping process is described by the helper
function <code>encode</code> taking two string arguments <code>s</code> and
<code>unescapedSet</code>.

<PRE>
helper function encode(s: string, unescapedSet: string): string {
    let R = "";
    let k = 0;

    while (k != s.length) {
        let C = s[k];

        if (unescapedSet.indexOf(C) != -1) {
            R = R + C;
            k = k + 1;
            continue;
        }

        let V = C.charCodeAt(0);
        if (V >= 0xDC00 && V &#60;= 0xDFFF)
            throw new URIError("Invalid code");
        if (V >= 0xD800 && V &#60;= 0xDBFF) {
            k = k + 1;
            if (k == s.length)
                throw new URIError("Truncated code");
            let V2 = s[k].charCodeAt(0);
            V = (V - 0xD800) * 0x400 + (V2 - 0xDC00) + 0x10000;
        }

        let octets = helper::toUTF8(V);
        for ( let j=0 ; j &#60; octets.length ; j++ )
            R = R + "%" + helper::twoHexDigits(octets[j]);
        k = k + 1;
    }
    return R;
}

helper function twoHexDigits(B) {
    let s = "0123456789ABCDEF";
    return s[B >> 4] + s[B & 15];
}
</PRE>

<P><span class="pcounter"></span>The unescaping and decoding process is described by the helper
function <code>decode</code> taking two string arguments <code>s</code> and
<code>reservedSet</code>.

<PRE>
helper function decode(s: string, reservedSet: string): string {
    let R = "";
    let k = 0;
    while (k != s.length) {
        if (s[k] != "%") {
            R = R + s[k];
            k = k + 1;
            continue;
        }

        let start = k;
        let B = helper::decodeHexEscape(s, k);
        k = k + 3;

        if ((B & 0x80) == 0) {
            let C = string.fromCharCode(B);
            if (reservedSet.indexOf(C) != -1)
                R = R + s.substring(start, k);
            else
                R = R + C;
            continue;
        }

        let n = 1;
        while (((B &#60;&#60; n) & 0x80) == 1)
            ++n;
        if (n == 1 || n > 4)
            throw new URIError("Invalid encoded character");

        let octets = [B];
        for ( let j=1 ; j &#60; n ; ++j ) {
            let B = helper::decodeHexEscape(s, k);
            if ((B & 0xC0) != 0x80)
                throw new URIError("Invalid encoded character");
            k = k + 3;
            octets.push(B);
        }
        let V = helper::fromUTF8(octets);
        if (V > 0x10FFFF)
            throw new URIError("Invalid Unicode code point");
        if (V > 0xFFFF) {
            L = ((V - 0x10000) & 0x3FF) + 0xD800;
            H = (((V - 0x10000) >> 10) & 0x3FF) + 0xD800;
            R = R + string.fromCharCode(H, L);
        }
        else {
            let C = string.fromCharCode(V);
            if (reservedSet.indexOf(C))
                R = R + s.substring(start, k);
            else
                R = R + C;
        }
    }
    return R;
}

helper function decodeHexEscape(s, k) {
    if (k + 2 >= s.length ||
        s[k] != "%" ||
        !helper::isDigitForRadix(s[k+1], 16) && !helper::isDigitForRadix(s[k+1], 16))
        throw new URIError("Invalid escape sequence");
    return parseInt(s.substring(k+1, k+3), 16);
}
</PRE>

<P><span class="pcounter"></span>The helper function <code>isDigitForRadix</code> was defined in section
<span class="xref">helper:isDigitForRadix</span>.

<p class="note"><b>NOTE</b>&nbsp;&nbsp; The syntax of Uniform Resource Identifiers is given in
RFC2396.

<p class="note"><b>NOTE</b>&nbsp;&nbsp; A formal description and implementation of UTF-8 is
given in the Unicode Standard, Version 2.0, Appendix A.  In UTF-8,
characters are encoded using sequences of 1 to 6 octets. The only
octet of a "sequence" of one has the higher-order bit set to 0, the
remaining 7 bits being used to encode the character value. In a
sequence of n octets, n>1, the initial octet has the n higher-order
bits set to 1, followed by a bit set to 0. The remaining bits of that
octet contain bits from the value of the character to be encoded. The
following octets all have the higher-order bit set to 1 and the
following bit set to 0, leaving 6 bits in each to contain bits from
the character to be encoded. The possible UTF-8 encodings of
ECMAScript characters are:

<center>
<table border="1">
  <tr><th>Code Point Value</th><th>Representation</th>    <th>1st Octet</th><th>2nd Octet</th><th>3rd Octet</th><th>4th Octet</th></tr>
  <tr><td>0x0000 - 0x007F</td> <td>00000000 0zzzzzzz</td> <td>0zzzzzzz</td></tr>
  <tr><td>0x0080 - 0x07FF</td> <td>00000yyy yyzzzzzz</td> <td>110yyyyy</td> <td>10zzzzzz</td></tr>
  <tr><td>0x0800 - 0xD7FF</td> <td>xxxxyyyy yyzzzzzz</td> <td>1110xxxx</td> <td>10yyyyyy</td><td>10zzzzzz</td></tr>
  <tr><td>0xD800 - 0xDBFF<br>
          followed by<br>
          0xDC00 - 0xDFFF</td> <td>110110vv vvwwwwxx<br>
                                   followed by<br>
                                   110111yy yyzzzzzz</td> <td>11110uuu</td> <td>10uuwwww</td> <td>10xxyyyy</td> <td>10zzzzzz</td></tr>
  <tr><td>0xD800 - 0xDBFF<br>
      not followed by<br>
      0xDC00 - 0xDFFF</td>     <td>causes URIError</td></tr>
  <tr><td>0xDC00 - 0xDFFF</td> <td>causes URIError</td></tr>
  <tr><td>0xE000 - 0xFFFF</td> <td>xxxxyyyy yyzzzzzz</td> <td>1110xxxx</td> <td>10yyyyyy</td> <td>10zzzzzz</td></tr>
</table>
</center>

<P><span class="pcounter"></span>Where
<div class="indented">uuuuu = vvvv + 1</div>
<P><span class="pcounter"></span>to account for the addition of 0x10000 as in section 3.7,
Surrogates of the Unicode Standard version 2.0.

<P><span class="pcounter"></span>The range of code point values 0xD800-0xDFFF is used to encode
surrogate pairs; the above transformation combines a UCS-2 surrogate
pair into a UCS-4 representation and encodes the resulting 21-bit
value in UTF-8. Decoding reconstructs the surrogate pair.

<P><span class="pcounter"></span>The helper functions <code>encode</code> and <code>decode</code>, defined above, use
the helper functions <code>toUTF8</code> and <code>fromUTF8</code> to convert code
points to UTF-8 sequences and to convert UTF-8 sequences to code
points, respectively.

<PRE>
helper function toUTF8(v: uint) {
    if (v &#60;= 0x7F)
        return [v];
    if (v &#60;= 0x7FF)
        return [0xC0 | ((v >> 6) & 0x3F),
                0x80 | (v & 0x3F)];
    if (v &#60;= 0xD7FF || v >= 0xE000 && v &#60;= 0xFFFF)
        return [0xE0 | ((v >> 12) & 0x0F),
                0x80 | ((v >> 6) & 0x3F),
                0x80 | (v & 0x3F)];
    if (v >= 0x10000)
        return [0xF0 | ((v >> 18) & 0x07),
                0x80 | ((v >> 12) & 0x3F),
                0x80 | ((v >> 6) & 0x3F),
                0x80 | (v & 0x3F)];
    throw URIError("Unconvertable code");
}

helper function fromUTF8(octets) {
    let B = octets[0];
    let V;
    if ((B & 0x80) == 0)
        V = B;
    else if ((B & 0xE0) == 0xC0)
        V = B & 0x1F;
    else if ((B & 0xF0) == 0xE0)
        V = B & 0x0F;
    else if ((B & 0xF8) == 0xF0)
        V = B & 0x07;
    for ( let j=1 ; j &#60; octets.length ; j++ )
        V = (V &#60;&#60; 6) | (octets[j] & 0x3F);
    return V;
}
</PRE>

<P><span class="pcounter"></span>Several helper strings are defined based on the grammar shown
previously:

<PRE>
helper const uriReserved = ";/?:@&=+$,";

helper const uriAlpha = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";

helper const uriDigit = "0123456789";

helper const uriMark = "-_.!~*'()";

helper const uriUnescaped = helper::uriAlpha + helper::uriDigit + helper::uriMark;
</PRE>


<h4>intrinsic::decodeURI&nbsp;(encodedURI)</h4>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>decodeURI</code> function computes a new version of
a URI in which each escape sequence and UTF-8 encoding of the sort
that might be introduced by the <code>encodeURI</code> function is replaced
with the character that it represents.  Escape sequences that could
not have been introduced by <code>encodeURI</code> are not replaced.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>decodeURI</code> function returns a decoded string.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic const function decodeURI(encodedURI: string)
    helper::decode(encodedURI, helper::uriReserved + "#");
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp; The character "<code>#</code>" is not decoded from escape sequences even
though it is not a reserved URI character.

<h4>decodeURI&nbsp;(encodedURI)</h4>

<P class="section"><b>Description</b> <P><span class="pcounter"></span>The <code>decodeURI</code> function converts its argument to <code>string</code>, then
calls its intrinsic counterpart.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>decodeURI</code> function returns a decoded string.

<P class="implsection"><b>Implementation</b>
<PRE>
function decodeURI(encodedURI)
    intrinsic::decodeURI(string(encodedURI));
</PRE>


<h4>intrinsic::decodeURIComponent&nbsp;(encodedURIComponent)</h4>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>decodeURIComponent</code> function computes a new
version of a URI in which each escape sequence and UTF-8 encoding of
the sort that might be introduced by the <code>encodeURIComponent</code>
function is replaced with the character that it represents.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>decodeURIComponent</code> function returns a decoded string.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic const function decodeURIComponent(encodedURIComponent)
    helper::decode(encodedURIComponent, "");
</PRE>

<h4>decodeURIComponent&nbsp;(encodedURIComponent)</h4>

<P class="section"><b>Description</b> <P><span class="pcounter"></span>The <code>decodeURIComponent</code> function converts its argument to
<code>string</code>, then calls its intrinsic counterpart.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>decodeURIComponent</code> function returns a decoded string.

<P class="implsection"><b>Implementation</b>
<PRE>
function decodeURIComponent(encodedURIComponent)
    intrinsic::decodeURIComponent(string(encodedURIComponent));
</PRE>


<h4>intrinsic::encodeURI&nbsp;(uri)</h4>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>encodeURI</code> function computes a new version of
a URI in which each instance of certain characters is replaced by one,
two or three escape sequences representing the UTF-8 encoding of the
character.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>encodeURI</code> function returns a encoded string.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic const function encodeURI(uri: string): string
    helper::encode(uri, helper::uriReserved + helper::uriUnescaped + "#")
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp; The character "<code>#</code>" is not encoded to an escape sequence
even though it is not a reserved or unescaped URI character.

<h4>encodeURI&nbsp;(uri)</h4>

<P class="section"><b>Description</b> <P><span class="pcounter"></span>The <code>encodeURI</code> function converts its argument to string, then
calls its intrinsic counterpart.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>encodeURI</code> function returns a encoded string.

<P class="implsection"><b>Implementation</b>
<PRE>
function encodeURI(uri)
    intrinsic::encodeURI(string(uri));
</PRE>


<h4>intrinsic::encodeURIComponent&nbsp;(uriComponent)</h4>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>encodeURIComponent</code> function computes a new
version of a URI in which each instance of certain characters is
replaced by one, two or three escape sequences representing the UTF-8
encoding of the character.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>encodeURIComponent</code> function returns a encoded string.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic const function encodeURIComponent(uriComponent: string): string
    helper::encode(uri, helper::uriReserved);
</PRE>

<h4>encodeURIComponent&nbsp;(uriComponent)</h4>

<P class="section"><b>Description</b> <P><span class="pcounter"></span>The <code>encodeURIComponent</code> function converts its
argument to string, then calls its intrinsic counterpart.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>encodeURIComponent</code> function returns a encoded string.

<P class="implsection"><b>Implementation</b>
<PRE>
function encodeURIComponent(uriComponent)
    intrinsic::encodeURIComponent(string(uriComponent));
</PRE>


<h3>intrinsic::hashcode&nbsp;(x)</h3>



<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>hashcode</code> function computes a numeric value
for its argument such that if two values <code>v1</code> and <code>v2</code> are equal
by the operator <code>intrinsic::===</code> then <code>hashcode(v1)</code> is
numerically equal to <code>hashcode(v2)</code>.

<P><span class="pcounter"></span> The hashcode of any value for which <code>isNaN</code> returns <b>true</b> is
zero.

<P><span class="pcounter"></span> The hashcode computed for an object does not change over time.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>hashcode</code> function returns an unsigned integer.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic const function hashcode(o): uint {
    switch type (o) {
    case (x: null)      { return 0u }
    case (x: undefined) { return 0u }
    case (x: boolean)   { return uint(x) }
    case (x: Boolean)   { return uint(x) }
    case (x: int)       { return x &#60; 0 ? -x : x }
    case (x: uint)      { return x }
    case (x: double)    { return isNaN(x) ? 0u : uint(x) }
    case (x: decimal)   { return isNaN(x) ? 0u : uint(x) }
    case (x: Number)    { return isNaN(x) ? 0u : uint(x) }
    case (x: string)    { return informative::stringHash(string(x)) }
    case (x: String)    { return informative::stringHash(string(x)) }
    case (x: *)         { return informative::objectHash(x) }
    }
}
</PRE>

<P><span class="pcounter"></span> The informative functions <code>stringHash</code> and <code>objectHash</code>
compute hash values for strings and arbitrary objects, respectively.
They can take into account their arguments' immutable structure only.

<P><span class="pcounter"></span> The implementation should strive to compute different hashcodes
for objects that are not the same by <code>intrinsic::===</code>, as the
utility of this function depends on that property.  (The user program
should be able to expect that the hashcodes of objects that are not
the same are different with high probability.)

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  A typical implementation of <code>stringHash</code> will make use of the
string's character sequence and its length.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  A typical implementation of <code>objectHash</code> may make use of the
object's address in memory if the object, or it may maintain a
separate table mapping objects to hash codes.

<p class="note"><b>IMPLEMENTATION NOTE</b>&nbsp;&nbsp; The intrinsic <code>hashcode</code> function should not return
pointer values cast to integers, even in implementations that do not
use a moving garbage collector.  Exposing memory locations of objects
may make security vulnerabilities in the host environment
significantly worse.  Implementations -- in particular those which
read network input -- should return numbers unrelated to memory
addresses if possible, or at least use memory addresses subject to
some cryptographically strong one-way transformation, or sequence
numbers, cookies, or similar.



<h2>Class and Interface Properties of the Global Object</h2>

<P><span class="pcounter"></span>The class properties of the global object are defined in later sections of this Standard:
<ul>
  <li> The <code>Object</code> class is defined in section <span class="xref">class Object</span>
  <li> The <code>Function</code> class is defined in section <span class="xref">class Function</span>
  <li> The <code>Name</code> class is defined in section <span class="xref">class Name</span>
  <li> The <code>Namespace</code> class is defined in section <span class="xref">class Namespace</span>
  <li> The <code>Array</code> class is defined in section <span class="xref">class Array</span>
  <li> The <code>String</code> and <code>string</code> classes are defined in sections <span class="xref">class String</span> and <span class="xref">class string</span>, respectively.
  <li> The <code>Boolean</code> and <code>boolean</code> classes are defined in sections <span class="xref">class Boolean</span> and <span class="xref">class boolean</span>, respectively.
  <li> The <code>Number</code>, <code>int</code>, <code>uint</code>, <code>double</code>, and <code>decimal</code> classes are defined in sections <span class="xref">class Number</span>, <span class="xref">class int</span>, <span class="xref">class uint</span>, <span class="xref">class double</span>, and <span class="xref">class decimal</span>, respectively.
  <li> The <code>Date</code> class is defined in section <span class="xref">class Date</span>
  <li> The <code>RegExp</code> class is defined in section <span class="xref">class RegExp</span>
  <li> The <code>Map</code> class is defined in section <span class="xref">class Map</span>
  <li> The <code>Vector</code> class is defined in section <span class="xref">class Vector</span>
  <li> The <code>ByteArray</code> class is defined in section <span class="xref">class ByteArray</span>
  <li> The <code>ControlInspector</code> class is defined in section <span class="xref">class ControlInspector</span>
  <li> The <code>Error</code> class and its subclasses <code>EvalError</code>, <code>RangeError</code>, <code>ReferenceError</code>, <code>SyntaxError</code>, <code>TypeError</code>, and <code>URIError</code> are defined in sections <span class="xref">class Error</span>, <span class="xref">class EvalError</span>, <span class="xref">class RangeError</span>, <span class="xref">class ReferenceError</span>,  <span class="xref">class SyntaxError</span>, <span class="xref">class TypeError</span>, and <span class="xref">class URIError</span>, respectively.
</ul>



<h2>Type Properties on the Global Object</h2>

<h3>EnumerableId</h3>

<P><span class="pcounter"></span>The type <code>EnumerableId</code> is a union type that collects all nominal
types that are treated as property names by the iteration protocol and the
built-in objects:

<PRE>
__ES4__ type EnumerableId = (int,uint,Name,string);
</PRE>

<h3>Numeric</h3>

<P><span class="pcounter"></span>The type <code>Numeric</code> is a union type that collects all nominal
types that are treated as numbers by the implementation:

<PRE>
__ES4__ type Numeric = (int,uint,double,decimal,Number);
</PRE>


<h2>Meta-Object Interface and Type Properties of the Global Object</h2>

<P><span class="pcounter"></span> The interface types <code>Field</code>, <code>FieldValue</code>, <code>Type</code>,
<code>NominalType</code>, <code>InterfaceType</code>, <code>ClassType</code>, <code>UnionType</code>,
<code>RecordType</code>, <code>FunctionType</code>, and <code>ArrayType</code>, as well as the
structural types <code>FieldIterator</code>, <code>FieldValueIterator</code>,
<code>TypeIterator</code>, and <code>InterfaceIterator</code>, are defined in section
<span class="xref">meta-objects</span>.


<h2>Other Properties of the Global Object</h2>

<h3>Math</h3>

<P><span class="pcounter"></span> See section <span class="xref">math-object</span>.

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #171.) Currently we have a single <code>const</code> math
object that has some intrinsic fixture methods and some nonintrinsic
dynamic methods, as per E262-3.  When the user opens <code>intrinsic</code> the
intrinsic methods will be perferred, but only because the
implementation knows the type of the Math object in the global
environment.  This type is not exposed in the spec.  Thus the math
object can't be passed around as a strongly typed parameter (should we
wish for it).

<P class="fixme"> Alternative approaches are to (a) expose that type
and (b) separate the intrinsic bindings from the nonintrinsic global
bindings by having two bindings for Math, one of them intrinsic, the
other not.  (And in case (b) we'd expose that type, and it'd be final
and nondynamic.)

<h3>global</h3>



<P><span class="pcounter"></span>The intrinsic <code>global</code> property holds a reference to the global
object that contains that property.

<p class="note"><b>NOTE</b>&nbsp;&nbsp; There may be multiple global objects in a program, but these
objects may share values or immutable state: for example, their
<code>isNaN</code> properties may hold the same function object.  However, each
global object has separate mutable state, and a separate value for the
intrinsic <code>global</code> property.

<p class="note"><b>NOTE</b>&nbsp;&nbsp; This property is new in 4th Edition.



<h1 id="class Object"> The class <code>Object</code> </h1>

<pre>
FILE:                       spec/library/Object.html
DRAFT STATUS:               DRAFT 1 - ROUGH - 2007-09-20
REVIEWED AGAINST ES3:       NO
REVIEWED AGAINST ERRATA:    NO
REVIEWED AGAINST BASE DOC:  NO
REVIEWED AGAINST PROPOSALS: NO
REVIEWED AGAINST CODE:      NO
</pre>

<P><span class="pcounter"></span> The class <code>Object</code> is a dynamic non-final class that does not
subclass any other objects: it is the root of the class hierarchy.

<P><span class="pcounter"></span> All values in ECMAScript except <b>undefined</b> and <b>null</b> are
instances of the class <code>Object</code> or one of its subclasses.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  Host objects may not be instances of <code>Object</code> or its
subclasses, but must to some extent behave as if they are (see <span class="xref">Host objects</span>).


<h2>Synopsis</h2>

<P><span class="pcounter"></span>The class <code>Object</code> provides this interface:

<PRE>
dynamic class Object
{
    function Object(value=undefined) &#x0085;
    meta static function invoke(value=undefined) &#x0085

    static const length = 1

    intrinsic function toString() : string &#x0085
    intrinsic function toLocaleString() : string &#x0085
    intrinsic function toJSONString(pretty: boolean=false) : string &#x0085
    intrinsic function valueOf() : Object! &#x0085
    intrinsic function hasOwnProperty(V: EnumerableId): boolean &#x0085
    intrinsic function isPrototypeOf(V): boolean &#x0085
    intrinsic function propertyIsEnumerable(prop: EnumerableId, &#x0085
}
</PRE>

<P><span class="pcounter"></span> The <code>Object</code> prototype object provides these direct properties:
<PRE>
    toString:             function () &#x0085; ,
    toLocaleString:       function () &#x0085; ,
    toJSONString:         function () &#x0085; ,
    valueOf:              function () &#x0085; ,
    hasOwnProperty:       function (V) &#x0085; ,
    isPrototypeOf:        function (V) &#x0085; ,
    propertyIsEnumerable: function (name, flag=undefined) &#x0085; ,
</PRE>

<P><span class="pcounter"></span> The <code>Object</code> prototype object is itself an instance of the class
<code>Object</code>, with the exception that the value of its <code>[[Prototype]]</code>
property is <b>null</b>.


<h2>Methods on the <code>Object</code> class object</h2>

<h3>new&nbsp;Object&nbsp;(&nbsp;value=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> When the <code>Object</code> constructor is called with an argument
<i>value</i> (defaulting to <b>undefined</b>) as part of a <code>new</code>
expression, it transforms the <i>value</i> to an object in a way that
depends on the type of <i>value</i>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>Object</code> constructor returns an object (an instance of
<code>Object</code> or one of its subclasses, or a host object).

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The <code>Object</code> constructor is the only constructor function
defined on a class in the language whose result may be a value of a
different class than the one in which the constructor is defined.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span> The <code>Object</code> constructor can't be expressed as a regular
ECMAScript constructor.  Instead it is presented below as a function
<code>makeObject</code> that the ECMAScript implementation will invoke when
it evaluates <code>new Object</code>.

<P><span class="pcounter"></span> The function <code>makeObject</code> is only invoked on native ECMAScript
values.  If <code>new Object</code> is evaluated on a host object, then actions
are taken and a result is returned in an implementation dependent
manner that may depend on the host object.

<PRE>
function makeObject(value=undefined) {
    switch type (value) {
    case (s:string) { 
        return new String(s);
    }
    case (b:boolean) { 
        return new Boolean(b);
    }
    case (n:(int,uint,double,decimal)) { 
        return new Number(n);
    }
    case (o:Object) {
        return o;
    }
    case (x:(null,undefined)) { 
        return magic::createObject();
    }
    }
}
</PRE>


<h3>Object&nbsp;(&nbsp;value=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> When the <code>Object</code> class object is called as a function with zero
or one arguments it performs a type conversion.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> It returns the converted value.

<P class="implsection"><b>Implementation</b>
<PRE>
meta static function invoke(value=undefined) {
    if (value === null || value === undefined)
        return new Object();
    return new Object(value);
}
</PRE>



<h2>Methods on <code>Object</code> instances</h2>

<h3>intrinsic::toString&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toString</code> method converts the <code>this</code> object
to a string.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>toString</code> method returns the concatenation of
<code>"["</code>, <code>"Object"</code>, the class name of the object, and <code>"]"</code>.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function toString() : string
    "[object " + magic::getClassName(this) + "]";
</PRE>

<P><span class="pcounter"></span> The function <code>magic::getClassName</code> extracts the class name
from the object.  See <span class="xref">magic:getClassName</span>.


<h3>intrinsic::toLocaleString&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toLocaleString</code> method calls the public
<code>toString</code> method on the <code>this</code> object.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  This method is provided to give all objects a generic
<code>toLocaleString</code> interface, even though not all may use it.
Currently, <code>Array</code>, <code>Number</code>, and <code>Date</code> provide their own
locale-sensitive <code>toLocaleString</code> methods.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The first parameter to this function is likely to be used in a
future version of this standard; it is recommended that
implementations do not use this parameter position for anything else.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>toLocaleString</code> method returns a string.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function toLocaleString() : string
    this.public::toString();
</PRE>


<h3>intrinsic::toJSONString&nbsp;(&nbsp;pretty=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toJSONString</code> method convert this object to
JSON format (<CITE ref="RFC4627">RFC 4627</CITE>).

<P><span class="pcounter"></span> The object is serialized as a a sequence of comma (<code>","</code>)
separated pairs wrapped in curly braces (<code>"{"</code> and <code>"}"</code>).  Each
pair consists of a property name and a property value, separated by a
colon (<code>":"</code>).  The string representation of a property value is
computed by calling the public <code>toJSONString</code> method on the value.

<P><span class="pcounter"></span> The <code>[[Prototype]]</code> internal property is not used when computing the
set of properties of an object that will be serialized.

<P><span class="pcounter"></span> Values which are not directly represented in JSON (such as
<b>undefined</b>, functions, and unknown types) will be silently skipped.
The value <b>null</b> is serialized as the unquoted string <code>null</code>.

<P><span class="pcounter"></span> An <b>EncodingError</b> exception will be thrown if this object
contains a cyclical (sub)structure.  Recurring objects that do not
cause cycles are allowed, but will produce a complete text for each
occurrence.

<P><span class="pcounter"></span> If <i>pretty</i> is true, then linefeeds are inserted after each left
curly brace and comma and before a right curly brace, and multiples of
4 spaces are inserted to indicate the level of nesting, and one space
will be inserted after the separating colon.  Otherwise, no whitespace
is inserted between the tokens.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>toJSONString</code> method returns a <code>string</code>.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span> The <code>toJSONString</code> method is implementation-dependent.

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #201.)  Only cycle finding need be
implementation-dependent, we should have code here.

<h3>intrinsic::valueOf&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>valueOf</code> method returns its <code>this</code> value.

<P><span class="pcounter"></span> If the object is the result of calling the Object constructor with
a host object (<span class="xref">Host objects</span>), it is
implementation-defined whether <code>valueOf</code> returns its <code>this</code> value
or another value such as the host object originally passed to the
constructor.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>toLocaleString</code> method returns an object value.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function valueOf() : Object!
    this;
</PRE>


<h3>intrinsic::hasOwnProperty&nbsp;(&nbsp;name&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>hasOwnProperty</code> method determines whether the
<code>this</code> object contains a property with a certain <i>name</i>, without
considering the prototype chain.

<p class="note"><b>NOTE</b>&nbsp;&nbsp; Unlike <code>[[HasProperty]]</code> (<span class="xref">HasProperty-defn</span>), this
method does not consider objects in the prototype chain.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>hasOwnProperty</code> method returns <code>true</code> if the
object contains the property, otherwise it returns <code>false</code>.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function hasOwnProperty(V: EnumerableId): boolean
    magic::hasOwnProperty(this, V);
</PRE>

<P><span class="pcounter"></span> The function <code>magic::hasOwnProperty</code> tests whether the object
contains the named property on its local property list (the prototype
chain is not considered).  See <span class="xref">magic:hasOwnProperty</span>.


<h3>intrinsic::isPrototypeOf&nbsp;(&nbsp;obj&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>isPrototypeOf</code> method determines whether its
<code>this</code> object is a prototype object of the argument <i>obj</i>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>isPrototypeOf</code> method returns <code>true</code> if the
<code>this</code> object is on the prototype chain of <i>obj</i>, otherwise it
returns <code>false</code>.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function isPrototypeOf(V): boolean
    private::isPrototypeOf(this,V);
</PRE>

<P><span class="pcounter"></span> The function <code>magic::getPrototype</code> extracts the <code>[[Prototype]]</code> property
from the object.  See <span class="xref">magic:getPrototype</span>.


<h3>intrinsic::propertyIsEnumerable&nbsp;(&nbsp;name,&nbsp;flag=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>propertyIsEnumerable</code> method retrieves, and
optionally sets, the enumerability flag for a property with a certain
<i>name</i> on the <code>this</code> object, without considering the prototype
chain.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  This method does not consider objects in the prototype chain.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>propertyIsEnumerable</code> method returns <code>false</code>
if the property does not exist on the <code>this</code> object; otherwise it
returns the value of the enumerability flag for the property before
any change was made.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function propertyIsEnumerable(prop: EnumerableId,
                                        e:(boolean,undefined) = undefined): boolean
    private::propertyIsEnumerable(this, prop, e);
</PRE>

<P><span class="pcounter"></span> The function <code>magic::hasOwnProperty</code> tests whether the object
contains the named property on its local property list.  See <span class="xref">magic:hasOwnProperty</span>.

<P><span class="pcounter"></span> The function <code>magic::getPropertyIsDontEnum</code> gets the DontEnum
flag of the property.  See <span class="xref">magic:getPropertyIsDontEnum</span>.

<P><span class="pcounter"></span> The function <code>magic::getPropertyIsDontDelete</code> gets the DontDelete
flag of the property.  See <span class="xref">magic:getPropertyIsDontDelete</span>.

<P><span class="pcounter"></span> The function <code>magic::setPropertyIsDontEnum</code> sets the DontEnum
flag of the property.  See <span class="xref">magic:setPropertyIsDontEnum</span>.


<h2>Methods on the <code>Object</code> prototype object</h2>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The methods on the <code>Object</code> prototype object all call the
corresponding intrinsic methods of the <code>Object</code> class.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The prototype methods return what their corresponding intrinsic
methods return.

<P class="implsection"><b>Implementation</b>
<PRE>
prototype function toString()
    "[object " + magic::getClassName(this) + "]";

prototype function toLocaleString()
    this.public::toString();

prototype function toJSONString(pretty=false)
    JSON.formatObject(this, pretty);

prototype function valueOf()
    this;

prototype function hasOwnProperty(V)
    magic::hasOwnProperty(this, V is EnumerableId ? V : string(V));

prototype function isPrototypeOf(V)
    private::isPrototypeOf(this,V);

prototype function propertyIsEnumerable(prop, e=undefined)
    private::propertyIsEnumerable(this,
                                 prop is EnumerableId ? prop : string(prop),
                                 e is (boolean,undefined) ? e : boolean(e));
</PRE>




<h1 id="class Function"> The class <code>Function</code> </h1>

<pre>
FILE:                       spec/library/Function.html
DRAFT STATUS:               DRAFT 1 - ROUGH - 2007-09-19
REVIEWED AGAINST ES3:       NO
REVIEWED AGAINST ERRATA:    NO
REVIEWED AGAINST BASE DOC:  NO
REVIEWED AGAINST PROPOSALS: NO
REVIEWED AGAINST CODE:      NO
</pre>

<P><span class="pcounter"></span> The class <code>Function</code> is a dynamic non-final subclass of
<code>Object</code> (see <span class="xref">class Object</span>).

<P><span class="pcounter"></span> All objects defined by <code>function</code> definitions or expressions in
ECMAScript are instances of the class <code>Function</code>.

<P><span class="pcounter"></span> Not all objects that can be called as functions are instances of
subclasses of the <code>Function</code> class, however.  Any object that has a
<code>meta invoke</code> method can be called as a function.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  Host functions may also not be instances of <code>Function</code> or its
subclasses, but must to some extent behave as if they are (see <span class="xref">Host objects</span>).


<h2>Synopsis</h2>

<P><span class="pcounter"></span> The class <code>Function</code> provides the following interface:

<PRE>
dynamic class Function extends Object
{
    function Function(...args) &#x0085
    meta static function invoke(...args) &#x0085

    static function apply(fn : Function!, thisArg=undefined, argArray=undefined) &#x0085
    static function call(fn, thisObj=undefined, ...args:Array):* &#x0085

    static const length = 1

    meta final function invoke( &#x0085; ) &#x0085;

    override intrinsic function toString() : string &#x0085

    intrinsic function apply(thisArg=undefined, argArray=undefined) &#x0085
    intrinsic function call(thisObj=undefined, ...args) &#x0085
    intrinsic function HasInstance(V) &#x0085

    const length = &#x0085;
    var   prototype = &#x0085;
}
</PRE>

<P><span class="pcounter"></span>The <code>Function</code> prototype object provides these direct properties:

<PRE>
    toString:    function () &#x0085; ,
    apply:       function(thisArg, argArray) &#x0085; ,
    call:        function(thisArg, ...args) &#x0085; ,
</PRE>


<h2>Methods on the <code>Function</code> class object</h2>

<H3 id="Function: constructor"> new Function (p1, p2, &#x0085; , pn, body) </h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> When the <code>Function</code> constructor is called with some arguments as
part of a <code>new</code> expression, it creates a new <code>Function</code> instance
whose parameter list is given by the concatenation of the <i>p<SUB>i</SUB></i>
arguments and whose executable code is given by the <i>body</i> argument.

<P><span class="pcounter"></span> There may be no <i>p<SUB>i</SUB></i> arguments, and <i>body</i> is optional too,
defaulting to the empty string.

<P><span class="pcounter"></span> If the list of parameters is not parsable as a
<i>FormalParameterList<sub>opt</sub></i>, or if the body is not parsable
as a <i>FunctionBody</i>, then a <b>SyntaxError</b> exception is thrown (see
the grammar in section <span class="xref">ECMAScript grammar</span>).

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>Function</code> constructor returns a new <code>Function</code> instance.

<P class="implsection"><b>Implementation</b>

<PRE>
function Function(...args)
    helper::createFunction(args);

helper function createFunction(args) {
    let parameters = "";
    let body = "";
    if (args.length > 0) {
        body = args[args.length-1];
        args.length = args.length-1;
        parameters = args.join(",");
    }
    body = string(body);
    magic::initializeFunction(this, intrinsic::global, parameters, body);
}
</PRE>

<P><span class="pcounter"></span> The helper function <code>createFunction</code> is also used by the
<code>invoke</code> method (see <span class="xref">Function: meta static invoke</span>).

<P><span class="pcounter"></span> The magic function <code>initializeFunction</code> initializes the function
object <code>this</code> from the list of parameters and the body, as specified
in section <span class="xref">translation:FunctionExpression</span>.  The global
object is passed in as the Scope parameter.

<P><span class="pcounter"></span>A <code>prototype</code> property is automatically created for every function, to
provide for the possibility that the function will be used as a
constructor.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  It is permissible but not necessary to have one argument for
each formal parameter to be specified. For example, all three of the
following expressions produce the same result:

<PRE>
new Function("a", "b", "c", "return a+b+c")

new Function("a, b, c", "return a+b+c")

new Function("a,b", "c", "return a+b+c")
</PRE>

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #172.)  Type annotations?  The RI barfs (looks like an
incomplete or incorrect set of namespaces is provided during
construction).

<p class="fixme"> Return type annotations?  No way to specify this using the
current shape of the constructor.

<p class="fixme"> Default values?  The RI says yes.

<p class="fixme"> Rest arguments?  The RI says yes.

<p class="fixme"> One possibility is to extend the syntax, s.t. the
<i>p<SUB>i</SUB></i> concatenated can form a syntactically valid
parameter list bracketed by <code>(</code> and <code>)</code>; this creates the
possibility that a return type annotation can follow the <code>)</code>.


<h3 id="Function: meta static invoke">Function&nbsp;(p1,&nbsp;p2,&nbsp;&#x0085;&nbsp;,&nbsp;pn,&nbsp;body)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> When the <code>Function</code> class object is called as a function it
creates and initialises a new <code>Function</code> object.  Thus the function
call <code>Function(&#x0085;)</code> is equivalent to the object creation
expression <code>new Function(&#x0085;)</code> with the same arguments.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>Function</code> class object called as a function returns a
new <code>Function</code> instance.

<P class="implsection"><b>Implementation</b>


<PRE>
meta static function invoke(...args)
    helper::createFunction(args)
</PRE>

<P><span class="pcounter"></span> The helper function <code>createFunction</code> was defined along with the
<code>Function</code> constructor (see <span class="xref">Function: constructor</span>).


<h3>apply&nbsp;(&nbsp;fn,&nbsp;thisArg=&#x0085;,&nbsp;argArray=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>apply</code> method takes arguments <i>fn</i>, <i>thisArg</i>, and
<i>argArray</i>, and performs a function call using the <code>[[Call]]</code> property
of <i>fn</i>, passing <i>thisArg</i> as the value for <code>this</code> and the
members of <i>argArray</i> as the individual argument values.

<P><span class="pcounter"></span> If <i>fn</i> does not have a <code>[[Call]]</code> property, a <b>TypeError</b>
exception is thrown.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>apply</code> method returns the value returned by <i>fn</i>.

<P class="implsection"><b>Implementation</b>

<PRE>
static function apply(fn : Function!, thisArg=undefined, argArray=undefined) {
    if (thisArg === undefined || thisArg === null)
        thisArg = global;
    if (argArray === undefined || argArray === null)
        argArray = [];
    else if (!(argArray is Array))
        throw new TypeError("argument array to 'apply' must be Array");
    return magic::apply(fn, thisArg, argArray);
}
</PRE>

<P><span class="pcounter"></span> The magic <code>apply</code> function performs the actual invocation (see
<span class="xref">magic::apply</span>).


<h3>call&nbsp;(&nbsp;fn,&nbsp;thisArg=&#x0085;,&nbsp;...args&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>call</code> method takes arguments <i>fn</i> and <i>thisArg</i> and
optionally some <i>args</i>, and performs a function call using the
<code>[[Call]]</code> property of <i>fn</i>, passing <i>thisArg</i> as the value for <code>this</code>
and the members of <i>args</i> as the individual argument values.

<P><span class="pcounter"></span> If <i>fn</i> does not have a <code>[[Call]]</code> property, a <b>TypeError</b> exception
is thrown.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>call</code> method returns the value returned by <i>fn</i>.

<P class="implsection"><b>Implementation</b>
<PRE>
static function call(fn, thisObj=undefined, ...args:Array):*
    Function.apply(fn, thisObj, args);
</PRE>


<h2>Methods on Function instances</h2>

<h3>meta::invoke&nbsp;(&nbsp;&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The meta method <code>invoke</code> is specialized to the individual
function object.  When called, it evaluates the executable code for
the function.

<P><span class="pcounter"></span> The meta method <code>invoke</code> is typically called by the ECMAScript
implementation as part of the function invocation and object
construction protocols.  When a function or method is invoked, the
<code>invoke</code> method of the function or method object provides the code
to run.  When a function is used to construct a new object, the
<code>invoke</code> method provides the code for the constructor function.

<P><span class="pcounter"></span> The signature of the meta method <code>invoke</code> is determined when the
<code>Function</code> instance is created, and is determined by the text that
defines the function being created.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The meta method <code>invoke</code> is <code>final</code>; therefore subclasses
can add properties and methods but can't override the function calling
behavior.

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #173.)  While it is necessary that the <code>invoke</code>
method is completely magic in <code>Function</code> instances, it's not clear
it needs to be magic for instances of subclasses of <code>Function</code>,
because these can be treated like other objects that have <code>invoke</code>
methods (and which already work just fine).  Therefore it should not
be <code>final</code>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The meta method <code>invoke</code> returns the result of evaluating the
executable code for the function represented by this <code>Function</code>
object.


<h3>intrinsic::toString&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toString</code> method converts the executable code
of the function to a string representation.  This representation has
the syntax of a <i>FunctionDeclaration</i> or <i>FunctionExpression</i>.
Note in particular that the use and placement of white space, line
terminators, and semicolons within the representation string is
implementation-dependent.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>toString</code> method returns a string.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function toString(): string
    informative::source;
</PRE>

<P><span class="pcounter"></span> The informative property <code>source</code> holds a string representation
of this function object.


<h3>intrinsic::apply&nbsp;(&nbsp;thisObj=&#x0085;,&nbsp;args=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>apply</code> method calls the static <code>apply</code> method
with the current value of <code>this</code> as the first argument.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>apply</code> method returns the result of the static
<code>apply</code> method.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function apply(thisArg=undefined, argArray=undefined)
    Function.apply(this, thisArg, argArray);
</PRE>

<h3>intrinsic::call&nbsp;(&nbsp;thisObj=&#x0085;,&nbsp;...args)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span>The intrinsic <code>call</code> method calls the static <code>apply</code> method
with the current value of <code>this</code> as the first argument.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>call</code> method returns the result of the static
<code>call</code> method.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function call(thisObj=undefined, ...args)
    Function.apply(this, thisObj, args);
</PRE>





<h2>Properties of <code>Function</code> instances</h2>

<P><span class="pcounter"></span> In addition to the required internal properties, every function
instance has a <code>[[Call]]</code> property, a <code>[[Construct]]</code> property and a
<code>[[Scope]]</code> property (see sections 8.6.2 and 13.2).


<h3>length</h3>

<P><span class="pcounter"></span> The value of the constant <code>length</code> property is the number of
non-rest arguments accepted by the function.

<P><span class="pcounter"></span> The value of the <code>length</code> property is an integer that indicates
the "typical" number of arguments expected by the function.  However,
the language permits the function to be invoked with some other number
of arguments.  The behaviour of a function when invoked on a number of
arguments other than the number specified by its length property
depends on the function.

<h3>prototype</h3>

<P><span class="pcounter"></span> The initial value of the <code>prototype</code> property is a fresh
<code>Object</code> instance.

<P><span class="pcounter"></span> The value of the <code>prototype</code> property is used to initialise the
internal <code>[[Prototype]]</code> property of a newly created object before the
<code>Function</code> instance is invoked as a constructor for that newly
created object.

<h2>Invoking the <code>Function</code> prototype object</h2>

<P><span class="pcounter"></span> When the <code>Function</code> prototype object is invoked it accepts any
arguments and returns <b>undefined</b>:

<PRE>
meta prototype function invoke(...args)
    undefined;
</PRE>


<h2>Methods on the <code>Function</code> prototype object</h2>

<P><span class="pcounter"></span> The methods on the <code>Function</code> prototype object call their
intrinsic counterparts:

<PRE>
prototype function toString()
    this.source;

prototype function apply(thisArg, argArray)
    Function.apply(this, thisArg, argArray);

prototype function call(thisObj, ...args)
    Function.apply(this, thisObj, args);
</PRE>

<P><span class="pcounter"></span> The Function prototype object does not have a <code>valueOf</code> property
of its own; however, it inherits the <code>valueOf</code> property from the
<code>Object</code> prototype object.




<H1 id="class Name"> The class <code>Name</code> </H1>

<pre>
FILE:                       spec/library/Name.html
DRAFT STATUS:               DRAFT 1 - ROUGH - 2007-09-18
REVIEWED AGAINST ES3:       N/A
REVIEWED AGAINST ERRATA:    N/A
REVIEWED AGAINST BASE DOC:  N/A
REVIEWED AGAINST PROPOSALS: NO
REVIEWED AGAINST CODE:      NO
</pre>

<P><span class="pcounter"></span> The class <code>Name</code> is a final, nullable, non-dynamic, direct
subclass of <code>String</code> that reflects a property name as a pair of
<code>Namespace</code> and <code>string</code> values.

<h2>Synopsis</h2>

<P><span class="pcounter"></span> The class <code>Name</code> provides the following interface:

<PRE>
final class Name extends String
{
    function Name(a, b=undefined) &#x0085
    meta static function invoke(a, b=undefined): Name &#x0085
    
    static const length = 2;

    override intrinsic function toString() : string &#x0085
    override intrinsic function valueOf() : string &#x0085

    const qualifier:  Namespace
    const identifier: string
}
</PRE>

<P><span class="pcounter"></span> The <code>Name</code> prototype object provides the following direct interfaces:

<PRE>
    toString: function (this:Name) &#x0085;
    valueOf:  function (this:Name) &#x0085;
</PRE>

<h2>Methods on the <code>Name</code> class object</h2>

<h3>new&nbsp;Name(&nbsp;a,&nbsp;b=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The <code>Name</code> constructor initializes a new <code>Name</code> object.
Three combinations of the two arguments <i>a</i> and <i>b</i> are allowed.
If <i>a</i> is a <code>string</code> or a <code>Name</code> then <i>b</i> must be
<b>undefined</b>.  Otherwise, if <i>a</i> is a <code>Namespace</code> then <i>b</i> must
be a <code>string</code>.

<P class="implsection"><b>Implementation</b>
<PRE>
function Name(a, b=undefined) {
    if (a is Namespace && b is string) {
        qualifier = a;
        identifier = b;
    }
    if (a is Name && b is undefined) {
        qualifier = a.qualifier;
        identifier = a.identifier;
    }
    if (a is string && b is undefined) {
        identifier = a;
    }
    throw new TypeError();
}
</PRE>

<h3>Name&nbsp;(a,&nbsp;b=&#x0085;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The <code>Name</code> class object called as a function creates a new
<code>Name</code> object by passing its arguments <i>a</i> and <i>b</i> to the
<code>Name</code> constructor.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>Name</code> class object called as a function returns a
<code>Name</code> object.

<P class="implsection"><b>Implementation</b>
<PRE>
meta static function invoke(a, b=undefined): Name
    new Name(a, b);
</PRE>


<h2>Methods on <code>Name</code> instances</h2>

<h3>intrinsic::toString&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toString</code> method converts this <code>Name</code> object
to a string.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>toString</code> method returns a string.

<P class="implsection"><b>Implementation</b>
<PRE>
override intrinsic function toString() : string {
    if (qualifier === null)
        return identifier;
    return string(qualifier) + "::" + identifier;
}
</PRE>

<h3>intrinsic::valueOf&nbsp;(&nbsp;)</h3>

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>valueOf</code> method returns what the intrinsic
<code>toString</code> method returns.

<P class="implsection"><b>Implementation</b>
<PRE>
override intrinsic function valueOf() : string
    intrinsic::toString();
</PRE>

<h2>Value properties of <code>Name</code> instances</h2>

<h3>qualifier</h3>

<P><span class="pcounter"></span> The <code>qualifier</code> property holds the namespace value for this
<code>Name</code> object.  It may be null.

<h3>identifier</h3>

<P><span class="pcounter"></span> The <code>identifier</code> property holds the identifier value for this
<code>Name</code> object.  It is never null.


<h2>Methods on the <code>Name</code> prototype object</h2>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The methods on the <code>Name</code> prototype object delegate to their
corresponding intrinsic methods.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The methods on the <code>Name</code> prototype object return what their
corresponding intrinsic methods return.

<P class="implsection"><b>Implementation</b>
<PRE>
prototype function toString(this : Name)
    this.intrinsic::toString();

prototype function valueOf(this : Name)
    this.intrinsic::valueOf();
</PRE>

 
<H1 id="class Namespace"> The class <code>Namespace</code> </H1>

<pre>
FILE:                       spec/library/Namespace.html
DRAFT STATUS:               DRAFT 1 - ROUGH - 2007-09-19
REVIEWED AGAINST ES3:       N/A
REVIEWED AGAINST ERRATA:    N/A
REVIEWED AGAINST BASE DOC:  NO
REVIEWED AGAINST PROPOSALS: NO
REVIEWED AGAINST CODE:      NO
</pre>

<P><span class="pcounter"></span> The class <code>Namespace</code> is a final, nullable, non-dynamic, direct
subclass of <code>Object</code>.  It represents objects that are created by the
evaluation of the <code>namespace</code> pragma.

<h2>Synopsis</h2>

<P><span class="pcounter"></span> The class <code>Namespace</code> provides the following interface:

<PRE>
final class Namespace
{
    intrinsic function toString();
}
</PRE>

<P><span class="pcounter"></span> The <code>Namespace</code> prototype object provides the following direct
properties:

<PRE>
    toString: function () &#x0085;
</PRE>

<h2>Methods on the <code>Namespace</code> class object</h2>

<P><span class="pcounter"></span> There are no methods on the <code>Namespace</code> class object.  In
particular, the class <code>Namespace</code> does not have a publicly
accessible constructor.

<h2>Methods on <code>Namespace</code> instances</h2>

<h3>intrinsic::toString()</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toString</code> method converts the <code>Namespace</code>
object to a string.  If the <code>Namespace</code> object was created with an
explicit name then the string contains that name as a substring.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>toString</code> method returns an implementation-defined string.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span> The <code>toString</code> method is implementation-defined.


<h2>Methods on the <code>Namespace</code> prototype object</h2>

=== toString() ==

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>toString</code> method returns what the intrinsic <code>toString</code>
method returns.

<P class="implsection"><b>Implementation</b>
<PRE>
prototype function toString(this:Namespace)
    this.intrinsic::toString()
</PRE>
 


<H1 id="class Array"> The class <code>Array</code> </H1>

<pre>
FILE:                       spec/library/Array.html
DRAFT STATUS:               DRAFT 1 - ROUGH - 2007-09-20
REVIEWED AGAINST ES3:       NO
REVIEWED AGAINST ERRATA:    NO
REVIEWED AGAINST BASE DOC:  NO
REVIEWED AGAINST PROPOSALS: NO
REVIEWED AGAINST CODE:      NO
</pre>

<P><span class="pcounter"></span> The class <code>Object</code> is a dynamic non-final subclass of <code>Object</code>
(see <span class="xref">class Object</span>).

<P><span class="pcounter"></span> Array objects give special treatment to a certain class of
property names.  A property name that can be interpreted as an
unsigned integer less than 2<sup>32</sup>-1 is an <i>array index</i>.

<P><span class="pcounter"></span> A property name <i>P</i> (in the form of a string value) is an array
index if and only if <i>string(uint(P))</i> is equal to <i>P</i> and
<i>uint(P)</i> is not equal to 2<sup>32</sup>-1.

<P><span class="pcounter"></span> Every <code>Array</code> object has a <code>length</code> property whose value is
always a nonnegative integer less than 2<sup>32</sup>.  The value of
the <code>length</code> property is numerically greater than the name of every
property whose name is an array index; whenever a property of an Array
object is created or changed, other properties are adjusted as
necessary to maintain this invariant.  Specifically, whenever a
property is added whose name is an array index, the <code>length</code>
property is changed, if necessary, to be one more than the numeric
value of that array index; and whenever the <code>length</code> property is
changed, every property whose name is an array index whose value is
not smaller than the new length is automatically deleted.  This
constraint applies only to properties of the Array object itself and
is unaffected by <code>length</code> or array index properties that may be
inherited from its prototype.

<P><span class="pcounter"></span> The set of <i>array elements</i> held by any object (not just
<code>Array</code> objects) are those properties of the object that are named
by array indices numerically less than the object's <code>length</code>
property.  (If the object has no <code>length</code> property then its value is
assumed to be zero, and the object has no array elements.)

<h2>Synopsis</h2>

<P><span class="pcounter"></span>The Array class provides the following interface:

<PRE>
dynamic class Array extends Object
{
    function Array(...args) &#x0085;
    meta static function invoke(...items) &#x0085

    static function concat(object/*: Object!*/, ...items): Array &#x0085
    static function every(object/*:Object!*/, checker/*:function*/, thisObj:Object=null)
        : boolean &#x0085 
    static function filter(object/*:Object!*/, checker/*function*/, thisObj:Object=null)
        : Array &#x0085
    static function forEach(object/*:Object!*/, eacher/*function*/, thisObj:Object=null)
        : void &#x0085
    static function indexOf(object/*:Object!*/, value, from:AnyNumber=0): AnyNumber &#x0085
    static function join(object/*: Object!*/, separator: string=","): string &#x0085
    static function lastIndexOf(object/*:Object!*/, value, from:AnyNumber=NaN)
        : AnyNumber &#x0085
    static function map(object/*:Object!*/, mapper/*:function*/, thisObj:Object=null)
        : Array &#x0085
    static function pop(object/*:Object!*/) &#x0085
    static function push(object/*: Object!*/, ...args): uint &#x0085
    static function reverse(object/*: Object!*/)/*: Object!*/ &#x0085
    static function shift(object/*: Object!*/) &#x0085
    static function slice(object/*: Object!*/, start: AnyNumber=0, end: AnyNumber=Infinity) &#x0085
    static function some(object/*:Object!*/, checker/*:function*/, thisObj:Object=null)
        : boolean &#x0085
    static function sort(object/*: Object!*/, comparefn) &#x0085
    static function splice(object/*: Object!*/, start: AnyNumber, deleteCount: AnyNumber, ...items)
        : Array &#x0085
    static function unshift(object/*: Object!*/, ...items) : uint &#x0085

    static const length = 1

    override intrinsic function toString():string &#x0085
    override intrinsic function toLocaleString():string &#x0085
    override intrinsic function toJSONString(pretty: boolean=false): string &#x0085
    intrinsic function concat(...items): Array &#x0085
    intrinsic function every(checker:Checker, thisObj:Object=null): boolean &#x0085
    intrinsic function filter(checker:Checker, thisObj:Object=null): Array &#x0085
    intrinsic function forEach(eacher:Eacher, thisObj:Object=null): void &#x0085
    intrinsic function indexOf(value, from:AnyNumber=0): AnyNumber &#x0085
    intrinsic function join(separator: string=","): string &#x0085
    intrinsic function lastIndexOf(value, from:AnyNumber=NaN): AnyNumber &#x0085
    intrinsic function map(mapper:Mapper, thisObj:Object=null): Array &#x0085
    intrinsic function pop() &#x0085
    intrinsic function push(...args): uint &#x0085
    intrinsic function reverse()/*: Object!*/ &#x0085
    intrinsic function shift() &#x0085
    intrinsic function slice(start: AnyNumber=0, end: AnyNumber=Infinity): Array &#x0085
    intrinsic function some(checker:Checker, thisObj:Object=null): boolean &#x0085
    intrinsic function sort(comparefn:Comparator):Array &#x0085
    intrinsic function splice(start: AnyNumber, deleteCount: AnyNumber, ...items)
        : Array &#x0085
    intrinsic function unshift(...items): uint &#x0085

    function get length(): uint &#x0085;
    function set length(len: uint): void &#x0085;
}
</PRE>

<P><span class="pcounter"></span> The <code>Array</code> prototype object provides these direct properties:

<PRE>
   toString:       function () &#x0085; ,
   toLocaleString: function () &#x0085; ,
   toJSONString:   function (pretty=false) &#x0085; ,
   concat:         function (...items) &#x0085; ,
   every:          function (checker, thisObj=null) &#x0085; ,
   filter:         function (checker, thisObj=null) &#x0085; ,
   forEach:        function (eacher, thisObj=null) &#x0085; ,
   indexOf:        function (value, from=0) &#x0085; ,
   join:           function (separator=",") &#x0085; ,
   lastIndexOf:    function (value, from=Infinity) &#x0085; ,
   map:            function (mapper, thisObj=null) &#x0085; ,
   pop:            function () &#x0085; ,
   push:           function (...items) &#x0085; ,
   reverse:        function () &#x0085; ,
   shift:          function () &#x0085; ,
   slice:          function (start=0, end=Infinity) &#x0085; ,
   some:           function (checker, thisObj=null) &#x0085; ,
   sort:           function (comparefn=undefined) &#x0085; ,
   splice:         function (start, deleteCount, ...items) &#x0085; ,
   unshift:        function (...items) &#x0085; ,
   length:         &#x0085;
</PRE>


<h2>Methods on the <code>Array</code> class object</h2>

<P><span class="pcounter"></span> The <code>Array</code> class provides a number of static methods for
manipulating array elements: <code>concat</code>, <code>every</code>, <code>filter</code>,
<code>forEach</code>, <code>indexOf</code>, <code>join</code>, <code>lastIndexOf</code>, <code>map</code>, <code>pop</code>,
<code>push</code>, <code>reverse</code>, <code>shift</code>, <code>slice</code>, <code>some</code>, <code>sort</code>,
<code>splice</code>, and <code>unshift</code>.  These static methods are intentionally
<i>generic</i>; they do not require that their <i>object</i> argument
be an <code>Array</code> object.  Therefore they can be applied to other kinds
of objects as well.  Whether the generic Array methods can be applied
successfully to a host object is implementation-dependent.

<p class="note"><b>COMPATIBILITY NOTE</b>&nbsp;&nbsp; The static generic methods on the Array class are all new in 4th
edition.


<h3>new&nbsp;Array&nbsp;(&nbsp;...items&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> When the <code>Array</code> constructor is called with some set of
arguments <i>items</i> as part of a <code>new&nbsp;Array</code> expression, it
initializes the <code>Array</code> object from its argument values.

<P><span class="pcounter"></span> If there is exactly one argument of any number type, then its
value is taken to be the initial value of the <code>length</code> property.
The value must be a nonnegative integer less than 2<sup>32</sup>.

<P><span class="pcounter"></span> If there are zero or more than one arguments, the arguments are
taken to be the initial values of array elements, and there will be
as many elements as there are arguments.

<P class="implsection"><b>Implementation</b>
<PRE>
function Array(...items) {
    if (items.length === 1) {
        let item = items[0];
        if (item is AnyNumber) {
            if (uint(item) === item)
                this.length = uint(item);
            else
                throw new RangeError("Invalid array length");
        }
        else {
            this.length = 1;
            this[0] = item;
        }
    }
    else {
        this.length = items.length;
        for ( let i=0, limit=items.length ; i &#60; limit ; i++ )
            this[i] = items[i];
    }
}
</PRE>


<h3>Array&nbsp;(&nbsp;...items&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> When <code>Array</code> class is called as a function rather than as a
constructor, it creates and initialises a new <code>Array</code> object.  Thus
the function call <code>Array(&#x0085;)</code> is equivalent to the object
creation expression new <code>Array(&#x0085;)</code> with the same arguments.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>Array</code> class called as function returns a new <code>Array</code> object.

<P class="implsection"><b>Implementation</b>
<PRE>
meta static function invoke(...items) {
    if (items.length == 1)
        return new Array(items[0]);
    else
        return items;
}
</PRE>


<h3>concat&nbsp;(&nbsp;object,&nbsp;...items&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>concat</code> method collects the array elements from
<i>object</i> followed by the array elements from the additional
<i>items</i>, in order, into a new Array object.  All the <i>items</i> must
be objects.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>concat</code> method returns a new <code>Array</code> object.

<P class="implsection"><b>Implementation</b>
<PRE>
static function concat(object/*: Object!*/, ...items): Array
    helper::concat(object, items);

helper static function concat(object/*: Object!*/, items: Array): Array {
    let out = new Array;

    let function emit(x) {
        if (x is Array) {
            for (let i=0, limit=x.length ; i &#60; limit ; i++)
                out[out.length] = x[i];
        }
        else
            out[out.length] = x;
    }

    emit( object );
    for (let i=0, limit=items.length ; i &#60; limit ; i++)
        emit( items[i] );

    return out;
}
</PRE>

<P><span class="pcounter"></span>The helper <code>concat</code> method is also used by the intrinsic and
prototype variants of <code>concat</code>.


<h3>every&nbsp;(&nbsp;object,&nbsp;checker,&nbsp;thisObj=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>every</code> method calls <i>checker</i> on every array
element of <i>object</i> in increasing numerical index order, stopping as
soon as any call returns <b>false</b>.

<P><span class="pcounter"></span><i>Checker</i> is called with three arguments: the property value, the
property index, and <i>object</i> itself.  The <i>thisObj</i> is used as the
<code>this</code> object in the call.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>every</code> method returns <b>true</b> if all the calls to
<i>checker</i> returned true values, otherwise it returns <b>false</b>.

<P class="implsection"><b>Implementation</b>
<PRE>
static function every(object/*:Object!*/, checker/*:function*/, thisObj:Object=null): boolean {

    if (typeof checker != "function")
        throw new TypeError("Function object required to 'every'");

    for (let i=0, limit=object.length ; i &#60; limit ; i++) {
        if (i in object)
            if (!checker.call(thisObj, object[i], i, object))
                return false;
    }
    return true;
}
</PRE>


<h3>filter&nbsp;(&nbsp;object,&nbsp;checker,&nbsp;thisObj=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>filter</code> method calls <i>checker</i> on every array element
of <i>object</i> in increasing numerical index order, collecting all the
array elements for which checker returns a true value.

<P><span class="pcounter"></span> <i>Checker</i> is called with three arguments: the property value, the
property index, and <i>object</i> itself.  The <i>thisObj</i> is used as the
<code>this</code> object in the call.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>filter</code> method returns a new <code>Array</code> object
containing the elements that were collected, in the order they were
collected.

<P class="implsection"><b>Implementation</b>
<PRE>
static function filter(object/*:Object!*/, checker/*function*/, thisObj:Object=null): Array {

    if (typeof checker != "function")
        throw new TypeError("Function object required to 'filter'");

    let result = [];
    for (let i = 0, limit=object.length ; i &#60; limit ; i++) {
        if (i in object) {
            let item = object[i];
            if (checker.call(thisObj, item, i, object))
                result[result.length] = item;
        }
    }
    return result;
}
</PRE>


<h3>forEach&nbsp;(&nbsp;object,&nbsp;eacher,&nbsp;thisObj=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>forEach</code> method calls <i>eacher</i> on every array
element of <i>object</i> in increasing numerical index order, discarding
any return value of <i>eacher</i>.

<P><span class="pcounter"></span> <i>Eacher</i> is called with three arguments: the property value, the
property index, and <i>object</i> itself.  The <i>thisObj</i> is used as the
<code>this</code> object in the call.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>forEach</code> method does not return a value.

<P class="implsection"><b>Implementation</b>
<PRE>
static function forEach(object/*:Object!*/, eacher/*function*/, thisObj:Object=null): void {

    if (typeof eacher != "function")
        throw new TypeError("Function object required to 'forEach'");

    for (let i=0, limit = object.length ; i &#60; limit ; i++)
        if (i in object)
            eacher.call(thisObj, object[i], i, object);
}
</PRE>


<h3>indexOf&nbsp;(&nbsp;object,&nbsp;value,&nbsp;from=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>indexOf</code> method compares <i>value</i> with every
array element of <i>object</i> in increasing numerical index order,
starting at the index <i>from</i>, stopping when an array element is
equal to <i>value</i> by the <code>===</code> operator.

<P><span class="pcounter"></span> <i>From</i> is rounded toward zero before use.  If <i>from</i> is
negative, it is treated as <code><i>object</i>.length+<i>from</i></code>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>indexOf</code> method returns the array index the first
time <i>value</i> is equal to an element, or -1 if no such element is
found.

<P class="implsection"><b>Implementation</b>
<PRE>
static function indexOf(object/*:Object!*/, value, from:AnyNumber=0): AnyNumber {
    let len = object.length;

    from = from &#60; 0 ? Math.ceil(from) : Math.floor(from);
    if (from &#60; 0)
        from = from + len;

    while (from &#60; len) {
        if (from in object)
            if (value === object[from])
                return from;
        from = from + 1;
    }
    return -1;
}
</PRE>


<h3>join&nbsp;(&nbsp;object,&nbsp;separator=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>join</code> method concatenates the string
representations of the array elements of <i>object</i> in increasing
numerical index order, separating the individual strings by
occurrences of <i>separator</i>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>join</code> method returns the complete concatenated
string.

<P class="implsection"><b>Implementation</b>
<PRE>
static function join(object/*: Object!*/, separator: string=","): string {
    let out = "";

    for (let i=0, limit=uint(object.length) ; i &#60; limit ; i++) {
        if (i > 0)
            out += separator;
        let x = object[i];
        if (x !== undefined && x !== null)
            out += string(x);
    }

    return out;
}
</PRE>


<h3>lastIndexOf&nbsp;(&nbsp;object,&nbsp;value,&nbsp;from=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>lastIndexOf</code> method compares <i>value</i> with every
array element of <i>object</i> in decreasing numerical index order,
starting at the index <i>from</i>, stopping when an array element is
equal to <i>value</i> by the <code>===</code> operator.

<P><span class="pcounter"></span> <i>From</i> is rounded toward zero before use.  If <i>from</i> is
negative, it is treated as <code><i>object</i>.length+<i>from</i></code>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>lastIndexOf</code> method returns the array index the
first time <i>value</i> is equal to an element, or -1 if no such element
is found.

<P class="implsection"><b>Implementation</b>
<PRE>
static function lastIndexOf(object/*:Object!*/, value, from:AnyNumber=NaN): AnyNumber {
    let len = object.length;

    if (isNaN(from))
        from = len - 1;
    else {
        from = from &#60; 0 ? Math.ceil(from) : Math.floor(from);
        if (from &#60; 0)
            from = from + len;
        else if (from >= len)
            from = len - 1;
    }

    while (from > -1) {
        if (from in object)
            if (value === object[from])
                return from;
        from = from - 1;
    }
    return -1;
}
</PRE>


<h3>map&nbsp;(&nbsp;object,&nbsp;mapper,&nbsp;thisObj=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>map</code> method calls <i>mapper</i> on each array element of
<i>object</i> in increasing numerical index order, collecting the return values
from <i>mapper</i> in a new <code>Array</code> object.

<P><span class="pcounter"></span><i>Mapper</i> is called with three arguments: the property value, the
property index, and <i>object</i> itself.  The <i>thisObj</i> is used as the
<code>this</code> object in the call.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>map</code> method returns a new <code>Array</code> object where
the array element at index <i>i</i> is the value returned from the call
to <i>mapper</i> on <i>object[i]</i>.

<P class="implsection"><b>Implementation</b>
<PRE>
static function map(object/*:Object!*/, mapper/*:function*/, thisObj:Object=null): Array {

    if (typeof mapper != "function")
        throw new TypeError("Function object required to 'map'");

    let result = [];
    for (let i = 0, limit = object.length; i &#60; limit ; i++)
        if (i in object)
            result[i] = mapper.call(thisObj, object[i], i, object);
    return result;
}
</PRE>


<h3>pop&nbsp;(&nbsp;object&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>pop</code> method extracts the last array element from
<i>object</i> and removes it by decreasing the value of the <code>length</code>
property of <i>object</i> by 1.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>pop</code> method returns the removed element.

<P class="implsection"><b>Implementation</b>
<PRE>
static function pop(object/*:Object!*/) {
    let len = uint(object.length);

    if (len != 0) {
        len = len - 1;
        let x = object[len];
        delete object[len]
        object.length = len;
        return x;
    }
    else {
        object.length = len;
        return undefined;
    }
}
</PRE>


<h3>push&nbsp;(&nbsp;object,&nbsp;...items&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>push</code> method appends the values in <i>items</i> to
the end of the array elements of <i>object</i>, in the order in which
they appear, in the process updating the <code>length</code> property of <i>object</i>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>push</code> method returns the new value of the
<code>length</code> property of <i>object</i>.

<P class="implsection"><b>Implementation</b>
<PRE>
static function push(object/*: Object!*/, ...args): uint
    Array.helper::push(object, args);

helper static function push(object/*:Object!*/, args: Array): uint {
    let len = uint(object.length);

    for (let i=0, limit=args.length ; i &#60; limit ; i++)
        object[len++] = args[i];

    object.length = len;
    return len;
}
</PRE>

<P><span class="pcounter"></span>The helper <code>push</code> method is also used by the intrinsic and
prototype variants of <code>push</code>.


<h3>reverse&nbsp;(&nbsp;object&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>reverse</code> method rearranges the array elements of
<i>object</i> so as to reverse their order.  The <code>length</code> property of
<i>object</i> remains unchanged.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>reverse</code> method returns <i>object</i>.

<P class="implsection"><b>Implementation</b>
<PRE>
static function reverse(object/*: Object!*/)/*: Object!*/ {
    let len = uint(object.length);
    let middle = Math.floor(len / 2);

    for ( let k=0 ; k &#60; middle ; ++k ) {
        let j = len - k - 1;
        if (j in object) {
            if (k in object)
                [object[k], object[j]] = [object[j], object[k]];
            else {
                object[k] = object[j];
                delete object[j];
            }
        }
        else if (k in object) {
            object[j] = object[k];
            delete object[k];
        }
        else {
            delete object[j];
            delete object[k];
        }
    }

    return object;
}
</PRE>


<h3>shift&nbsp;(&nbsp;object&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>shift</code> method removes the element called <code>0</code> in
<i>object</i>, moves the element at index <i>i+1</i> to index <i>i</i>, and
decrements the <code>length</code> property of <i>object</i> by 1.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>shift</code> method returns the element that was removed.

<P class="implsection"><b>Implementation</b>
<PRE>
static function shift(object/*: Object!*/) {
    let len = uint(object.length);
    if (len == 0) {
        object.length = 0;
        return undefined;
    }

    let x = object[0];

    for (let i = 1; i &#60; len; i++)
        object[i-1] = object[i];
    delete object[len - 1];
    object.length = len - 1;
    return x;
}
</PRE>


<h3>slice&nbsp;(&nbsp;object,&nbsp;start=&#x0085;,&nbsp;end=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>slice</code> method extracts the subrange of array
elements from <i>object</i> between <i>start</i> (inclusive) and <i>end</i>
(exclusive) into a new Array.

<P><span class="pcounter"></span> If <i>start</i> is negative, it is treated as
<code><i>object</i>.length+<i>start</i></code>.  If <i>end</i> is negative, it is
treated as <code><i>object</i>.length+<i>end</i></code>.  In either case the values
of <i>start</i> and <i>end</i> are bounded between 0 and
<code><i>object</i>.length</code>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>slice</code> method returns a new <code>Array</code> object
containing the extracted array elements.

<P class="implsection"><b>Implementation</b>
<PRE>
static function slice(object/*: Object!*/, start: AnyNumber=0, end: AnyNumber=Infinity) {
    let len = uint(object.length);

    let a = helper::clamp( start, len);
    let b = helper::clamp( end, len);
    if (b &#60; a)
        b = a;

    let out = new Array;
    for (let i = a; i &#60; b; i++)
        out.push(object[i]);

    return out;
}

helper function clamp(val: AnyNumber, len: uint): uint {
    val = helper::toInteger(val);
    if (val &#60; 0)
        val += len;
    return uint( Math.min( Math.max( val, 0 ), len ) );
}
</PRE>


<h3>some&nbsp;(&nbsp;object,&nbsp;checker,&nbsp;thisObj=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>some</code> method calls <i>checker</i> on every array element in
<i>object</i> in increasing numerical index order, stopping as soon as <i>checker</i> returns
a true value.

<P><span class="pcounter"></span><i>Checker</i> is called with three arguments: the property value, the
property index, and the object itself.  The <i>thisObj</i> is used as the
<code>this</code> object in the call.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>some</code> method returns <b>true</b> when <i>checker</i>
returns a true value, otherwise returns <b>false</b> if all the calls to
<i>checker</i> return false values.

<P class="implsection"><b>Implementation</b>
<PRE>
static function some(object/*:Object!*/, checker/*:function*/, thisObj:Object=null): boolean {

    if (typeof checker != "function")
        throw new TypeError("Function object required to 'some'");

    for (let i=0, limit=object.length; i &#60; limit ; i++) {
        if (i in object)
            if (checker.call(thisObj, object[i], i, object))
                return true;
    }
    return false;
}
</PRE>


<h3>sort&nbsp;(object,&nbsp;comparefn=&#x0085;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>sort</code> method sorts the array elements of
<i>object</i>, it rearranges the elements of <i>object</i> according to some
criterion.

<P><span class="pcounter"></span>The sort is not necessarily stable (that is, elements that compare
equal do not necessarily remain in their original order).  If
<i>comparefn</i> is not <b>undefined</b>, it should be a function that
accepts two arguments <i>x</i> and <i>y</i> and returns a negative value if
<i>x < y</i>, zero if <i>x = y</i>, or a positive value if <i>x > y</i>.

<P><span class="pcounter"></span>If <i>comparefn</i> is not <b>undefined</b> and is not a consistent
comparison function for the array elements of <i>object</i> (see <span class="xref">sorting-logic</span>),
the behaviour of <code>sort</code> is implementation-defined.  Let <i>len</i> be
<code>uint(object.length)</code>.  If there exist integers <i>i</i> and <i>j</i>
and an object <i>P</i> such that all of the conditions below are
satisfied then the behaviour of <code>sort</code> is implementation-defined:

<ol>
<li> <i>0 &#x2264; i < len</i>
<li> <i>0 &#x2264; j < len</i>
<li> <i>object</i> does not have a property with name <code>string(<i>i</i>)</code>
<li> <i>P</i> is obtained by following one or more <code>[[Prototype]]</code> properties starting at this
<li> <i>P</i> has a property with name <code>string(<i>j</i>)</code>
</ol>

<P><span class="pcounter"></span> If the behavior of <code>sort</code> is not implementation-defined then
the array is sorted as described in section <span class="xref">sorting-logic</span>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>sort</code> method returns <i>object</i>.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span>
The static <code>sort</code> method calls on the generic sorting engine,
passing a function to compare elements of <i>object</i>.

<PRE>
static function sort(object/*: Object!*/, comparefn) {

    function compare(j, k) {
        if (!(j in object) && !(k in object))
            return 0;
        if (!(j in object))
            return 1;
        if (!(k in object))
            return -1;

        let x = object[j];
        let y = object[k];

        if (x === undefined && y === undefined)
            return 0;
        if (x === undefined)
            return 1;
        if (y === undefined)
            return -1;

        if (comparefn !== undefined)
            return comparefn(x, y);

        x = x.toString();
        y = y.toString();
        if (x &#60; y) return -1;
        if (x > y) return 1;
        return 0;
    }

    let len = uint(object.length);
    if (len > 0)
        informative::sortEngine(object, 0, len-1, compare);
    return object;
}
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  Because non-existent property values always compare greater
than <b>undefined</b> property values, and <b>undefined</b> always compares
greater than any other value, <b>undefined</b> property values always
sort to the end of the result, followed by non-existent property
values.

<h4 id="sorting-logic"> The sorting engine </h4>

<P><span class="pcounter"></span> The sorting engine sorts the numerically named properties of an
object between two indices <code>low</code> and <code>high</code> inclusive, using a
sort-specific function <code>sortCompare</code> to compare elements at two
indices:

<PRE>
informative function sortEngine(object, low, high, sortCompare) &#x0085;
</PRE>

<P><span class="pcounter"></span> The sorting engine perform an implementation-dependent sequence of
calls to the <code>[[Get]]</code>, <code>[[Put]]</code>, and <code>[[Delete]]</code> methods of <i>object</i>
and to <i>sortCompare</i>, where the first argument for each call to
<code>[[Get]]</code>, <code>[[Put]]</code>, or <code>[[Delete]]</code>, and both arguments to
<i>sortCompare</i>, are nonnegative integers greater than or equal to
<i>low</i> and less than or equal to <i>high</i>.

</OL>

<P><span class="pcounter"></span>Following the execution of the preceding algorithm, <i>object</i> must
have the following two properties.

<ol>
  <li> There must be some mathematical permutation &#x03C0; of the
nonnegative integers in the range <i>low</i> to <i>high</i> inclusive, such that for every nonnegative
integer <i>j</i> in that range, if property <i>old[j]</i> existed, then
<i>new[&#x03C0;(j)]</i> is exactly the same value as <i>old[j]</i>, but if
property <i>old[j]</i> did not exist, then <i>new[&#x03C0;(j)]</i> does not
exist.

  <li> Then for all nonnegative integers <i>j</i> and <i>k</i> in that
range, if <i>sortCompare(j,k) &lt; 0</i>, then <i>&#x03C0;(j) &lt; &#x03C0;(k)</i>.
</ol>

<P><span class="pcounter"></span>Here the notation <i>old[j]</i> is used to refer to the hypothetical
result of calling the <code>[[Get]]</code> method of this object with argument
<i>j</i> before this function is executed, and the notation <i>new[j]</i> to
refer to the hypothetical result of calling the <code>[[Get]]</code> method of this
object with argument <i>j</i> after this function has been executed.

<P><span class="pcounter"></span>A function <i>comparefn</i> is a consistent comparison function for a
set of values <i>S</i> if all of the requirements below are met for all
values <i>a</i>, <i>b</i>, and <i>c</i> (possibly the same value) in the set
<i>S</i>: The notation <i>a &lt;CF b</i> means <i>comparefn(a,b) < 0</i>;
<i>a =CF b</i> means <i>comparefn(a,b) = 0</i> (of either sign); and <i>a >CF b</i>
means <i>comparefn(a,b) > 0</i>.

<OL>

<LI> Calling <i>comparefn(a,b)</i> always returns the same value <i>v</i>
when given a specific pair of values <i>a</i> and <i>b</i> as its two
arguments. Furthermore, <i>v</i> has type <i>Number</i>, and <i>v</i> is not
<b>NaN</b>. Note that this implies that exactly one of <i>a &lt;CF b</i>,
<i>a =CF b</i>, and <i>a >CF b</i> will be true for a given pair of <i>a</i>
and <i>b</i>.

<LI> <i>a =CF a</i> (reflexivity)

<LI> If <i>a =CF b</i>, then <i>b =CF a</i> (symmetry)

<LI> If <i>a =CF b</i> and <i>b =CF c</i>, then <i>a =CF c</i> (transitivity of <i>=CF</i>)

<LI> If <i>a &lt;CF b</i> and <i>b &lt;CF c</i>, then <i>a &lt;CF c</i> (transitivity of <i>&lt;CF</i>)

<LI> If <i>a >CF b</i> and <i>b >CF c</i>, then <i>a >CF c</i> (transitivity of <i>>CF</i>)

</OL>

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The above conditions are necessary and sufficient to ensure
that <i>comparefn</i> divides the set <i>S</i> into equivalence classes and
that these equivalence classes are totally ordered.


<h3>splice&nbsp;(&nbsp;object,&nbsp;start,&nbsp;deleteCount,&nbsp;...items&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>splice</code> method replaces the <i>deleteCount</i> array
elements of <i>object</i> starting at array index <i>start</i> with values
from the <i>items</i>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>splice</code> method returns a new Array object
containing the array elements that were removed from <i>objects</i>, in
order.

<P class="implsection"><b>Implementation</b>
<PRE>
static function splice(object/*: Object!*/, start: AnyNumber, deleteCount: AnyNumber, ...items): Array
    Array.helper::splice(object, start, deleteCount, items);

helper static function splice(object/*: Object!*/, start: AnyNumber, deleteCount: AnyNumber, items: Array) {
    let out = new Array();
    let len = uint(object.length);

    start = helper::clamp( start, len );
    deleteCount = helper::clamp( deleteCount, len - start );

    let end = start + deleteCount;

    for (let i = 0; i &#60; deleteCount; i++)
        out.push(object[i + start]);

    let insertCount = items.length;
    let shiftAmount = insertCount - deleteCount;

    if (shiftAmount &#60; 0) {
        shiftAmount = -shiftAmount;

        for (let i = end; i &#60; len; i++)
            object[i - shiftAmount] = object[i];

        for (let i = len - shiftAmount; i &#60; len; i++)
            delete object[i];
    }
    else {
        for (let i = len; i > end; ) {
            --i;
            object[i + shiftAmount] = object[i];
        }
    }

    for (let i = 0; i &#60; insertCount; i++)
        object[start+i] = items[i];

    object.length = len + shiftAmount;
    return out;
}
</PRE>

<P><span class="pcounter"></span>The helper <code>clamp</code> function was defined earlier (see <span class="xref">Array.slice</span>).


<h3>unshift&nbsp;(&nbsp;object,&nbsp;...items&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>unshift</code> method inserts the values in <i>items</i>
as new array elements at the start of <i>object</i>, such that their
order within the array elements of <i>object</i> is the same as the order
in which they appear in <i>items</i>.  Existing array elements in
<i>object</i> are shifted upward in the index range, and the <code>length</code>
property of <i>object</i> is updated.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>unshift</code> method returns the new value of the
<code>length</code> property of <i>object</i>.

<P class="implsection"><b>Implementation</b>
<PRE>
static function unshift(object/*: Object!*/, ...items) : uint
    Array.helper::unshift(this, object, items);

helper static function unshift(object/*: Object!*/, items: Array) : uint {
    let len = uint(object.length);
    let numitems = items.length;

    for ( let k=len-1 ; k >= 0 ; --k ) {
        let d = k + numitems;
        if (k in object)
            object[d] = object[k];
        else
            delete object[d];
    }

    for (let i=0; i &#60; numitems; i++)
        object[i] = items[i];

    object.length = len+numitems;

    return len+numitems;
}
</PRE>

<h2>Method Properties of Array Instances</h2>

<h3>Intrinsic methods</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic methods on Array instances delegate to their static
counterparts.  Unlike their static and prototype counterparts, these
methods are bound by their instance and they are not generic.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic methods on Array instances return what their static
counterparts return.

<P class="implsection"><b>Implementation</b>
<PRE>
override intrinsic function toString():string
    join();

override intrinsic function toLocaleString():string {
    let out = "";
    for (let i = 0, limit = this.length; i &#60; limit ; i++) {
        if (i > 0)
            out += ",";
        let x = this[i];
        if (x !== null && x !== undefined)
            out += x.toLocaleString();
    }
    return out;
}

override intrinsic function toJSONString(pretty: boolean=false): string
    JSON.formatArray(this, pretty);

intrinsic function concat(...items): Array
    Array.helper::concat(this, items);

intrinsic function every(checker:Checker, thisObj:Object=null): boolean
    Array.every(this, checker, thisObj);

intrinsic function filter(checker:Checker, thisObj:Object=null): Array
    Array.filter(this, checker, thisObj);

intrinsic function forEach(eacher:Eacher, thisObj:Object=null): void {
    Array.forEach(this, eacher, thisObj);
}

intrinsic function indexOf(value, from:AnyNumber=0): AnyNumber
    Array.indexOf(this, value, from);

intrinsic function join(separator: string=","): string
    Array.join(this, separator);

intrinsic function lastIndexOf(value, from:AnyNumber=NaN): AnyNumber
    Array.lastIndexOf(this, value, from);

intrinsic function map(mapper:Mapper, thisObj:Object=null): Array
    Array.map(this, mapper, thisObj);

intrinsic function pop()
    Array.pop(this);

intrinsic function push(...args): uint
    Array.helper::push(this, args);

intrinsic function reverse()/*: Object!*/
    Array.reverse(this);

intrinsic function shift()
    Array.shift(this);

intrinsic function slice(start: AnyNumber=0, end: AnyNumber=Infinity): Array
    Array.slice(this, start, end);

intrinsic function some(checker:Checker, thisObj:Object=null): boolean
    Array.some(this, checker, thisObj);

intrinsic function sort(comparefn:Comparator):Array
    Array.sort(this, comparefn);

intrinsic function splice(start: AnyNumber, deleteCount: AnyNumber, ...items): Array
    Array.helper::splice(this, start, deleteCount, items);

intrinsic function unshift(...items): uint
    Array.helper::unshift(this, items);
</PRE>

<h3>[[Put]]&nbsp;(P,&nbsp;V)</h3>

<P><span class="pcounter"></span>Array objects use a variation of the <code>[[Put]]</code> method used for other
native ECMAScript objects (section 8.6.2.2).

<P><span class="pcounter"></span>Assume A is an Array object and P is a string.

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp; P may be not-a-string in ES4.

<P><span class="pcounter"></span>When the <code>[[Put]]</code> method of A is called with property P and value V, the following steps are taken:

<OL>
<LI> Call the <code>[[CanPut]]</code> method of A with name P.
<LI> If Result(1) is false, return.
<LI> If A doesn't have a property with name P, go to step 7.
<LI> If P is "length", go to step 12.
<LI> Set the value of property P of A to V.
<LI> Go to step 8.
<LI> Create a property with name P, set its value to V and give it empty attributes.
<LI> If P is not an array index, return.
<LI> If uint(P) is less than the value of the length property of A, then return.
<LI> Change (or set) the value of the length property of A to uint(P)+1.
<LI> Return.
<LI> Compute uint(V).
<LI> If Result(12) is not equal to Number(V), throw a RangeError exception.
<LI> For every integer k that is less than the value of the length property of A but not less than Result(12), if A
itself has a property (not an inherited property) named string(k), then delete that property.
<LI> Set the value of property P of A to Result(12).
<LI> Return.
</OL>


<h2>Value properties of Array instances</h2>

<P><span class="pcounter"></span>Array instances inherit properties from the Array prototype object
and also have the following properties.

<h3>length</h3>

<P><span class="pcounter"></span>The <code>length</code> property of this Array object is always numerically
greater than the name of every property whose name is an array index.


<h2>Method properties on the <code>Array</code> prototype object</h2>

<h3>toString&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The prototype <code>toString</code> method converts the array to a <code>string</code>.
It has the same effect as if the intrinsic <code>join</code> method were invoked for this
object with no argument.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The prototype <code>toString</code> method returns a <code>string</code>.

<P class="implsection"><b>Implementation</b>
<PRE>
prototype function toString(this:Array)
    this.join();
</PRE>

<h3>toLocaleString&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span>The elements of this Array are converted to strings using their
public <code>toLocaleString</code> methods, and these strings are then concatenated,
separated by occurrences of a separator string that has been derived
in an implementation-defined locale-specific way.  The result of
calling this function is intended to be analogous to the result of
<code>toString</code>, except that the result of this function is intended to
be locale-specific.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The prototype <code>toLocaleString</code> method returns a <code>string</code>.

<P class="implsection"><b>Implementation</b>
<PRE>
prototype function toLocaleString(this:Array)
    this.toLocaleString();
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp; The first parameter to this method is likely to be used in a
future version of this standard; it is recommended that
implementations do not use this parameter position for anything else.

<h3>toJSONString&nbsp;(&nbsp;pretty=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toJSONString</code> method convert this array object
to JSON format (<CITE ref="RFC4627">RFC 4627</CITE>).

<P><span class="pcounter"></span> The object is serialized as a a sequence of comma (<code>","</code>)
separated values wrapped in square brackets (<code>"["</code> and <code>"]"</code>).
The string representation of a value is computed by calling the public
<code>toJSONString</code> method on the value.

<P><span class="pcounter"></span> The <code>[[Prototype]]</code> internal property is not used when computing the
set of properties of an object that will be serialized.

<P><span class="pcounter"></span> Values that are not directly represented in JSON (such as
<b>undefined</b>, functions, and unknown types) will be silently skipped.
This means that holes in arrays, and array length, are not preserved.
The value <b>null</b> is serialized as the unquoted string <code>null</code>.

<P><span class="pcounter"></span> An <b>EncodingError</b> exception will be thrown if this object
contains a cyclical (sub)structure.  Recurring objects that do not
cause cycles are allowed, but will produce a complete text for each
occurrence.

<P><span class="pcounter"></span> If <i>pretty</i> is true, then linefeeds are inserted after each left
square bracket and comma and before a right square bracket, and
multiples of 4 spaces are inserted to indicate the level of nesting.
Otherwise, no whitespace is inserted between the tokens.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>toJSONString</code> method returns a <code>string</code>.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span> The <code>toJSONString</code> method is implementation-dependent.

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #201.)  Only cycle finding need be
implementation-dependent, we should have code here.


<h3>Generic methods</h3>

<P><span class="pcounter"></span>These methods delegate to their static counterparts, and like their
counterparts, they are generic: they can be transferred to other
objects for use as methods.  Whether these methods can be applied
successfully to a host object is implementation-dependent.

<PRE>
prototype function concat(...items)
    Array.helper::concat(this, items);

prototype function every(checker, thisObj=null)
    Array.every(this, checker, thisObj);

prototype function filter(checker, thisObj=null)
    Array.filter(this, checker, thisObj);

prototype function forEach(eacher, thisObj=null) {
    Array.forEach(this, eacher, thisObj);
}

prototype function indexOf(value, from=0)
    Array.indexOf(this, value, Number(from));

prototype function join(separator=undefined)
    Array.join(this, separator === undefined ? "," : string(separator));

prototype function lastIndexOf(value, from=NaN)
    Array.lastIndexOf(this, value, Number(from));

prototype function map(mapper, thisObj=null)
    Array.map(this, mapper, thisObj);

prototype function pop()
    Array.pop(this);

prototype function push(...args)
    Array.helper::push(this, args);

prototype function reverse()
    Array.reverse(this);

prototype function shift()
    Array.shift(this);

prototype function slice(start, end)
    Array.slice(this,
                start === undefined ? 0 : Number(start),
                end === undefined ? Infinity : Number(end));

prototype function some(checker, thisObj=null)
    Array.some(this, checker, thisObj);

prototype function sort(comparefn)
    Array.sort(this, comparefn);

prototype function splice(start, deleteCount, ...items)
    Array.helper::splice(this, Number(start), Number(deleteCount), items);

prototype function unshift(...items)
    Array.helper::unshift(this, items);
</PRE>

<p class="note"><b>COMPATIBILITY NOTE</b>&nbsp;&nbsp; In the 3rd Edition of this Standard some of the functions on the
Array prototype object had <code>length</code> properties that did not reflect
those functions' signatures.  In the 4th Edition of this Standard, all
functions on the Array prototype object have <code>length</code> properties
that follow the general rule stated in section <span class="xref">function-semantics</span>.


 
<h1>String classes</h1>

<pre>
FILE:                       spec/library/String.html
DRAFT STATUS:               DRAFT 1 - ROUGH - 2007-09-20
REVIEWED AGAINST ES3:       NO
REVIEWED AGAINST ERRATA:    NO
REVIEWED AGAINST BASE DOC:  NO
REVIEWED AGAINST PROPOSALS: NO
REVIEWED AGAINST CODE:      NO
</pre>

<P><span class="pcounter"></span> ECMAScript provides a primitive string representation in the class
<code>string</code>.  It is primitive in the sense that this representation is
directly operated upon by operators of the language, and in the sense
that it is a final and non-dynamic class for which ECMAScript
implementations may provide efficient representations.

<P><span class="pcounter"></span> ECMAScript also provides the class <code>String</code>, which is a dynamic
non-final class that holds <code>string</code> values.  Instances of <code>String</code>
are converted to <code>string</code> when operated upon by operators of the
language.


<h2 id="type AnyString"> The type <code>AnyString</code> </h2>

<P><span class="pcounter"></span> The type <code>AnyString</code> is a union type that contains the two
built-in string types.  By standard subtyping rules it also includes
all classes that extend <code>String</code>.

<PRE>
__ES4__ type AnyString = (string, String!);
</PRE>


<H1 id="class String"> The class <code>String</code> </h1>

<P><span class="pcounter"></span>The class <code>String</code> is a dynamic, nullable, non-final subclass of
<code>Object</code>.  It is a container for <code>string</code> values.  Instances of
<code>String</code> are converted to <code>string</code> when operated upon by the
operators of the language.

<P><span class="pcounter"></span> The class <code>String</code> can be extended and the extending classes can
provide novel representations for string values.

<h3>Synopsis</h3>

<P><span class="pcounter"></span> The class <code>String</code> provides the following interface:

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  Optional arguments need to be handled better in these interfaces.

<PRE>
dynamic class String
{
    function String(value="") &#x0085
    meta static function invoke(value="") &#x0085

    static function fromCharCode(...args) &#x0085
    static function charAt(self, pos) &#x0085
    static function charCodeAt(self, pos) &#x0085
    static function concat(self, ...args) : string &#x0085
    static function indexOf(self, searchString, position): double &#x0085
    static function lastIndexOf(self, searchString, position) : double &#x0085
    static function localeCompare(self, that) : double &#x0085
    static function match(self, regexp) : Array &#x0085
    static function parseJSON(self, filter=undefined) &#x0085
    static function replace(self, searchValue, replaceValue) : string &#x0085
    static function search(self, regexp) : double &#x0085
    static function slice(self, start, end): string &#x0085
    static function split(self, separator, limit): Array! &#x0085
    static function substring(self, start, end): string &#x0085
    static function toLowerCase(self): string &#x0085
    static function toLocaleLowerCase(self): string &#x0085
    static function toUpperCase(self): string &#x0085
    static function toLocaleUpperCase(self): string &#x0085
    static function trim(self) : string &#x0085

    static const length: uint = 1

    override intrinsic function toString() : string &#x0085
    override intrinsic function toJSONString(pretty:boolean=false) : string &#x0085
    override intrinsic function valueOf() : string &#x0085

    intrinsic function charAt(pos: double = 0) : string &#x0085
    intrinsic function charCodeAt(pos: double = 0) : double &#x0085
    intrinsic function concat(...args) : string &#x0085
    intrinsic function indexOf(searchString: AnyString, position: double = 0.0) 
        : double &#x0085
    intrinsic function lastIndexOf(searchString: AnyString, position: double) 
        : double &#x0085
    intrinsic function localeCompare(that: AnyString) : double &#x0085
    intrinsic function match(regexp: RegExp!) : Array &#x0085
    intrinsic function parseJSON(filter=undefined) &#x0085
    intrinsic function replace(s: (RegExp!,AnyString), r: (AnyString,function(...):AnyString)) 
        : string &#x0085
    intrinsic function search(regexp: RegExp!) : double &#x0085
    intrinsic function slice(s: double, e: double): string &#x0085
    intrinsic function split(separator:(AnyString,RegExp!), limit: uint = uint.MAX_VALUE) 
        : Array! &#x0085
    intrinsic function substring(start: double, end: double=Infinity) : string &#x0085
    intrinsic function toLowerCase(): string &#x0085
    intrinsic function toLocaleLowerCase(): string &#x0085
    intrinsic function toUpperCase() : string &#x0085
    intrinsic function toLocaleUpperCase() : string &#x0085
    intrinsic function trim() : string &#x0085

    function get length() : uint &#x0085
    meta function get(pos) &#x0085
}
</PRE>

<P><span class="pcounter"></span> The <code>String</code> prototype object provides the following direct properties:

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  Optional arguments need to be handled better in these interfaces.

<PRE>
    toString:          function (this:Strings) &#x0085;
    toJSONString:      function (this:Strings, pretty=false) &#x0085;
    valueOf:           function (this:Strings) &#x0085;
    charAt:            function (pos) &#x0085;
    charCodeAt:        function (pos) &#x0085;
    concat:            function (...strings) &#x0085;
    indexOf:           function (searchString, pos) &#x0085;
    lastIndexOf:       function (searchString, pos) &#x0085;
    localeCompare:     function (that) &#x0085;
    match:             function (regexp) &#x0085;
    parseJSON:         function () &#x0085;
    replace:           function (searchValue, replaceValue) &#x0085;
    search:            function (regexp) &#x0085;
    slice:             function (start, end) &#x0085;
    split:             function (separator, limit) &#x0085;
    substring:         function (start, end) &#x0085;
    toLowerCase:       function () &#x0085;
    toLocaleLowerCase: function () &#x0085;
    toUpperCase:       function () &#x0085;
    toLocaleUpperCase: function () &#x0085;
    trim:              function () &#x0085;
</PRE>

<P><span class="pcounter"></span> The <code>String</code> prototype object is also used as the prototype object for the
class <code>string</code>.

<h2>Methods on the <code>String</code> class object</h2>

<h3>new&nbsp;String&nbsp;(&nbsp;value=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The <code>String</code> constructor initializes a new <code>String</code> object
by storing <i>value</i>, converted to <code>string</code>, in a private property.
<i>Value</i> defaults to the empty string.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span> The <code>String</code> constructor is implementation-defined.

<h3>String(&nbsp;value=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The <code>String</code> class object called as a function converts
<i>value</i> to <code>string</code> (not to <code>String</code>).  <i>Value</i> defaults to
the empty string.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>String</code> class object called as a function returns a
<code>string</code> object.

<P class="implsection"><b>Implementation</b>
<PRE>
meta static function invoke(value="")
    string(value);
</PRE>

<h3>Methods that delegate to <code>string</code> methods</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic methods <code>charAt</code>, <code>charCodeAt</code>, <code>concat</code>,
<code>indexOf</code>, <code>lastIndexOf</code>, <code>localeCompare</code>, <code>match</code>, <code>parseJSON</code>,
<code>replace</code>, <code>search</code>, <code>slice</code>, <code>split</code>, <code>substring</code>,
<code>toLowerCase</code>, <code>toLocaleLowerCase</code>, <code>toUpperCase</code>,
<code>toLocaleUpperCase</code>, and <code>trim</code> all delegate 
to the corresponding static methods on the <code>string</code> class.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> These intrinsic methods return what their corresponding static
methods on the <code>string</code> class return.

<P class="implsection"><b>Implementation</b>
<PRE>
static function charAt(self, pos)
    string.charAt(self, pos);

static function charCodeAt(self, pos)
    string.charCodeAt(self, pos);

static function concat(self, ...args) : string
    string.helper::concat(self, args);

static function indexOf(self, searchString, position): double
    string.indexOf(self, searchString, position);

static function lastIndexOf(self, searchString, position) : double
    string.lastIndexOf(self, searchString, position);

static function localeCompare(self, that) : double
    string.localeCompare(self, that);

static function match(self, regexp) : Array
    string.match(self, regexp);

static function parseJSON(self, filter=undefined)
    string.parseJSON(string(self), filter);

static function replace(self, searchValue, replaceValue) : string
    string.replace(self, searchValue, replaceValue);

static function search(self, regexp) : double
    string.search(self, regexp);

static function slice(self, start, end): string
    string.slice(self, start, end);

static function split(self, separator, limit): Array!
    string.split(self, separator, limit);

static function substring(self, start, end): string
    string.substring(self, start, end);

static function toLowerCase(self): string
    string.toLowerCase(self);

static function toLocaleLowerCase(self): string
    string.toLocaleLowerCase(self);

static function trim(self) : string
    string.trim(self);
</PRE>

<h2>Methods on <code>String</code> instances</h2>

<h3>toString</h3>

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>toString</code> method returns this <code>String</code>
object converted to <code>string</code>.  For the class <code>String</code> itself this
results in the extraction of the private string value held by the
<code>String</code>.  Subclasses of <code>String</code> can represent strings
differently by overriding <code>toString</code>.

<P class="implsection"><b>Implementation</b>
<PRE>
override intrinsic function toString() : string
    string(this);
</PRE>

<h3>toJSONString</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toJSONString</code> method convert this string object
to JSON format (<CITE ref="RFC4627">RFC 4627</CITE>).

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>toJSONString</code> method returns a string.

<P class="implsection"><b>Implementation</b>
<PRE>
override intrinsic function toJSONString(pretty:boolean=false) : string
    JSON.formatString(string(this), pretty);
</PRE>

<h3>valueOf</h3>

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>valueOf</code> method returns the result of calling
the intrinsic <code>toString</code> method.

<P class="implsection"><b>Implementation</b>
<PRE>
override intrinsic function valueOf() : string
    intrinsic::toString();
</PRE>

<h3>Methods that delegate to <code>string</code> methods</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic methods <code>charAt</code>, <code>charCodeAt</code>, <code>concat</code>,
<code>indexOf</code>, <code>lastIndexOf</code>, <code>localeCompare</code>, <code>match</code>, <code>parseJSON</code>,
<code>replace</code>, <code>search</code>, <code>slice</code>, <code>split</code>, <code>substring</code>,
<code>toLowerCase</code>, <code>toLocaleLowerCase</code>, <code>toUpperCase</code>,
<code>toLocaleUpperCase</code>, and <code>trim</code> all delegate 
to the corresponding static methods on the <code>string</code> class, passing
<code>this</code> as the first argument in all cases.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> These intrinsic methods return what their corresponding static
methods on the <code>string</code> class return.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function charAt(pos: double = 0) : string
    string.charAt(this, pos);

intrinsic function charCodeAt(pos: double = 0) : double
    string.charCodeAt(this, pos);

intrinsic function concat(...args) : string
    string.helper::concat(this, args);

intrinsic function indexOf(searchString: AnyString, position: double = 0.0) : double
    string.indexOf(this, searchString, position);

intrinsic function lastIndexOf(searchString: AnyString, position: double) : double
    string.lastIndexOf(this, searchString, position);

intrinsic function localeCompare(that: AnyString) : double
    string.localeCompare(this, that);

intrinsic function match(regexp: RegExp!) : Array
    string.match(this, regexp);

intrinsic function parseJSON(filter=undefined)
    string.parseJSON(string(this), filter);

intrinsic function replace(s: (RegExp!,AnyString), r: (AnyString,function(...):AnyString)) : string
    string.replace(this, searchValue, replaceValue);

intrinsic function search(regexp: RegExp!) : double
    string.search(this, r);

intrinsic function slice(s: double, e: double): string
    string.slice(this, s, e);

intrinsic function split(separator:(AnyString,RegExp!), limit: uint = uint.MAX_VALUE) : Array!
    string.split(this, separator, limit);

intrinsic function substring(start: double, end: double=Infinity) : string
    string.substring(this, start, end);

intrinsic function toLowerCase(): string
    string.toLowerCase(this);

intrinsic function toLocaleLowerCase(): string
    string.toLocaleLowerCase(this);

intrinsic function toUpperCase() : string
    string.toUpperCase(this);

intrinsic function toLocaleUpperCase() : string
    string.toLocaleUpperCase(this);

intrinsic function trim() : string
    string.trim(string(this));
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The second parameter to the intrinsic method <code>localeCompare</code>
and the first parameter to the intrinsic methods <code>toLocaleLowerCase</code>
and <code>toLocaleUpperCase</code> are likely to be used in a future version of
this standard; it is recommended that implementations do not use these
parameter position for anything else.

<h2>Methods on the <code>String</code> prototype object</h2>

<h3>toString&nbsp;(&nbsp;)</h3>

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> Returns this result of invoking the intrinsic <code>toString</code>
method.

<P><span class="pcounter"></span> The <code>toString</code> function is not generic; it throws a
<b>TypeError</b> exception if its this value is not a <code>String</code> or
<code>string</code> object.  Therefore, it cannot be transferred to other kinds
of objects for use as a method.

<P class="implsection"><b>Implementation</b>
<PRE>
prototype function toString(this: AnyString)
    this.intrinsic::toString();
</PRE>

<h3>valueOf&nbsp;(&nbsp;)</h3>

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> Returns this result of invoking the intrinsic <code>valueOf</code> method.

<P><span class="pcounter"></span> The <code>valueOf</code> function is not generic; it throws a <b>TypeError</b>
exception if its this value is not a <code>String</code> or <code>string</code> object.
Therefore, it cannot be transferred to other kinds of objects for use
as a method.

<P class="implsection"><b>Implementation</b>
<PRE>
prototype function valueOf(this: AnyString)
    this.intrinsic::valueOf();
</PRE>

<h3>Methods that delegate to <code>string</code> methods</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The methods <code>charAt</code>, <code>charCodeAt</code>, <code>concat</code>,
<code>indexOf</code>, <code>lastIndexOf</code>, <code>localeCompare</code>, <code>match</code>,
<code>parseJSON</code>, <code>replace</code>, <code>search</code>, <code>slice</code>, <code>split</code>,
<code>substring</code>, <code>toLowerCase</code>, <code>toLocaleLowerCase</code>,
<code>toUpperCase</code>, <code>toLocaleUpperCase</code>, and <code>trim</code> on the <code>String</code>
prototype object all delegate to the
corresponding static methods on the <code>string</code> class, passing <code>this</code>
as the first argument in all cases.

<P><span class="pcounter"></span> These methods are all generic, they do not require that their
<code>this</code> object is a <code>String</code>.  Therefore, they can be transferred
to other kinds of objects for use as methods.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> These methods on the <code>String</code> prototype object all return the
values returned by their corresponding static methods on the
<code>string</code> class.

<P class="implsection"><b>Implementation</b>
<PRE>
prototype function charAt(pos)
    string.charAt(this, pos);

prototype function charCodeAt(pos)
    string.charCodeAt(this, pos);

prototype function concat(...args)
    string.helper::concat(this, args);

prototype function indexOf(searchString, position)
    string.indexOf(this, searchString, position);

prototype function lastIndexOf(searchString, position)
    string.lastIndexOf(this, searchString, position);

prototype function localeCompare(that)
    string.localeCompare(this, that);

prototype function match(regexp)
    string.match(this, regexp);

prototype function parseJSON(this:AnyString, filter=undefined)
    string.parseJSON(string(this), filter);

prototype function replace(searchValue, replaceValue)
    string.replace(this, searchValue, replaceValue);

prototype function search(regexp)
    string.search(this, regexp);

prototype function slice(start, end)
    string.slice(this, start, end);

prototype function split(separator, limit)
    string.split(this, separator, limit);

prototype function substring(start, end)
    string.substring(this, start, end);

prototype function toLowerCase()
    string.toLowerCase(this);

prototype function toLocaleLowerCase()
    string.toLocaleLowerCase(this);

prototype function trim()
    string.trim(this);


</PRE>


<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The second parameter to the prototype method <code>localeCompare</code>
and the first parameter to the prototype methods <code>toLocaleLowerCase</code>
and <code>toLocaleUpperCase</code> are likely to be used in a future version of
this standard; it is recommended that implementations do not use these
parameter position for anything else.
 
<H1 id="class string"> The class <code>string</code> </h1>

<pre>
FILE:                       spec/library/string_primitive.html
DRAFT STATUS:               DRAFT 1 - ROUGH - 2007-09-19
REVIEWED AGAINST ES3:       NO
REVIEWED AGAINST ERRATA:    NO
REVIEWED AGAINST BASE DOC:  NO
REVIEWED AGAINST PROPOSALS: NO
REVIEWED AGAINST CODE:      NO
</pre>

<P><span class="pcounter"></span> The class <code>string</code> is a final, non-nullable, non-dynamic
subclass of Object that represents an immutable indexable sequence of
Unicode characters.  The property <code>"length"</code> holds the number of
characters in this sequence.  The property <code>"0"</code> names the first
character, the property <code>"1"</code> names the second character, and so on,
up to property <code>"length"</code>-1.  Single characters are represented as
<code>string</code> objects with length equal to one.

<P><span class="pcounter"></span> The <code>string</code> class has the same prototype object as the
<code>String</code> class; changes made to the prototype object of one class
are visible on the prototype object of the other class.

<p class="note"><b>COMPATIBILITY NOTE</b>&nbsp;&nbsp;  The class <code>string</code> is new in the 4th Edition of this
Standard, but <code>string</code> models the "string values" in the 3rd
Edition.


<h2>Synopsis</h2>

<P><span class="pcounter"></span> The class <code>string</code> provides the following interface:

<PRE>
final class string!
{
    function string(value="") &#x0085
    meta static function invoke(value="") &#x0085

    static function fromCharCode(...codes) &#x0085
    static function charAt(self, pos) : string &#x0085
    static function charCodeAt(self, pos) : double &#x0085
    static function concat(self, ...args) &#x0085
    static function indexOf(self, searchString, position) : double &#x0085
    static function lastIndexOf(self, searchString, position) : double &#x0085
    static function localeCompare(self, that) : double &#x0085
    static function match(self, regexp): Array &#x0085
    static function parseJSON(self, filter=undefined) &#x0085
    static function replace(self, s, r): string &#x0085
    static function search(self, regexp): double &#x0085
    static function slice(self, s, e): Array &#x0085
    static function split(self, separator, limit) : Array! &#x0085
    static function substring(self, start, end) : string &#x0085
    static function toLowerCase(self): string &#x0085
    static function toLocaleLowerCase(self): string &#x0085
    static function toUpperCase(self): string &#x0085
    static function toLocaleUpperCase(self) &#x0085
    static function trim(s): string &#x0085

    static const length: uint = 1

    override intrinsic function toString() : string &#x0085
    override intrinsic function valueOf() : string &#x0085

    intrinsic function charAt(pos: double = 0) : string &#x0085
    intrinsic function charCodeAt(pos: double = 0) : double &#x0085
    intrinsic function concat(...args) : string &#x0085
    intrinsic function indexOf(searchString: string, position: double = 0.0) 
        : double &#x0085
    intrinsic function lastIndexOf(searchString: string, position: double) : double &#x0085
    intrinsic function localeCompare(that : string) : double &#x0085
    intrinsic function match(regexp: RegExp) : Array &#x0085
    intrinsic function parseJSON(filter=undefined) &#x0085
    intrinsic function replace(searchValue: (string,RegExp!), &#x0085
    intrinsic function search(regexp: RegExp!) : double &#x0085
    intrinsic function slice(start: double, end: double): Array &#x0085
    intrinsic function split(separator:(string,RegExp!), limit: uint = uint.MAX_VALUE)
        : Array! &#x0085
    intrinsic function substring(start: double, end: double=this.length) : string &#x0085
    intrinsic function toLowerCase() : string &#x0085
    intrinsic function toLocaleLowerCase() : string &#x0085
    intrinsic function toUpperCase() : string &#x0085
    intrinsic function toLocaleUpperCase() : string &#x0085
    intrinsic function trim() : string &#x0085

    function get length() : uint &#x0085
    meta function get(pos) &#x0085
}
</PRE>

<h2>Static Methods on the <code>string</code> Class</h2>

<h3>new&nbsp;string&nbsp;(&nbsp;value=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The <code>string</code> constructor initializes a new <code>string</code> object
by storing an implementation-dependent string representation of
<i>value</i> in a private property.  The default <i>value</i> is the empty
string.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span> The <code>string</code> constructor is implementation-dependent.

<h3>string&nbsp;(&nbsp;value=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The <code>string</code> class object called as a function converts
<i>value</i> to <code>string</code> as by the <code>ToString</code> operator.  The default
<i>value</i> is the empty string.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>string</code> class object called as a function returns a <code>string</code>.

<P class="implsection"><b>Implementation</b>
<PRE>
meta static function invoke(value="")
    value is string ? value : magic::newString(value);
</PRE>

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #176.) The use of <code>magic::newString</code> is an
optimization that confuses the spec; <code>new string(x)</code> would have been
better.

<h3>fromCharCode&nbsp;(&nbsp;...codes&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>fromCharCode</code> method creates a <code>string</code>
containing as many characters as there are elements in <i>codes</i>.
Each element of <i>codes</i> specifies the Unicode code point value of
one character of the resulting string, with the first argument
specifying the first character, and so on, from left to right.

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #170.) The code below assumes a 21-bit Unicode
representation.  What happens in a system that only has 16-bit
unicode?  We'd like to be backwards compatible.  If so, the upper bits
are ignored.  This conflicts with how <code>\u{...}</code> is handled, though:
it creates two code points.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>fromCharCode</code> method returns the computed <code>string</code>.

<P class="implsection"><b>Implementation</b>
<PRE>
static function fromCharCode(...codes)
    string.helper::fromCharCode(codes);

helper static function fromCharCode(codes: Array): string {
    let s = "";
    for (let i=0, limit=codes.length ; i &#60; limit ; ++i)
        s += magic::fromCharCode(uint(codes[i] & 0x1FFFFF));
    return s;
}
</PRE>

<h3>charAt&nbsp;(self,&nbsp;pos)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>charAt</code> method converts <i>self</i> to <code>string</code> and
extracts the character at index <i>pos</i>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>charAt</code> method returns a <code>string</code>.

<P class="implsection"><b>Implementation</b>
<PRE>
static function charAt(self, pos) : string {
    let S    = string(self);
    let ipos = helper::toInteger(pos);
    if (ipos &#60; 0 || ipos >= S.length)
        return "";
    return magic::fromCharCode(magic::charCodeAt(S, uint(ipos)));
}
</PRE>

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #176.) The use of <code>magic::charCodeAt</code> is an optimization that
complicates the spec; <code>string.charCodeAt(x)</code> would have been better.

<h3>charCodeAt&nbsp;(self,&nbsp;pos)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>charCodeAt</code> method converts <i>self</i> to <code>string</code> and
extracts the code point value of the character at index <i>pos</i>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>charCodeAt</code> method returns a number.

<P class="implsection"><b>Implementation</b>
<PRE>
static function charCodeAt(self, pos) : double {
    let S = string(self);
    let ipos = helper::toInteger(pos);
    if (ipos &#60; 0 || ipos >= S.length)
        return NaN;
    return magic::charCodeAt(S, uint(ipos));
}
</PRE>

<h3>concat&nbsp;(&nbsp;self,&nbsp;...strings&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>concat</code> method computes a <code>string</code> value
consisting of the characters of <i>self</i> (converted to <code>string</code>)
followed by the characters of each of the elements of <i>strings</i>
(where each argument is converted to <code>string</code>).

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>concat</code> method returns the concatenated <code>string</code>.

<P class="implsection"><b>Implementation</b>
<PRE>
static function concat(self, ...args)
    string.helper::concat(self, args);

helper static function concat(self, strings) : string {
    let S = string(self);
    let n = strings.length;
    for (let i=0; i &#60; n ; i++)
        S += string(strings[i]);
    return S;
}
</PRE>

<h3>indexOf&nbsp;(&nbsp;self,&nbsp;searchString,&nbsp;position)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>indexOf</code> method searches <i>self</i> (converted to
string) for occurrences of <i>searchString</i> (converted to <code>string</code>),
at positions that are greater than or equal to <i>position</i> (converted
to integer).

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>indexOf</code> method returns the smallest index at
which a match was found, or -1 if there was no match.

<P class="implsection"><b>Implementation</b>
<PRE>
static function indexOf(self, searchString, position) : double {
    let S     = string(self);
    let SS    = string(searchString);
    let pos   = helper::toInteger(position);
    let slen  = S.length;
    let m     = Math.min(Math.max(pos, 0), slen);
    let sslen = SS.length;
    let lim   = slen - sslen + 1;

    outer:
    for ( let k = m ; k &#60; lim ; k++ ) {
        for ( let w = 0 ; w &#60; sslen ; w++ ) {
            if (magic::charCodeAt(S, uint(k+w)) !== magic::charCodeAt(SS, uint(w)))
                continue outer;
        }
        return k;
    }
    return -1;
}
</PRE>

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #176.) The use of <code>magic::charCodeAt</code> is an optimization that
complicates the spec; using <code>string.charCodeAt</code> would have been
better.

<h3>lastIndexOf&nbsp;(&nbsp;self,&nbsp;searchString,&nbsp;position)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>lastIndexOf</code> method searches <i>self</i> (converted
to string) for occurrences of <i>searchString</i> (converted to
<code>string</code>), at positions that are smaller than or equal to
<i>position</i> (converted to integer).

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>lastIndexOf</code> method returns the greatest index at
which a match was found, or -1 if there was no match.

<P class="implsection"><b>Implementation</b>
<PRE>
static function indexOf(self, searchString, position) : double {
    let S     = string(self);
    let SS    = string(searchString);
    let pos   = helper::toInteger(position);
    let slen  = S.length;
    let m     = Math.min(Math.max(pos, 0), slen);
    let sslen = SS.length;
    let lim   = slen - sslen + 1;

    outer:
    for ( let k = m ; k &#60; lim ; k++ ) {
        for ( let w = 0 ; w &#60; sslen ; w++ ) {
            if (magic::charCodeAt(S, uint(k+w)) !== magic::charCodeAt(SS, uint(w)))
                continue outer;
        }
        return k;
    }
    return -1;
}
</PRE>

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #176.) The use of <code>magic::charCodeAt</code> is an optimization that
complicates the spec; using <code>string.charCodeAt</code> would have been
better.

<h3>localeCompare&nbsp;(self,&nbsp;other)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>localeCompare</code> method compares <i>self</i>
(converted to <code>string</code>) with <i>other</i> (converted to string) in a
locale-sensitive manner.  The two strings are compared in an
implementation-defined fashion.  The comparison is intended to order
strings in the sort order specified by the system default locale.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>localeCompare</code> method returns a number other than
<b>NaN</b> that represents the result of the comparison.  The result will
be negative, zero, or positive, depending on whether <i>self</i> comes
before <i>other</i> in the sort order, the strings are equal, or <i>self</i>
comes after <i>other</i> in the sort order, respectively.

<P><span class="pcounter"></span>The static <code>localeCompare</code> method is a consistent comparison
function (as defined in <span class="xref">sort:consistent_comparator</span>) on
the set of all strings.  Furthermore, <code>localeCompare</code> returns 0 or -0
when comparing two strings that are considered canonically equivalent
by the Unicode standard.

<P><span class="pcounter"></span>The actual return values are left implementation-defined to permit
implementers to encode additional information in the result value, but
the function is required to define a total ordering on all strings and
to return 0 when comparing two strings that are considered canonically
equivalent by the Unicode standard.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span> The static <code>localeCompare</code> method is implementation-defined.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  This function is intended to rely on whatever
language-sensitive comparison functionality is available to the
ECMAScript environment from the host environment, and to compare
according to the rules of the host environment's current locale. It is
strongly recommended that this function treat strings that are
canonically equivalent according to the Unicode standard as identical
(in other words, compare the strings as if they had both been
converted to Normalised Form C or D first). It is also recommended
that this function not honour Unicode compatibility equivalences or
decompositions.  If no language-sensitive comparison at all is
available from the host environment, this function may perform a
bitwise comparison.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The third parameter to this function is likely to be used in a
future version of this standard; it is recommended that
implementations do not use this parameter position for anything else.


<h3>match&nbsp;(self,&nbsp;regexp)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>match</code> method searches <i>self</i> (converted to
<code>string</code>) for occurrences of <i>regexp</i> (converted to <code>RegExp</code>).

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> If the <code>global</code> flag on <i>regexp</i> is <b>false</b>, the <code>match</code> method returns
the result obtained by invoking the intrinsic <code>exec</code> method on <i>regexp</i> with <i>self</i>
as a parameter.

<P><span class="pcounter"></span> If the <code>global</code> flag on <i>regexp</i> is <b>true</b>, the <code>match</code>
method returns an array of strings containing the substrings of
<i>self</i> that were matched by <i>regexp</i>, in order.

<P class="implsection"><b>Implementation</b>
<PRE>
static function match(self, regexp): Array {
    let S = string(self);
    let R = regexp is RegExp ? regexp : new RegExp(regexp);

    if (!R.global)
        return R.exec(S);

    let matches = [];

    R.lastIndex = 0;
    while (true) {
        let oldLastIndex = R.lastIndex;
        let res = R.exec(S);

        if (res === null)
            break;

        matches.push(res[0]);
        if (R.lastIndex === oldLastIndex)
            ++R.lastIndex;
    }
    if (matches.length == 0)
        return null;
    else
        return matches;
}
</PRE>

<h3>parseJSON(&nbsp;self,&nbsp;filter=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>parseJSON</code> method parses <i>self</i> (converted to
<code>string</code>) as a JSON object.  The argument <code>filter</code>, if not
<b>undefined</b>, should be a function that takes two arguments <i>key</i>
and <i>value</i> and returns a possibly modified <i>value</i>.  It will be
called for each element of objects and arrays.

<P><span class="pcounter"></span> An <b>EncodingError</b> exception will be thrown if <i>self</i> is not
parseable as a JSON object.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>parseJSON</code> method returns an ECMAScript value.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span> The <code>parseJSON</code> method is implementation-dependent.

<h3>replace&nbsp;(self,&nbsp;searchValue,&nbsp;replaceValue)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>replace</code> method computes a string from <i>self</i>
(converted to <code>string</code>) by replacing substrings matching
<i>searchValue</i> (converted to <code>string</code> if not <code>RegExp</code>) by
instances of <i>replaceValue</i> (converted to <code>string</code> if not a
function).

<P><span class="pcounter"></span> If <i>replaceValue</i> is a function, then it is called once for each
matched substring on arguments providing details about the match, and
the value returned from this call is converted to <code>string</code> if
necessary and replaces the matched substring.

<P><span class="pcounter"></span> If <i>replaceValue</i> is not a function then a string to replace a
matched substring is derived from <i>replaceValue</i> by replacing
characters of <i>replaceValue</i> (converted to <code>string</code>) as specified
in the following table.  These <code>$</code> replacements are done
left-to-right, and, once such a replacement is performed, the new
replacement text is not subject to further replacements.  For example,
<code>"$1,$2".replace(/(\$(\d))/g, "$$1-$1$2")</code> returns
<code>"$1-$11,$1-$22"</code>.  A <code>$</code> in <i>replaceValue</i> that does not match
any of the forms below is left as is.

<table border=1>
<tr><th>Characters</th><th>Replacement text</th></tr>
<tr><td>$$</td>        <td>$</td></tr>
<tr><td>$&</td>        <td>The matched substring.</td></tr>
<tr><td>$`</td>        <td>The portion of <i>self</i> that precedes the matched substring.</td></tr>
<tr><td>$'</td>        <td>The portion of <i>self</i> that follows the matched substring.</td></tr>
<tr><td>$n</td>        <td>The <i>n</i>th capture, where <i>n</i> is a single digit 1-9 and <code>$n</code> is not
                           followed by a decimal digit. If <i>n&#x2264;m</i> and the <i>n</i>th capture
                           is undefined, use the empty string instead. If <i>n>m</i>,
                           the result is implementation-defined.</td></tr>
<tr><td>$nn</td>       <td>The <i>nn</i>th capture, where <i>nn</i> is a two-digit decimal number
                           01-99. If <i>nn&#x2264;m</i> and the <i>nn</i>th capture is undefined, use
                           the empty string instead. If <i>nn>m</i>, the result is implementation-defined.</td></tr>
</table>

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  In the above table, <i>m</i> is the length of the search result's
capture array.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>replace</code> function returns a <code>string</code> object
that is the concatenation of the unmatched portions of <i>self</i> and
the computed replace values for the matched portions of <i>self</i>, in
order.

<P class="implsection"><b>Implementation</b>
<PRE>
static function replace(self, s, r): string {

    let function substituteFunction(start: uint, end: uint, m: uint, cap: Array) : string {
        let A = [];
        A[0] = S.substring(start, end);
        for ( let i=0 ; i &#60; m ; i++ )
            A[i+1] = cap[i+1];
        A[m+2] = start;
        A[m+3] = S;
        return string(replaceFun.apply(null, A));
    }

    let function substituteString(start: uint, end: uint, m: uint, cap: Array) : string {
        let s   = "";
        let i   = 0;
        let r   = /\$(?:(\$)|(\&)|(\`)|(\')|([0-9]{1,2}))/g;
        let res;

        while ((res = r.exec(replaceString)) !== null) {
            s += replaceString.substring(i, r.lastIndex - res[0].length);
            i = r.lastIndex;

            if (res[1])      s += "$";
            else if (res[2]) s += S.substring(start, end);
            else if (res[3]) s += S.substring(0, start);
            else if (res[4]) s += S.substring(end);
            else {
                let n = parseInt(res[5]);
                if (n &#60;= m && cap[n] !== undefined)
                    s += cap[n];
            }
        }
        s += replaceString.substring(i);

        return s;
    }

    let function match( regexp, i : uint ) : [uint, CapArray]  {
        while (i &#60;= S.length) {
            let res : MatchResult = regexp.helper::match(S, i);
            if (res !== null) {
                res.captures[0] = S.substring(i,res.endIndex);
                return [i, res.captures];
            }
            ++i;
        }
        return [0, null];
    }

    let S             = string(self);
    let replaceString = r is string ? r cast string : null;
    let replaceFun    = r is Function ? r cast Function : null;

    let substitute : function (uint, uint, uint, Array) : string =
        replaceFun !== null ? substituteFunction : substituteString;

    if (s !== null && s is RegExp) {
        let regexp = s cast RegExp;
        let m      = regexp.helper::nCapturingParens;

        if (!regexp.global) {
            let [i, res] = match(regexp, 0);

            if (res === null)
                return S;

            let end = i + res[0].length;
            return S.substring(0,i) + substitute(i, end, m, res) + S.substring(end);
        }
        else {
            let newstring = "";
            let prevEnd   = 0;

            regexp.lastIndex = 0;
            while (true) {
                let oldLastIndex : double = regexp.lastIndex;
                let [i,res] = match(regexp, uint(oldLastIndex));

                if (res === null)
                    break;

                newstring += S.substring(prevEnd, i);

                let end = i + res[0].length;
                regexp.lastIndex = end;
                if (regexp.lastIndex == oldLastIndex)
                    regexp.lastIndex++;
                newstring += substitute(i, end, m, res);
                prevEnd = end;
            }
            newstring += S.substring(prevEnd, S.length);

            return newstring;
        }
    }
    else {
        let searchString = string(s);
        let pos          = S.indexOf(searchString, 0);

        if (pos === -1)
            return S;

        let end = pos + searchString.length;
        return S.substring(0,pos) + substitute(pos, end, 0, []) + S.substring(end);
    }
}
</PRE>

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #177.) The code above needs to be factored into a
top-level function with the auxiliary functions following it; values
of names now free in the nested functions must be passed as
parameters.

<h3>search&nbsp;(self,&nbsp;regexp)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>search</code> method searches <i>self</i> (converted to
<code>string</code>) for the first occurrence of the search term <i>regexp</i>
(converted to <code>RegExp</code>).

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  This method ignores the <code>lastIndex</code> and global properties of
<i>regexp</i>.  The <code>lastIndex</code> property of <i>regexp</i> is left
unchanged.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>search</code> method returns a number indicating the index
at which a match was made, or -1 if there was no match.

<P class="implsection"><b>Implementation</b>
<PRE>
static function search(self, regexp): double {
    let S = string(self);
    let R = regexp is RegExp ? regexp : new RegExp(regexp);

    for ( let i=0, limit=S.length ; i &#60; limit ; i++ )
        if (R.helper::match(S, i) !== null)
            return i;
    return -1;
}
</PRE>

<h3>slice&nbsp;(self,&nbsp;start,&nbsp;end)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>slice</code> method extracts a substring of <i>self</i>
(converted to <code>string</code>) from <i>start</i> and up to but not including
<i>end</i> (both converted to integer).  Both <i>start</i> and <i>end</i> may
be negative.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>slice</code> method returns a <code>string</code>.

<P class="implsection"><b>Implementation</b>
<PRE>
static function slice(self, s, e): Array {
    let S     = string(self);
    let len   = S.length;
    let start = helper::toInteger(s);
    let end   = e === undefined ? len : helper::toInteger(e);

    let startpos = start &#60; 0 ? Math.max(len+start,0) : Math.min(start,len);
    let endpos = end &#60; 0 ? Math.max(len+end,0) : Math.min(end,len);
    let n = Math.max(endpos-startpos,0);

    return S.substring(startpos, startpos+n);
}
</PRE>

<h3>split&nbsp;(self,&nbsp;separator,&nbsp;limit)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>split</code> method extracts substrings from <i>self</i>
(converted to <code>string</code>), where substrings are separated by instances
of <i>separator</i> (converted to <code>string</code> if not a <code>RegExp</code>).  At
most <i>limit</i> substrings are extracted.

<P><span class="pcounter"></span> Occurrences of <i>separator</i> are not part of any substring in the result.

<P><span class="pcounter"></span>The value of <i>separator</i> may be an empty string, an empty regular
expression, or a regular expression that can match an empty string.
In this case, <i>separator</i> does not match the empty substring at the
beginning or end of the input string, nor does it match the empty
substring at the end of the previous separator match.  (For example,
if <i>separator</i> is the empty string, the string is split up into
individual characters; the length of the result array equals the
length of the string, and each substring contains one character.)  If
<i>separator</i> is a regular expression, only the first match at a given
position of the this string is considered, even if backtracking could
yield a non-empty-substring match at that position.  (For example,
<code>string.split("ab",/a*?/)</code> evaluates to the array <code>["a","b"]</code>,
while <code>string.split("ab",/a*/)</code> evaluates to the array
<code>["","b"]</code>.)

<P><span class="pcounter"></span> If <i>self</i> is (or converts to) the empty string, the result
depends on whether <i>separator</i> can match the empty string.  If it
can, the result contains no elements.  Otherwise, the result contains
one element, which is the empty string.

<P><span class="pcounter"></span> If <i>separator</i> is a regular expression that contains capturing
parentheses, then each time <i>separator</i> is matched the results
(including any undefined results) of the capturing parentheses are
spliced into the result. For example,
<PRE>
"A&#60;B>bold&#60;/B>and&#60;CODE>coded&#60;/CODE>".split(/&#60;(\/)?([^&#60;>]+)>/)
</PRE>
evaluates to the array
<PRE>
["A", undefined, "B", "bold", "/", "B", "and", undefined, "CODE", "coded", "/", "CODE", ""].
</PRE>

<P><span class="pcounter"></span>If <i>separator</i> is <b>undefined</b>, then the result contains just one
string, which is <i>self</i> (converted to <code>string</code>).

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>split</code> method returns a new <code>Array</code> object
holding the extracted substrings, in order.

<P class="implsection"><b>Implementation</b>
<PRE>
static function split(self, separator, limit) : Array! {

    type matcher = (string,RegExp!);

    function splitMatch(R: matcher, S: string, q: uint) : [uint, [string]]? {
        switch type (R) {
        case (x: string) {
            let r = x.length;
            if (q + r &#60;= S.length && S.substring(q, q + r) === R)
                return [q+r, []];
            else
                return null;
        }
        case (x: RegExp!) {
            let mr: MatchResult = x.helper::match(S, q);
            if (mr === null)
                return null;
            else
                return [mr.endIndex, mr.captures];
        }
        }
    }

    let A   = new Array;
    let lim = limit === undefined ? uint.MAX_VALUE : uint(limit);
    let S   = string(self);
    let s   = S.length;
    let p   = 0;
    let R;

    if (separator !== null && separator is RegExp)
        R = separator;
    else
        R = string(separator);

    if (lim === 0)
        return A;

    if (separator === undefined) {
        A[0] = S;
        return A;
    }

    if (s === 0) {
        let z = splitMatch(R, S, 0);
        if (z === null)
            A[0] = S;
        return A;
    }

    for ( let q = p ; q !== s ; ) {
        let z = splitMatch(R, S, q);
        if (z === null) {
            ++q;
            continue;
        }

        let [e,cap] = z;
        if (e === p) {
            ++q;
            continue;
        }

        A[A.length] = S.substring(p, q);
        if (A.length === lim)
            return A;

        p = e;

        for ( let i=1 ; i &#60; cap.length ; i++ ) {
            A[A.length] = cap[i];
            if (A.length === lim)
                return A;
        }

        q = p;
    }

    A[A.length] = S.substring(p, s);
    return A;
}
</PRE>

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #178.) The exposition leaves something to be desired.
Should split <code>splitMatch</code> out as a separate helper function, at
least.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The static <code>split</code> method ignores the value of
<i>separator</i><code>.global</code> for separators that are <code>RegExp</code> objects.

<h3>substring&nbsp;(self,&nbsp;start,&nbsp;end)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>substring</code> method extracts a substring from
<i>self</i> (converted to <code>string</code>) from <i>start</i> up to but not
including <i>end</i> (converted to number).

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>substring</code> method returns a <code>string</code>.

<P class="implsection"><b>Implementation</b>
<PRE>
static function substring(self, start, end) : string {
    let S   = string(self);
    let len = S.length;

    start = helper::toInteger(start);
    end = end === undefined ? len : helper::toInteger(end);

    start = Math.min(Math.max(start, 0), len);
    end = Math.min(Math.max(end, 0), len);

    if (start > end)
        [start, end] = [end, start];

    let s = "";
    for ( let i=start ; i &#60; end ; i++ )
        s += S[i];

    return s;
}
</PRE>

<h3>toLowerCase&nbsp;(&nbsp;self&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>toLowerCase</code> method converts the characters of
<i>self</i> (converted to string) to lower case.  The characters are
converted one by one.  The result of each conversion is the original
character, unless that character has a Unicode lowercase equivalent,
in which case the lowercase equivalent is used instead.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The result should be derived according to the case mappings in
the Unicode character database (this explicitly includes not only the
<code>UnicodeData.txt</code> file, but also the <code>SpecialCasings.txt</code> file
that accompanies it in Unicode 2.1.8 and later).

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>toLowerCase</code> method returns a <code>string</code>.

<P class="implsection"><b>Implementation</b>
<PRE>
static function toLowerCase(self): string {
    let S = string(self);
    let s = "";

    for ( let i=0, limit=S.length ; i &#60; limit ; i++ ) {
        let u = Unicode.toLowerCaseCharCode(magic::charCodeAt(S,uint(i)));
        if (u is uint)
            s += magic::fromCharCode(u);
        else {
            for ( let j=0 ; j &#60; u.length ; j++ )
                s += magic::fromCharCode(u[j]);
        }
    }
    return s;
}
</PRE>

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #176.) The use of <code>magic::charCodeAt</code> and
<code>magic::fromCharCode</code> is a confusing optimization.

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #179.) Cross reference to the Unicode library somehow,
or put the unicode stuff into the <code>helper</code> namespace.

<h3>toLocaleLowerCase&nbsp;(&nbsp;self&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>toLocaleLowerCase</code> method works exactly the same
as the static <code>toLowerCase</code> method except that it is intended to
yield the correct result for the host environment's current locale,
rather than a locale-independent result.  There will only be a
difference in the few cases (such as Turkish) where the rules for that
language conflict with the regular Unicode case mappings.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>toLocaleLowerCase</code> method returns a <code>string</code>.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span>
The static <code>toLocaleLowerCase</code> method is implementation-dependent.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The second parameter to this function is likely to be used in a
future version of this standard; it is recommended that
implementations do not use this parameter position for anything else.

<h3>toUpperCase&nbsp;(&nbsp;self&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>toUpperCase</code> method converts the characters of
<i>self</i> (converted to string) to upper case.  The characters are
converted one by one.  The result of each conversion is the original
character, unless that character has a Unicode uppercase equivalent,
in which case the uppercase equivalent is used instead.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The result should be derived according to the case mappings in
the Unicode character database (this explicitly includes not only the
<code>UnicodeData.txt</code> file, but also the <code>SpecialCasings.txt</code> file
that accompanies it in Unicode 2.1.8 and later).

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>toUpperCase</code> method returns a <code>string</code>.

<P class="implsection"><b>Implementation</b>
<PRE>
static function toUpperCase(self): string {
    let S   = string(self);
    let s   = "";

    for ( let i=0, limit=S.length ; i &#60; limit ; i++ ) {
        let u = Unicode.toUpperCaseCharCode(magic::charCodeAt(S,uint(i)));
        if (u is uint)
            s += magic::fromCharCode(u);
        else {
            for ( let j=0 ; j &#60; u.length ; j++ )
                s += magic::fromCharCode(u[j]);
        }
    }
    return s;
}
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  Because both <code>toUpperCase</code> and <code>toLowerCase</code> have
context-sensitive behaviour, the functions are not symmetrical. In
other words, <code>string.toLowerCase(string.toUpperCase(s))</code> is not
necessarily equal to <code>string.toLowerCase(s)</code>.


<h3>toLocaleUpperCase&nbsp;(&nbsp;self&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>toLocaleUpperCase</code> method works exactly the same
as the static <code>toUpperCase</code> method except that it is intended to
yield the correct result for the host environment's current locale,
rather than a locale-independent result.  There will only be a
difference in the few cases (such as Turkish) where the rules for that
language conflict with the regular Unicode case mappings.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>toLocaleUpperCase</code> method returns a <code>string</code>.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span>
The static <code>toLocaleUpperCase</code> method is implementation-dependent.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The second parameter to this function is likely to be used in a
future version of this standard; it is recommended that
implementations do not use this parameter position for anything else.

<h3>trim&nbsp;(&nbsp;self&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>trim</code> method extracts a substring from <i>self</i>
(converted to <code>string</code>) such that the extracted string contains no
whitespace characters at either end.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>trim</code> method returns a <code>string</code>.

<P class="implsection"><b>Implementation</b>
<PRE>
static function trim(s): string {
    s = string(s);

    let len = s.length;
    let i, j;

    for ( i=0 ; i &#60; len && Unicode.isTrimmableSpace(s.charAt(i)) ; i++ )
        ;
    for ( j=len-1 ; j >= i && Unicode.isTrimmableSpace(s.charAt(j)) ; j-- )
        ;
    return s.substring(i,j+1);
}
</PRE>

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #179.) Reference to Unicode library -- handle this somehow.

<h2>Methods on <code>string</code> instances</h2>

<h3>intrinsic::toString</h3>

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>toString</code> method returns this string value: the object itself.

<PRE>
override intrinsic function toString() : string
    this;
</PRE>

<h3>toJSONString</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toJSONString</code> method convert this string object
to JSON format (<CITE ref="RFC4627">RFC 4627</CITE>).

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>toJSONString</code> method returns a <code>string</code>.

<P class="implsection"><b>Implementation</b>
<PRE>
override intrinsic function toJSONString(pretty:boolean=false) : string
    JSON.formatString(this, pretty);
</PRE>

<h3>intrinsic::valueOf</h3>

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>valueOf</code> method returns this string value: the object itself.

<PRE>
override intrinsic function valueOf() : string
    this;
</PRE>

<h3>Methods that delegate to static methods</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic methods <code>charAt</code>, <code>charCodeAt</code>, <code>concat</code>,
<code>indexOf</code>, <code>lastIndexOf</code>, <code>localeCompare</code>, <code>match</code>,
<code>parseJSON</code>, <code>replace</code>, <code>search</code>, <code>slice</code>, <code>split</code>,
<code>substring</code>, <code>toLowerCase</code>, <code>toLocaleLowerCase</code>,
<code>toUpperCase</code>, <code>toLocaleUpperCase</code>, and <code>trim</code> all delegate to
the corresponding static methods on the <code>string</code> class.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> These intrinsic methods return what their corresponding static
methods on the <code>string</code> class return.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function charAt(pos: double = 0) : string
    string.charAt(this, pos);

intrinsic function charCodeAt(pos: double = 0) : double
    string.charCodeAt(this, pos);

intrinsic function concat(...args) : string
    string.helper::concat(this, args);

intrinsic function indexOf(searchString: string, position: double = 0.0) : double
    string.indexOf(this, searchString, position);

intrinsic function lastIndexOf(searchString: string, position: double) : double
    string.lastIndexOf(this, searchString, position);

intrinsic function localeCompare(that : string) : double
    string.localeCompare(this, that);

intrinsic function match(regexp: RegExp) : Array
    string.match(this, regexp);

intrinsic function replace(searchValue: (string,RegExp!),
                           replaceValue: (string,function(...):string)) : string
    string.replace(this, searchValue, replaceValue);

intrinsic function search(regexp: RegExp!) : double
    string.search(this, regexp);

intrinsic function slice(start: double, end: double): Array
    string.slice(this, start, end);

intrinsic function split(separator:(string,RegExp!), limit: uint = uint.MAX_VALUE): Array!
    string.split(this, separator, limit)

intrinsic function substring(start: double, end: double=this.length) : string
    string.substring(this, start, end);

intrinsic function toLowerCase() : string
    string.toLowerCase(this);

intrinsic function toLocaleLowerCase() : string
    string.toLowerCase(this);

intrinsic function toUpperCase() : string
    string.toUpperCase(this);

intrinsic function toLocaleUpperCase() : string
    string.toLocaleUpperCase(this);

intrinsic function trim() : string
    string.trim(this);
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The second parameter to the intrinsic method <code>localeCompare</code>
and the first parameter to the intrinsic methods <code>toLocaleLowerCase</code>
and <code>toLocaleUpperCase</code> are likely to be used in a future version of
this standard; it is recommended that implementations do not use these
parameter position for anything else.
 
<h1>Boolean classes</h1>

<pre>
FILE:                       spec/library/Boolean.html
DRAFT STATUS:               DRAFT 1 - ROUGH - 2007-09-20
REVIEWED AGAINST ES3:       NO
REVIEWED AGAINST ERRATA:    NO
REVIEWED AGAINST BASE DOC:  NO
REVIEWED AGAINST PROPOSALS: NO
REVIEWED AGAINST CODE:      NO
</pre>

<P><span class="pcounter"></span> ECMAScript provides a primitive truth value representation in the
class <code>boolean</code>.  It is primitive in the sense that this
representation is directly operated upon by the operators of the
language, and in the sense that the class <code>boolean</code> is a final and
non-dynamic class for which ECMAScript implementations may provide
efficient representations.

<P><span class="pcounter"></span> ECMAScript also provides the class <code>Boolean</code>, which is a dynamic
non-final class that holds <code>boolean</code> values.  Instances of
<code>Boolean</code> are converted to <code>boolean</code> when operated upon by
operators of the language.


<H2 id="type AnyBoolean"> The type <code>AnyBoolean</code> </h2>

<P><span class="pcounter"></span> The type <code>AnyBoolean</code> is a union containing all the built-in
boolean types.  By standard subtyping rules it also includes all
claases that extend <code>Boolean</code>.

<PRE>
__ES4__ type AnyBoolean = (boolean,Boolean!);
</PRE>


<H1 id="class Boolean"> The class <code>Boolean</code> </h1>

<P><span class="pcounter"></span> The class <code>Boolean</code> is a dynamic, nullable, non-final subclass
of <code>Object</code> that holds a boolean value in the form of a <code>boolean</code>
object.  Instances of <code>Boolean</code> are converted to <code>boolean</code> when
operated upon by operators of the language.

<P><span class="pcounter"></span> The class <code>Boolean</code> can be extended and the extending classes
can provide novel representations for boolean values.


<h2>Synopsis</h2>

<P><span class="pcounter"></span> The class <code>Boolean</code> provides the following interface:

<PRE>
dynamic class Boolean
{
    function Boolean(x=false) &#x0085
    meta static function invoke(x=false) : boolean &#x0085

    static const length: uint = 1

    override intrinsic function toString() : string &#x0085
    override intrinsic function toJSONString(pretty: boolean=false) : string &#x0085
    override intrinsic function valueOf() : boolean &#x0085
}
</PRE>

<P><span class="pcounter"></span> The <code>Boolean</code> prototype object provides the following direct properties:

<PRE>
    toString: function (this: Booleans) &#x0085;
    valueOf:  function (this: Booleans) &#x0085;
</PRE>

<P><span class="pcounter"></span> The <code>Boolean</code> prototype object is also the prototype object of
the class <code>boolean</code>.

<h2>Methods on the <code>Boolean</code> class object</h2>

<h3>new&nbsp;Boolean&nbsp;(&nbsp;value=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The <code>Boolean</code> constructor intializes a new <code>Boolean</code> object
by storing <i>value</i>, converted to <code>boolean</code>, in a private property.
The default <i>value</i> is <b>false</b>.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span> The <code>Boolean</code> constructor is implementation-defined.

<h3>Boolean(&nbsp;value=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The <code>Boolean</code> class object called as a function converts
<i>value</i> to <code>boolean</code> (not <code>Boolean</code>).

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>boolean</code> class object called as a function returns a
<code>boolean</code> object.

<P class="implsection"><b>Implementation</b>
<PRE>
meta static function invoke(x=false) : boolean
    boolean(x);
</PRE>

<h2>Methods on <code>Boolean</code> instances</h2>

<h3>intrinsic::toString&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toString</code> method converts this boolean value
to a string.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>toString</code> method returns a string.

<P class="implsection"><b>Implementation</b>
<PRE>
override intrinsic function toString() : string
    intrinsic::valueOf().intrinsic::toString();
</PRE>

<h3>toJSONString</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toJSONString</code> method convert this boolean
object to JSON format (<CITE ref="RFC4627">RFC 4627</CITE>).

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>toJSONString</code> method returns a <code>string</code>.

<P class="implsection"><b>Implementation</b>
<PRE>
override intrinsic function toJSONString(pretty: boolean=false) : string
    intrinsic::valueOf().intrinsic::toJSONString();
</PRE>

<h3>intrinsic::valueOf&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>valueOf</code> method returns this boolean value.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>valueOf</code> method returns a <code>boolean</code> object
(not a <code>Boolean</code> object).

<P class="implsection"><b>Implementation</b>
<PRE>
override intrinsic function valueOf() : boolean
    boolean(this);
</PRE>

<h2>Methods on the <code>Boolean</code> prototype object</h2>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The methods on the <code>Boolean</code> prototype object invoke their
intrinsic counterparts.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The methods on the <code>Boolean</code> prototype object return what their
intrinsic counterparts return.

<P class="implsection"><b>Implementation</b>
<PRE>
prototype function toString(this: AnyBoolean)
    this.intrinsic::toString();

prototype function toJSONString(this: AnyBoolean, pretty=false)
    this.intrinsic::toJSONString(pretty);

prototype function valueOf(this: AnyBoolean)
    this.intrinsic::valueOf();


</PRE>


<H1 id="class boolean"> The class <code>boolean</code> </h1>

<P><span class="pcounter"></span> The class <code>boolean</code> is a non-dynamic, non-nullable, final
subclass of <code>Object</code>.  It represents a boolean value (<b>true</b> or
<b>false</b>).

<p class="note"><b>COMPATIBILITY NOTE</b>&nbsp;&nbsp;  The class <code>boolean</code> is new in the 4th Edition of this
Standard, but <code>boolean</code> models the "boolean values" in the 3rd
Edition.

<h2>Synopsis</h2>

<P><span class="pcounter"></span> The class <code>boolean</code> provides the following interface:

<PRE>
final class boolean!
{
    function boolean(x=null) &#x0085
    meta static function invoke(x=null) : boolean &#x0085

    static const length: uint = 1

    override intrinsic function toString() : string &#x0085
    override intrinsic function toJSONString(pretty: boolean=null) : string &#x0085
    override intrinsic function valueOf() : boolean &#x0085
}
</PRE>

<P><span class="pcounter"></span> The <code>boolean</code> prototype object is the same as the <code>Boolean</code>
prototype object (<span class="xref">Boolean.prototype</span>).

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #180.)  Why are the default values to the
constructor/converter null and not false?  Bootstrapping issue in the
reference implementation?


<h2>Methods on the <code>boolean</code> class object</h2>

<h3>new&nbsp;boolean&nbsp;(&nbsp;value=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The <code>boolean</code> constructor intializes a new <code>boolean</code> object
by storing an implementation-dependent representation of the truth
value of <i>value</i>, as computed by <code>ToBoolean</code>, in a private
property.  The default <i>value</i> is <b>false</b>.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span> The <code>boolean</code> constructor is implementation-defined.

<h3>boolean(&nbsp;value=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The <code>boolean</code> class object called as a function converts
<i>value</i> to <code>boolean</code>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>boolean</code> class object called as a function returns a
<code>boolean</code> object.

<P class="implsection"><b>Implementation</b>
<PRE>
meta static function invoke(x=null) : boolean
    x is boolean ? x : new boolean(x);
</PRE>

<h2>Methods on <code>boolean</code> instances</h2>

<h3>intrinsic::toString&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toString</code> method converts this boolean value
to a string, either <code>"true"</code> or <code>"false"</code>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>toString</code> method returns the string.

<P class="implsection"><b>Implementation</b>
<PRE>
override intrinsic function toString() : string
    this ? "true" : "false";
</PRE>

<h3>toJSONString</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toJSONString</code> method convert this boolean
object to JSON format (<CITE ref="RFC4627">RFC 4627</CITE>).

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>toJSONString</code> method returns a <code>string</code>.

<P class="implsection"><b>Implementation</b>
<PRE>
override intrinsic function toJSONString(pretty: boolean=false) : string
    intrinsic::valueOf().intrinsic::toJSONString();
</PRE>

<h3>intrinsic::valueOf&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>valueOf</code> method returns a <code>boolean</code> instance:
the object on which the method was invoked.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>valueOf</code> method returns its <code>this</code> object.

<P class="implsection"><b>Implementation</b>
<PRE>
override intrinsic function valueOf() : boolean
    this;
</PRE>


<h1>Number classes</h1>

<pre>
FILE:                       spec/library/Number.html
DRAFT STATUS:               DRAFT 1 - ROUGH - 2007-09-20
REVIEWED AGAINST ES3:       NO
REVIEWED AGAINST ERRATA:    NO
REVIEWED AGAINST BASE DOC:  NO
REVIEWED AGAINST PROPOSALS: NO
REVIEWED AGAINST CODE:      NO
</pre>

<P><span class="pcounter"></span> ECMAScript provides a variety of primitive number representations.
They are primitive in the sense that these are the representations
directly operated upon by the operators of the language, and also in
the sense that they are represented by final non-dynamic classes for
which ECMAScript implementations may provide efficient
representations.

<P><span class="pcounter"></span> The class <code>int</code> represents signed 32-bit integer values in the
range -2<sup>31</sup> to 2<sup>31</sup>-1 inclusive.

<P><span class="pcounter"></span> The class <code>uint</code> represents unsigned 32-bit integer values in
the range 0 to 2<sup>32</sup>-1 inclusive.

<P><span class="pcounter"></span> The class <code>double</code> represents 64-bit IEEE-format binary floating
point numbers approximately in the range -1.7976931348623157 &#x00D7;
10<SUP>308</SUP> to +1.7976931348623157 &#x00D7; 10<SUP>308</SUP>.

<P><span class="pcounter"></span> The class <code>decimal</code> represents 128-bit IEEE-format decimal
floating point numbers in the range
<NOBR>-(10<SUP>34</SUP>-1) &#x00D7; 10<SUP>6111</SUP></NOBR> to
<NOBR>(10<SUP>34</SUP>-1) &#x00D7; 10<SUP>6111</SUP></NOBR>.

<p class="note"><b>COMPATIBILITY NOTE</b>&nbsp;&nbsp;  The 3rd Edition of this Standard provided only one kind of
primitive number value, represented as 64-bit IEEE-format binary
floating point.

<P><span class="pcounter"></span> ECMAScript also provides the class <code>Number</code>, which is a dynamic
non-final class that represents 64-bit IEEE-format binary floating
point numbers.  Instances of <code>Number</code> are converted to
<code>double</code> when operated upon by the operators ofthe language.


<H2 id="type AnyNumber"> The type <code>AnyNumber</code> </h2>

<P><span class="pcounter"></span> The type <code>AnyNumber</code> is a union type that contains all the number
types in the language.

<PRE>
__ES4__ type AnyNumber = (byte, int, uint, double, decimal, Number!);
</PRE>

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #181.)  The type <code>Numeric</code> should instead be called
<code>Numbers</code>.


<H1 id="class Number"> The class <code>Number</code> </h1>

<P><span class="pcounter"></span> The class <code>Number</code> is a dynamic, nullable, non-final direct
subclass of <code>Object</code> that holds a <code>double</code> value.  Instances of
<code>Number</code> are converted to <code>double</code> when operated upon by the
operators of the language.

<P><span class="pcounter"></span> All intrinsic methods of <code>Number</code> obtain the number value stored
in the object by calling the intrinsic <code>valueOf</code> method.  If the
class <code>Number</code> is extended then the extending class can override the
intrinsic <code>valueOf</code> method in order to provide new ways of
representing the number value stored in the class.

<P><span class="pcounter"></span> The intrinsic <code>valueOf</code> method is not constrained to return a
<code>double</code> value, it can return any primitive number type.

<h2>Synopsis</h2>

<P><span class="pcounter"></span> The class <code>Number</code> provides the following interface:

<PRE>
dynamic class Number
{
    function Number(value=0d) &#x0085
    meta static function invoke(value=0d) &#x0085
    
    static const MAX_VALUE: double = double.MAX_VALUE
    static const MIN_VALUE: double = double.MIN_VALUE
    static const NaN: double = double.NAN
    static const NEGATIVE_INFINITY: double = double.NEGATIVE_INFINITY
    static const POSITIVE_INFINITY: double = double.POSITIVE_INFINITY
    static const length: uint = 1

    override intrinsic function toString(radix = 10) : string &#x0085
    override intrinsic function toLocaleString() : string &#x0085
    override intrinsic function toJSONString(pretty: boolean=false) : string &#x0085
    override intrinsic function valueOf(): (int,uint,double,decimal) &#x0085

    intrinsic function toFixed(fractionDigits=0): string &#x0085
    intrinsic function toExponential(fractionDigits=undefined) : string &#x0085
    intrinsic function toPrecision(precision=undefined) : string &#x0085
}
</PRE>

<P><span class="pcounter"></span> The <code>Number</code> prototype object provides these direct properties:

<PRE>
    toString:       function (this: Numeric, radix) &#x0085;
    toLocaleString: function (this: Numeric) &#x0085;
    toJSONString:   function (this: Numeric, pretty=false) &#x0085;
    valueOf:        function (this: Numeric) &#x0085;
    toFixed:        function (this: Numeric, fractionDigits) &#x0085;
    toExponential:  function (this: Numeric, fractionDigits) &#x0085;
    toPrecision:    function (this: Numeric, precision) &#x0085;
</PRE>


<h2>Methods on the <code>Number</code> class object</h2>

<h3>new&nbsp;Number(&nbsp;value=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span>The <code>Number</code> constructor initialises the newly created
<code>Number</code> object by storing <i>value</i> (which defaults to +0),
converted to <code>double</code>, in a private property.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span>
The <code>Number</code> constructor is implementation-defined.

<h3>Number(&nbsp;value=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> When the <code>Number</code> class object is called as a function it
performs a type conversion: if <i>value</i> (which defaults to +0) is not
a primitive number type it is converted to <code>double</code>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>Number</code> class object called as a function returns
<i>value</i> converted to a primitive number type.

<P class="implsection"><b>Implementation</b>
<PRE>
meta static function invoke(value=0d) {
    if (value is (int,uint,double,decimal,Number))
        return value;
    return double(value);
}
</PRE>

<h2>Value properties on the <code>Number</code> class object</h2>

<h3>MAX_VALUE</h3>

<P><span class="pcounter"></span> The value of <code>MAX_VALUE</code> is the largest positive finite value
represented by the <code>double</code> class.

<h3>MIN_VALUE</h3>

<P><span class="pcounter"></span> The value of <code>MIN_VALUE</code> is the smallest positive value
represented by the <code>double</code> class.

<h3>NaN</h3>

<P><span class="pcounter"></span> The value of <code>NaN</code> is the not-a-number value represented by the
<code>double</code> class.

<h3>NEGATIVE_INFINITY</h3>

<P><span class="pcounter"></span> The value of <code>NEGATIVE_INFINITY</code> is the value -&#x221E; as
represented by a <code>double</code> object.

<h3>POSITIVE_INFINITY</h3>

<P><span class="pcounter"></span> The value of <code>POSITIVE_INFINITY</code> is the value +&#x221E; as
represented by a <code>double</code> object.


<h2>Methods on <code>Number</code> instances</h2>


<h3>intrinsic::toString&nbsp;(&nbsp;radix=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toString</code> method converts this number value to a string representation
in a base given by <i>radix</i>.

<P><span class="pcounter"></span> If radix is the number 10 or undefined, then the result is as for the <code>ToString</code> operator.

<P><span class="pcounter"></span> If radix is an integer from 2 to 36, but not 10, the result is an implementation-dependent string

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>toString</code> method returns a string.

<P class="implsection"><b>Implementation</b>
<PRE>
override intrinsic function toString(radix = 10) : string
    intrinsic::valueOf().intrinsic::toString(radix);
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The intrinsic <code>toString</code> method operates by obtaining a
primitive number value, which it then converts to string by invoking
the intrinsic <code>toString</code> method on the primitive value.

<h3>toJSONString</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toJSONString</code> method convert this number object
to JSON format (<CITE ref="RFC4627">RFC 4627</CITE>).

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>toJSONString</code> method returns a <code>string</code>.

<P class="implsection"><b>Implementation</b>
<PRE>
override intrinsic function toJSONString(pretty: boolean=false) : string
    intrinsic::valueOf().intrinsic::toJSONString(pretty);
</PRE>


<h3>intrinsic::toLocaleString&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toLocaleString</code> method converts this number
value to a string value that represents the number value formatted
according to the conventions of the host environment's current locale.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>toLocaleString</code> method returns an
implementation-dependent string.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span> The intrinsic <code>toLocaleString</code> method is
implementation-dependent, and it is permissible, but not encouraged,
for it to return the same thing as the intrinsic <code>toString</code> method.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The first parameter to this function is likely to be used in a
future version of this standard; it is recommended that
implementations do not use this parameter position for anything else.


<h3>intrinsic::valueOf&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>valueOf</code> method returns the number value
represented by this <code>Number</code> object.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>valueOf</code> method returns a primitive number value.

<P class="implsection"><b>Implementation</b>
<PRE>
override intrinsic function valueOf(): (int,uint,double,decimal)
    double(this);
</PRE>


<h3>Intrinsic methods that delegate to methods on primitive types</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toFixed</code>, <code>toExponential</code>, and
<code>toPrecision</code> methods operate by obtaining a primitive number value
from the intrinsic <code>valueOf</code> method, then invoking the appropriate
method on the primitive value.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>toFixed</code>, <code>toExponential</code>, and
<code>toPrecision</code> methods return what their delegates return.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function toFixed(fractionDigits=0): string
    intrinsic::valueOf().intrinsic::toFixed(fractionDigits);

intrinsic function toExponential(fractionDigits=undefined) : string
    intrinsic::valueOf().intrinsic::toExponential(fractionDigits);

intrinsic function toPrecision(precision=undefined) : string
    intrinsic::valueOf().intrinsic::toPrecision(precision);
</PRE>

<h2>Methods on the <code>Number</code> prototype object</h2>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The methods on the <code>Number</code> prototype object are constrained to
being invoked on members of the type <code>Numeric</code>.  All operate by
calling the corresponding intrinsic method on the <code>this</code> object.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The <code>Number</code> prototype object is also the prototype object
for <code>int</code>, <code>uint</code>, <code>double</code>, and <code>decimal</code>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The methods on the <code>Number</code> prototype object return what
their corresponding intrinsic methods return.

<P class="implsection"><b>Implementation</b>
<PRE>
prototype function toString(this: AnyNumber, radix=10)
    this.intrinsic::toString(radix);

prototype function toLocaleString(this: AnyNumber)
    this.intrinsic::toLocaleString();

prototype function toJSONString(this: AnyNumber, pretty=false)
    this.intrinsic::toJSONString(pretty);

prototype function valueOf(this: AnyNumber)
    this.intrinsic::valueOf();

prototype function toFixed(this:AnyNumber, fractionDigits)
    this.intrinsic::toFixed(fractionDigits);

prototype function toExponential(this: AnyNumber, fractionDigits)
    this.intrinsic::toExponential(fractionDigits);

prototype function toPrecision(this: AnyNumber, precision)
    this.intrinsic::toPrecision(precision);


</PRE>



<H1 id="class int"> The class <code>int</code> </h1>

<pre>
FILE:                       spec/library/int.html
DRAFT STATUS:               DRAFT 1 - ROUGH - 2007-09-20
REVIEWED AGAINST ES3:       NO
REVIEWED AGAINST ERRATA:    NO
REVIEWED AGAINST BASE DOC:  NO
REVIEWED AGAINST PROPOSALS: NO
REVIEWED AGAINST CODE:      NO
</pre>


<P><span class="pcounter"></span> The class <code>int</code> is a final, non-nullable, non-dynamic direct
subclass of <code>Object</code> that represents two's complement signed 32-bit
integer values in the range -2<sup>31</sup> to 2<sup>31</sup>-1
inclusive.

<p class="note"><b>COMPATIBILITY NOTE</b>&nbsp;&nbsp;  The class <code>int</code> is new in the 4th Edition of this Standard.

<h2>Synopsis</h2>

<P><span class="pcounter"></span> The class <code>int</code> provides the following interface:

<PRE>
final class int!
{
    function int(x=0i) &#x0085
    meta static function invoke(x=0) &#x0085
    
    static const MAX_VALUE: int = 0x7FFFFFFF
    static const MIN_VALUE: int = -0x80000000
    static const length: uint = 1

    override intrinsic function toString(radix = 10) : string &#x0085
    override intrinsic function toLocaleString() : string &#x0085
    override intrinsic function toJSONString(pretty: boolean=false) : string &#x0085
    override intrinsic function valueOf(): int &#x0085

    intrinsic function toFixed(fractionDigits=0) : string &#x0085
    intrinsic function toExponential(fractionDigits=undefined) : string &#x0085
    intrinsic function toPrecision(precision=undefined) : string &#x0085
}
</PRE>

<P><span class="pcounter"></span> The <code>int</code> prototype object is identical to the <code>Number</code>
prototype object (<span class="xref">Number.prototype</span>).

<h2>Methods on the <code>int</code> class object</h2>

<h3>new&nbsp;int(&nbsp;value=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The <code>int</code> constructor it initialises the newly created
<code>int</code> object by storing an implementation-defined representation of
the integer value of <i>value</i>, as computed by the <code>ToInt32</code>
operator, in a private property.  The default <i>value</i> is 0.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span> The <code>int</code> constructor is implementation-defined.

<h3>int(&nbsp;value=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> When the <code>int</code> class object is called as a function it
performs a type conversion: it converts <i>value</i> (which defaults
to 0) to <code>int</code>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>int</code> class object called as a function returns an
<code>int</code>.

<P class="implsection"><b>Implementation</b>
<PRE>
meta static function invoke(x=0)
    x is int ? x : magic::newInt(x);
</PRE>

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #176.)  It would be less confusing if the converter
used <code>new int</code> instead of <code>newInt</code> here.

<h2>Value properties on the <code>int</code> class object</h2>

<h3>MAX_VALUE</h3>

<P><span class="pcounter"></span> The value of <code>MAX_VALUE</code> is the largest positive integer value
represented by the <code>int</code> class.  Its value is 2<SUP>31</SUP>-1.

<h3>MIN_VALUE</h3>

<P><span class="pcounter"></span> The value of <code>MIN_VALUE</code> is the smallest negative value
represented by the <code>int</code> class.  Its value is -2<SUP>31</SUP>.

<h2>Methods on <code>int</code> instances</h2>

<h3>intrinsic::toString&nbsp;(&nbsp;radix=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toString</code> method converts this integer value
to a string representation in a base given by <i>radix</i>.

<P><span class="pcounter"></span> If radix is the number 10 or undefined, then the result is as for
the <code>ToString</code> operator.

<P><span class="pcounter"></span> If radix is an integer from 2 to 36, but not 10, the result is an
implementation-dependent string

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>toString</code> method returns a <code>string</code>.

<P class="implsection"><b>Implementation</b>
<PRE>
override intrinsic function toString(radix = 10) : string {
    if (radix === 10 || radix === undefined)
        return string(this);
    if (radix is AnyNumber && radix >= 2 && radix &#60;= 36 && isIntegral(radix))
        return informative::toString(int(radix));
    throw new TypeError("Invalid radix argument to int.toString");
}
</PRE>

<h3>intrinsic::toLocaleString&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toLocaleString</code> method converts this integer
value to a string value that represents the value of the integer
formatted according to the conventions of the host environment's
current locale.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>toLocaleString</code> method returns an
implementation-dependent string.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span> The intrinsic <code>toLocaleString</code> method is
implementation-dependent, and it is permissible, but not encouraged,
for it to return the same thing as the intrinsic <code>toString</code> method.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The first parameter to this function is likely to be used in a
future version of this standard; it is recommended that
implementations do not use this parameter position for anything else.

<h3>toJSONString</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toJSONString</code> method convert this <code>int</code>
object to JSON format (<CITE ref="RFC4627">RFC 4627</CITE>).

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>toJSONString</code> method returns a <code>string</code>.

<P class="implsection"><b>Implementation</b>
<PRE>
override intrinsic function toJSONString(pretty: boolean=false) : string
    JSON.formatNumber(this, pretty);
</PRE>

<h3>intrinsic::valueOf&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>valueOf</code> method returns the integer value
represented by this <code>int</code> object: the object itself.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>valueOf</code> method returns its <code>this</code> object.

<P class="implsection"><b>Implementation</b>
<PRE>
override intrinsic function valueOf(): int
    this;
</PRE>


<h3>intrinsic::toFixed&nbsp;(&nbsp;fractionDigits=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toFixed</code> method converts the this number value
to a string in fixed-point notation with <i>fractionDigits</i> digits
after the decimal point.  If <i>fractionDigits</i> is <b>undefined</b>, 0
is assumed.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>toFixed</code> method returns the fixed-point
notation string representation of this number value.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function toFixed(fractionDigits=0) : string
    double(this).intrinsic::toFixed(fractionDigits);
</PRE>


<h3>intrinsic::toExponential&nbsp;(&nbsp;fractionDigits=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toExponential</code> method converts this number value
to a string in exponential notation with one digit before the
significand's decimal point and <i>fractionDigits</i> digits after the
significand's decimal point.  If <i>fractionDigits</i> is <b>undefined</b>,
include as many significand digits as necessary to uniquely specify
the number (just like in <code>ToString</code> except that in this case the
number is always output in exponential notation).

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>toExponential</code> method returns the exponential
notation string representation of this number value.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function toExponential(fractionDigits=undefined) : string
    double(this).intrinsic::toExponential(fractionDigits);
</PRE>

<h3>intrinsic::toPrecision&nbsp;(&nbsp;precision=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toPrecision</code> method converts this number value
to a string, either in exponential notation with one digit before the
significand's decimal point and <i>precision</i>-1 digits after the
significand's decimal point or in fixed notation with <i>precision</i>
significant digits.  If precision is <b>undefined</b>, call <code>ToString</code>
(<span class="xref">Operator:ToString</span>) instead.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>toPrecision</code> method returns the selected string
representation of this number value.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function toPrecision(precision=undefined) : string
    double(this).intrinsic::toPrecision(precision);
</PRE>



<H1 id="class int"> The class <code>uint</code> </h1>

<pre>
FILE:                       spec/library/uint.html
DRAFT STATUS:               DRAFT 1 - ROUGH - 2007-09-20
REVIEWED AGAINST ES3:       NO
REVIEWED AGAINST ERRATA:    NO
REVIEWED AGAINST BASE DOC:  NO
REVIEWED AGAINST PROPOSALS: NO
REVIEWED AGAINST CODE:      NO
</pre>


<P><span class="pcounter"></span> The class <code>uint</code> is a final, non-nullable, non-dynamic class
that represents unsigned 32-bit integer values in the range 0 to
2<sup>32</sup>-1 inclusive.

<p class="note"><b>COMPATIBILITY NOTE</b>&nbsp;&nbsp;  The class <code>uint</code> is new in the 4th Edition of this Standard.

<h2>Synopsis</h2>

<P><span class="pcounter"></span> The class <code>uint</code> provides the following interface:

<PRE>
final class uint!
{
    function uint(x=0u) &#x0085
    meta static function invoke(x=0u) &#x0085
    
    static const MAX_VALUE: uint = 0xFFFFFFFF
    static const MIN_VALUE: uint = 0
    static const length: uint = 1

    override intrinsic function toString(radix=10) &#x0085
    override intrinsic function toLocaleString() : string &#x0085
    override intrinsic function toJSONString(pretty: boolean=false) : string &#x0085
    override intrinsic function valueOf(): uint &#x0085

    intrinsic function toFixed(fractionDigits=0) : string &#x0085
    intrinsic function toExponential(fractionDigits=undefined) : string &#x0085
    intrinsic function toPrecision(precision=undefined) : string &#x0085
}
</PRE>

<P><span class="pcounter"></span> The <code>uint</code> prototype object is identical to the <code>Number</code>
prototype object (<span class="xref">Number.prototype</span>).

<h2>Methods on the <code>uint</code> class object</h2>

<h3>new&nbsp;uint(&nbsp;value=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span>The <code>uint</code> constructor initialises the newly created <code>uint</code>
object by storing an implementation-dependent representation of the
unsigned integer value of <i>value</i>, converted to <code>uint</code> by the
<code>ToUint32</code> operator, in a private property.  The default <i>value</i>
is 0.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span> The <code>uint</code> constructor is implementation-dependent.

<h3>uint(&nbsp;value=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> When the <code>uint</code> class object is called as a function it
performs a type conversion: it converts <i>value</i> (which defaults to
0) to <code>uint</code>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>uint</code> class object called as a function returns
<i>value</i> converted to <code>uint</code>.

<P class="implsection"><b>Implementation</b>
<PRE>
meta static function invoke(x=0u)
    x is uint ? x : magic::newUInt(x);
</PRE>

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #176.) The optimization here, using <code>newUInt</code>, is more confusing
than <code>new uint</code> would have been.

<h2>Value properties on the <code>uint</code> class object</h2>

<h3>MAX_VALUE</h3>

<P><span class="pcounter"></span> The value of <code>MAX_VALUE</code> is the largest positive integer value
represented by the <code>uint</code> class.  Its value is 2<SUP>32</SUP>-1.

<h3>MIN_VALUE</h3>

<P><span class="pcounter"></span> The value of <code>MIN_VALUE</code> is the smallest value
represented by the <code>uint</code> class.  Its value is 0.


<h2>Methods on <code>uint</code> instances</h2>

<h3>intrinsic::toString&nbsp;(&nbsp;radix=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toString</code> method converts this unsigned integer value
to a string representation in a base given by <i>radix</i>.

<P><span class="pcounter"></span> If radix is the number 10 or undefined, then the result is as for
the <code>ToString</code> operator.

<P><span class="pcounter"></span> If radix is an integer from 2 to 36, but not 10, the result is an
implementation-dependent string

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>toString</code> method returns a string.

<P class="implsection"><b>Implementation</b>
<PRE>
override intrinsic function toString(radix=10) {
    if (radix === 10 || radix === undefined)
        return string(this);
    if (radix is AnyNumber && radix >= 2 && radix &#60;= 36 && isIntegral(radix)) {
        radix = int(radix);
        let v = this;
        var q = "";
        while (v != 0) {
            q = "0123456789abcdefABCDEFGHIJKLMNOPQRSTUVWXYZ"[v % radix] + q;
            v = (v - (v % radix)) / radix;
        }
        if (q == "")
            q = "0";
        return q;
    }
    throw new TypeError("Invalid radix argument to uint.toString");
}
</PRE>

<h3>intrinsic::toLocaleString&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toLocaleString</code> method converts this unsigned
integer value to a string value that represents the value of the
unsigned integer formatted according to the conventions of the host
environment's current locale.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>toLocaleString</code> method returns an
implementation-dependent string.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span> The intrinsic <code>toLocaleString</code> method is
implementation-dependent, and it is permissible, but not encouraged,
for it to return the same thing as the intrinsic <code>toString</code> method.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The first parameter to this function is likely to be used in a
future version of this standard; it is recommended that
implementations do not use this parameter position for anything else.

<h3>toJSONString</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toJSONString</code> method convert this <code>uint</code>
object to JSON format (<CITE ref="RFC4627">RFC 4627</CITE>).

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>toJSONString</code> method returns a <code>string</code>.

<P class="implsection"><b>Implementation</b>
<PRE>
override intrinsic function toJSONString(pretty: boolean=false) : string
    JSON.formatNumber(this, pretty);
</PRE>


<h3>intrinsic::valueOf&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>valueOf</code> method returns the integer value
represented by this <code>uint</code> object: the object itself.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>valueOf</code> method returns its <code>this</code> object.

<P class="implsection"><b>Implementation</b>
<PRE>
override intrinsic function valueOf(): uint
    this;
</PRE>


<h3>intrinsic::toFixed&nbsp;(&nbsp;fractionDigits=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toFixed</code> method converts the this number value
to a string in fixed-point notation with <i>fractionDigits</i> digits
after the decimal point.  If <i>fractionDigits</i> is <b>undefined</b>, 0
is assumed.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>toFixed</code> method returns the fixed-point
notation string representation of this number value.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function toFixed(fractionDigits=0) : string
    double(this).intrinsic::toFixed(fractionDigits);
</PRE>


<h3>intrinsic::toExponential&nbsp;(&nbsp;fractionDigits=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toExponential</code> method converts this number value
to a string in exponential notation with one digit before the
significand's decimal point and <i>fractionDigits</i> digits after the
significand's decimal point.  If <i>fractionDigits</i> is <b>undefined</b>,
include as many significand digits as necessary to uniquely specify
the number (just like in <code>ToString</code> except that in this case the
number is always output in exponential notation).

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>toExponential</code> method returns the exponential
notation string representation of this number value.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function toExponential(fractionDigits=undefined) : string
    double(this).intrinsic::toExponential(fractionDigits);
</PRE>

<h3>intrinsic::toPrecision&nbsp;(&nbsp;precision=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toPrecision</code> method converts this number value
to a string, either in exponential notation with one digit before the
significand's decimal point and <i>precision</i>-1 digits after the
significand's decimal point or in fixed notation with <i>precision</i>
significant digits.  If precision is <b>undefined</b>, call <code>ToString</code>
(<span class="xref">Operator:ToString</span>) instead.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>toPrecision</code> method returns the selected string
representation of this number value.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function toPrecision(precision=undefined) : string
    double(this).intrinsic::toPrecision(precision);
</PRE>



<H1 id="class int"> The class <code>byte</code> </h1>

<pre>
FILE:                       spec/library/byte.html
DRAFT STATUS:               DRAFT 1 - VERY ROUGH - 2007-09-20
REVIEWED AGAINST ES3:       NO
REVIEWED AGAINST ERRATA:    NO
REVIEWED AGAINST BASE DOC:  NO
REVIEWED AGAINST PROPOSALS: NO
REVIEWED AGAINST CODE:      NO
</pre>


<P><span class="pcounter"></span> The class <code>byte</code> is a final, non-nullable, non-dynamic direct
subclass of <code>Object</code> that represents two's complement unsigned 8-bit
integer values in the range 0 to 255 inclusive.

<P><span class="pcounter"></span> The class <code>byte</code> is unusual in that it cannot be instantiated;
byte values are always represented as <code>uint</code> in computations.
Instead, <code>byte</code> is intended to be used as an annotation on variables
and as the element type of <code>Vector</code>.  Used as an annotation it
causes the truncation of other number values to the <code>byte</code> range,
and used as the element type in <code>Vector</code> some implementations will
store byte data efficiently.

<p class="note"><b>COMPATIBILITY NOTE</b>&nbsp;&nbsp;  The class <code>byte</code> is new in the 4th Edition of this Standard.

<h2>Synopsis</h2>

<P><span class="pcounter"></span> The class <code>byte</code> provides the following interface:

<PRE>
final class byte!
{
    meta static function invoke(x=0) &#x0085
    
    static const MAX_VALUE: byte = 255
    static const MIN_VALUE: byte = 0
    static const length: uint = 1
}
</PRE>

<P><span class="pcounter"></span> The <code>byte</code> class has no instance methods or variables, since no
instances are ever created.

<P><span class="pcounter"></span> The <code>byte</code> prototype object is identical to the <code>Number</code>
prototype object (<span class="xref">Number.prototype</span>).

<h2>Methods on the <code>byte</code> class object</h2>

<h3>int(&nbsp;value=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> When the <code>byte</code> class object is called as a function it
performs a type conversion: it converts <i>value</i> (which defaults
to 0) to an unsigned integer.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>byte</code> class object called as a function returns a
<code>uint</code>.

<P class="implsection"><b>Implementation</b>
<PRE>
meta static function invoke(x=0u)
    x is byte ? x : magic::newByte(x);
</PRE>

<h2>Value properties on the <code>int</code> class object</h2>

<h3>MAX_VALUE</h3>

<P><span class="pcounter"></span> The value of <code>MAX_VALUE</code> is the largest positive integer value
represented by the <code>byte</code> class.  Its value is 2<SUP>8</SUP>-1.

<h3>MIN_VALUE</h3>

<P><span class="pcounter"></span> The value of <code>MIN_VALUE</code> is the smallest value
represented by the <code>int</code> class.  Its value is 0.



<H1 id="class double"> The class <code>double</code> </h1>

<pre>
FILE:                       spec/library/double.html
DRAFT STATUS:               DRAFT 1 - ROUGH - 2007-09-20
REVIEWED AGAINST ES3:       NO
REVIEWED AGAINST ERRATA:    NO
REVIEWED AGAINST BASE DOC:  NO
REVIEWED AGAINST PROPOSALS: NO
REVIEWED AGAINST CODE:      NO
</pre>


<P><span class="pcounter"></span> The class <code>double</code> is a final, non-nullable, non-dynamic direct
subclass of <code>Object</code> that represents 64-bit ("double precision")
IEEE binary floating point number values in the range
-(1-(1/2)<SUP>53</SUP>) &#x00D7; 2<SUP>1024</SUP> to
+(1-(1/2)<SUP>53</SUP>) &#x00D7; 2<SUP>1024</SUP> inclusive
(approximately the range -1.7976931348623157 &#x00D7; 10<SUP>308</SUP>
to +1.7976931348623157 &#x00D7; 10<SUP>308</SUP>, inclusive), plus the
three special values -&#x221E;, +&#x221E;, and NaN.

<p class="note"><b>COMPATIBILITY NOTE</b>&nbsp;&nbsp;  The class <code>double</code> is new in the 4th Edition of this
Standard, but <code>double</code> models the "number values" in the 3rd
Edition.


<h2>Synopsis</h2>

<P><span class="pcounter"></span> The class <code>double</code> provides the following interface:

<PRE>
final class double!
{
    function double(x=0d) &#x0085
    meta static function invoke(x=0d) &#x0085
    
    static const MAX_VALUE: double = &#x0085;
    static const MIN_VALUE: double = &#x0085;
    static const NaN: double = &#x0085;
    static const NEGATIVE_INFINITY: double = &#x0085;
    static const POSITIVE_INFINITY: double = &#x0085;
    static const E: double = &#x0085;
    static const LN10: double = &#x0085;
    static const LN2: double = &#x0085;
    static const LOG2E: double = &#x0085;
    static const LOG10E: double = &#x0085;
    static const PI: double = &#x0085;
    static const SQRT1_2: double = &#x0085;
    static const SQRT2: double = &#x0085;
    static const length: uint = 1

    override intrinsic function toString(radix = 10) : string &#x0085
    override intrinsic function toLocaleString() : string &#x0085
    override intrinsic function toJSONString(pretty: boolean=false) : string &#x0085
    override intrinsic function valueOf() : double &#x0085

    intrinsic function toFixed(fractionDigits=0) : string &#x0085
    intrinsic function toExponential(fractionDigits=undefined) : string &#x0085
    intrinsic function toPrecision(precision=undefined) : string &#x0085
}
</PRE>

<P><span class="pcounter"></span> The <code>double</code> prototype object is identical to the <code>Number</code>
prototype object (<span class="xref">Number.prototype</span>).

<h2>Methods on the <code>double</code> class object</h2>

<h3>new&nbsp;double(&nbsp;value=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span>The <code>double</code> constructor initialises the newly created
<code>double</code> object by storing an implementation-dependent
representation of the double-precision value of <i>value</i>, converted
to a number by the ToNumber operator, in a private property.  The
default <i>value</i> is 0.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span> The <code>double</code> constructor is implementation-dependent.

<h3>double(&nbsp;value=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> When the <code>double</code> class object is called as a function it
performs a type conversion: it converts <i>value</i> (which defaults
to +0) to <code>double</code>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>double</code> class object called as a function returns
<i>value</i> converted to <code>double</code>.

<P class="implsection"><b>Implementation</b>
<PRE>
meta static function invoke(x=0d)
    x is double ? x : magic::newDouble(x);
</PRE>

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #176.)  The optimization used here, <code>magic::newDouble</code> for <code>new
double</code>, makes the spec harder than it needs to be.

<h2>Value properties on the <code>double</code> class object</h2>

<h3>MAX_VALUE</h3>

<P><span class="pcounter"></span> The value of <code>MAX_VALUE</code> is the largest positive finite value
represented by the <code>double</code> class, type, which is
approximately 1.7976931348623157 &#x00D7; 10<SUP>308</SUP>.

<h3>MIN_VALUE</h3>

<P><span class="pcounter"></span> The value of <code>MIN_VALUE</code> is the smallest positive value
represented by the <code>double</code> class, which is approximately 5 &#x00D7;
10<SUP>-324</SUP>.

<h3>NaN</h3>

<P><span class="pcounter"></span> The value of <code>NaN</code> is the not-a-number value represented by a
<code>double</code> instance.

<h3>NEGATIVE_INFINITY</h3>

<P><span class="pcounter"></span> The value of <code>NEGATIVE_INFINITY</code> is the value -&#x221E; as
represented by a <code>double</code> instance.

<h3>POSITIVE_INFINITY</h3>

<P><span class="pcounter"></span> The value of <code>POSITIVE_INFINITY</code> is the value +&#x221E; as
represented by a <code>double</code> instance.

<h3>E</h3>

<P><span class="pcounter"></span> The value of <code>E</code> is the <code>double</code> value for <i>e</i>, the base of the
natural logarithms, which is approximately 2.7182818284590452354.

<h3>LN10</h3>

<P><span class="pcounter"></span>The value of <code>LN10</code> is the <code>double</code> value for the natural
logarithm of 10, which is approximately 2.302585092994046.

<h3>LN2</h3>

<P><span class="pcounter"></span>The value of <code>LN2</code> is the <code>double</code> value for the natural
logarithm of 2, which is approximately 0.6931471805599453.

<h3>LOG2E</h3>

<P><span class="pcounter"></span>The value of <code>LOG2E</code> is the <code>double</code> value for the base-2
logarithm of <i>e</i>, the base of the natural logarithms; this value is
approximately 1.4426950408889634.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The value of <code>double.LOG2E</code> is approximately the reciprocal
of the value of <code>double.LN2</code>.

<h3>LOG10E</h3>

<P><span class="pcounter"></span>The value of <code>LOG10E</code> is the double value for the base-10
logarithm of <i>e</i>, the base of the natural logarithms; this value is
approximately 0.4342944819032518.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The value of <code>double.LOG10E</code> is approximately the reciprocal
of the value of <code>double.LN10</code>.

<h3>PI</h3>

<P><span class="pcounter"></span>The value of <code>PI</code> is the <code>double</code> value for &#x03C0;, the ratio of
the circumference of a circle to its diameter, which is approximately
3.1415926535897932.

<h3>SQRT1_2</h3>

<P><span class="pcounter"></span>The value of <code>SQRT1_2</code> is the <code>double</code> value for the square
root of 1/2, which is approximately 0.7071067811865476.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The value of <code>double.SQRT1_2</code> is approximately the reciprocal
of the value of <code>double.SQRT2</code>.

<h3>SQRT2</h3>

<P><span class="pcounter"></span>The value of <code>SQRT2</code> is the <code>double</code> value for the square root
of 2, which is approximately 1.4142135623730951.


<h2>Methods on <code>double</code> instances</h2>

<h3>intrinsic::toString&nbsp;(&nbsp;radix=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toString</code> method converts this number value
to a string representation in a base given by <i>radix</i>.

<P><span class="pcounter"></span> If radix is the number 10 or undefined, then the result is as for
the <code>ToString</code> operator.

<P><span class="pcounter"></span> If radix is an integer from 2 to 36, but not 10, the result is an
implementation-dependent string

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>toString</code> method returns a string.

<P class="implsection"><b>Implementation</b>
<PRE>
override intrinsic function toString(radix = 10) : string {
    if (radix === 10 || radix === undefined)
        return string(this);
    if (radix is AnyNumber && radix >= 2 && radix &#60;= 36 && isIntegral(radix))
        return informative::toString(int(radix));
    throw new TypeError("Invalid radix argument to double.toString");
}
</PRE>


<h3>intrinsic::toLocaleString&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toLocaleString</code> method converts this number
value to a string value that represents the value of the integer
formatted according to the conventions of the host environment's
current locale.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>toLocaleString</code> method returns an
implementation-dependent string.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span> The intrinsic <code>toLocaleString</code> method is
implementation-dependent, and it is permissible, but not encouraged,
for it to return the same thing as the intrinsic <code>toString</code> method.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The first parameter to this function is likely to be used in a
future version of this standard; it is recommended that
implementations do not use this parameter position for anything else.

<h3>toJSONString</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toJSONString</code> method convert this <code>double</code>
object to JSON format (<CITE ref="RFC4627">RFC 4627</CITE>).

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>toJSONString</code> method returns a <code>string</code>.

<P class="implsection"><b>Implementation</b>
<PRE>
override intrinsic function toJSONString(pretty: boolean=false) : string
    JSON.formatNumber(this, pretty);
</PRE>


<h3>intrinsic::valueOf&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>valueOf</code> method returns the number value
represented by this <code>double</code> object: the object itself.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>valueOf</code> method returns its <code>this</code> object.

<P class="implsection"><b>Implementation</b>
<PRE>
override intrinsic function valueOf() : double
    this;
</PRE>


<h3>intrinsic::toFixed&nbsp;(&nbsp;fractionDigits=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toFixed</code> method converts the this number value
to a string in fixed-point notation with <i>fractionDigits</i> digits
after the decimal point.  If <i>fractionDigits</i> is <b>undefined</b>, 0
is assumed.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>toFixed</code> method returns the fixed-point
notation string representation of this number value.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function toFixed(fractionDigits=0) : string {
    let x = this;
    let f = helper::toInteger(fractionDigits);
    if (f &#60; 0 || f > 20)
        throw new RangeError();

    if (isNaN(x))
        return "NaN";
    let s = "";
    if (x &#60; 0) {
        s = "-";
        x = -x;
    }

    if (x >= Math.pow(10,21))
        return s + string(m);

    let n = toFixedStep10(x, f);
    let m = n == 0 ? "0" : string(n);
    if (f == 0)
        return s + m;
    let k = m.length;
    if (k &#60;= f) {
        m = "00000000000000000000".substring(0,f+1-k) + m;
        k = f+1;
    }
    return s + m.substring(0,k-f) + "." + m.substring(k-f);
}
</PRE>

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #184.) Note that calling anything "step 10" no longer
makes sense.

<p class="fixme"> Note also that "step 10" is informative and needs to
be documented and implemented as such.

<P><span class="pcounter"></span> An implementation is permitted to extend the behaviour of toFixed
for values of <i>fractionDigits</i> less than 0 or greater than 20.  In
this case <code>toFixed</code> would not necessarily throw <b>RangeError</b> for
such values.

<p class="note"><b>NOTE</b>&nbsp;&nbsp; The output of <code>toFixed</code> may be more precise than <code>toString</code>
for some values because <code>toString</code> only prints enough significant
digits to distinguish the number from adjacent number values. For
example, <code>(1000000000000000128).toString()</code> returns
"1000000000000000100", while <code>(1000000000000000128).toFixed(0)</code>
returns "1000000000000000128".


<h3>intrinsic::toExponential&nbsp;(&nbsp;fractionDigits=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toExponential</code> method converts this number value
to a string in exponential notation with one digit before the
significand's decimal point and <i>fractionDigits</i> digits after the
significand's decimal point.  If <i>fractionDigits</i> is <b>undefined</b>,
include as many significand digits as necessary to uniquely specify
the number (just like in <code>ToString</code> except that in this case the
number is always output in exponential notation).

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>toExponential</code> method returns the exponential
notation string representation of this number value.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function toExponential(fractionDigits=undefined) : string {
    return "**toExponential: FIXME**";
}
</PRE>

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #185.) Implement this function.

<P><span class="pcounter"></span>An implementation is permitted to extend the behaviour of
<code>toExponential</code> for values of <i>fractionDigits</i> less than 0 or
greater than 20.  In this case <code>toExponential</code> would not necessarily
throw <b>RangeError</b> for such values.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  For implementations that provide more accurate conversions than
required by the rules above, it is recommended that the following
alternative version of step 19 be used as a guideline:

<P class="note">Let e, n, and f be integers such that <i>f &#x2265; 0</i>,
<i>10<SUP>f</SUP> &#x2264; n < 10<SUP>f+1</SUP></i>, the number value for
<i>n &#x00D7; 10<SUP>e-f</SUP></i> is <i>x</i>, and <i>f</i> is as small as
possible.  If there are multiple possibilities for <i>n</i>, choose the
value of <i>n</i> for which <i>n &#x00D7; 10<SUP>e-f</SUP></i> is closest in
value to <i>x</i>.  If there are two such possible values of <i>n</i>,
choose the one that is even.

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #186.) "Step 19" is obsolete.

<h3>intrinsic::toPrecision&nbsp;(&nbsp;precision=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toPrecision</code> method converts this number value
to a string, either in exponential notation with one digit before the
significand's decimal point and <i>precision</i>-1 digits after the
significand's decimal point or in fixed notation with <i>precision</i>
significant digits.  If precision is <b>undefined</b>, call <code>ToString</code>
(<span class="xref">operator:ToString</span>) instead.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>toPrecision</code> method returns the selected
string representation of this number value.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function toPrecision(precision=undefined) : string {
    return "**toPrecision: FIXME**";
}
</PRE>

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #185.) Implement this function.

<P><span class="pcounter"></span> An implementation is permitted to extend the behaviour of
<code>toPrecision</code> for values of precision less than 1 or greater than
21.  In this case <code>toPrecision</code> would not necessarily throw
<b>RangeError</b> for such values.



<H1 id="class decimal"> The class <code>decimal</code> </h1>



<pre>
FILE:                       spec/library/decimal.html
DRAFT STATUS:               DRAFT 1 - ROUGH - 2007-09-20
REVIEWED AGAINST ES3:       NO
REVIEWED AGAINST ERRATA:    NO
REVIEWED AGAINST BASE DOC:  NO
REVIEWED AGAINST PROPOSALS: NO
REVIEWED AGAINST CODE:      NO
</pre>


<P><span class="pcounter"></span> The class <code>decimal</code> is a final, non-nullable, non-dynamic direct
subclass of <code>Object</code> that represents 128-bit IEEE decimal floating
point number values in the range 
<NOBR>-(10<SUP>34</SUP>-1) &#x00D7; 10<SUP>6111</SUP></NOBR> to
<NOBR>(10<SUP>34</SUP>-1) &#x00D7; 10<SUP>6111</SUP></NOBR> inclusive,
plus the three special values -&#x221E;, +&#x221E;, and NaN.

<p class="note"><b>COMPATIBILITY NOTE</b>&nbsp;&nbsp;  The class <code>decimal</code> is new in the 4th Edition of this
Standard.


<h2>Synopsis</h2>

<P><span class="pcounter"></span> The class <code>decimal</code> provides the following interface:

<PRE>
final class decimal!
{
    function decimal(x=0m) &#x0085
    meta static function invoke(x=0m) &#x0085
    
    static const MAX_VALUE: decimal = &#x0085;
    static const MIN_VALUE: decimal = &#x0085;
    static const NaN: decimal = &#x0085;
    static const NEGATIVE_INFINITY: decimal = &#x0085;
    static const POSITIVE_INFINITY: decimal = &#x0085;
    static const E: decimal = &#x0085;
    static const LN10: decimal = &#x0085;
    static const LN2: decimal = &#x0085;
    static const LOG2E: decimal = &#x0085;
    static const LOG10E: decimal = &#x0085;
    static const PI: decimal = &#x0085;
    static const SQRT1_2: decimal = &#x0085;
    static const SQRT2: decimal = &#x0085;
    static const length: uint = 1

    override intrinsic function toString(radix = 10) : string &#x0085
    override intrinsic function toLocaleString() : string &#x0085
    override intrinsic function toJSONString(pretty: boolean=false) : string &#x0085
    override intrinsic function valueOf() : decimal &#x0085

    intrinsic function toFixed(fractionDigits=0) : string &#x0085
    intrinsic function toExponential(fractionDigits=undefined) : string &#x0085
    intrinsic function toPrecision(precision=undefined) : string &#x0085
}
</PRE>

<P><span class="pcounter"></span> The <code>decimal</code> prototype object is identical to the <code>Number</code>
prototype object (<span class="xref">Number.prototype</span>).

<h2>Methods on the <code>decimal</code> class object</h2>

<h3>new&nbsp;decimal(&nbsp;value=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span>The <code>decimal</code> constructor initialises the newly created
<code>decimal</code> object by storing an implementation-dependent
representation of the decimal value of <i>value</i>, as converted by
<code>ToNumber</code>, in a private property.  The default <i>value</i> is +0.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span>The <code>decimal</code> constructor is implementation-dependent.

<h3>decimal(&nbsp;value=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> When the <code>decimal</code> class object is called as a function it
performs a type conversion: it converts <i>value</i> (which defaults
to +0) to <code>decimal</code>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>decimal</code> class object called as a function returns
<i>value</i> converted to <code>decimal</code>.

<P class="implsection"><b>Implementation</b>
<PRE>
meta static function invoke(x=0m)
    x is decimal ? x : new decimal(x);
</PRE>


<h2>Value properties on the <code>decimal</code> class object</h2>

<h3>MAX_VALUE</h3>

<P><span class="pcounter"></span> The value of <code>MAX_VALUE</code> is the largest positive finite value
represented by the <code>decimal</code> class, type, which is
<NOBR>(10<SUP>34</SUP>-1) &#x00D7; 10<SUP>6111</SUP></NOBR>.

<h3>MIN_VALUE</h3>

<P><span class="pcounter"></span> The value of <code>MIN_VALUE</code> is the smallest positive value
represented by the <code>decimal</code> class, which is
<NOBR>10<SUP>-6143</SUP></NOBR>.

<h3>NaN</h3>

<P><span class="pcounter"></span> The value of <code>NaN</code> is the not-a-number value represented by a
<code>decimal</code> instance.

<h3>NEGATIVE_INFINITY</h3>

<P><span class="pcounter"></span> The value of <code>NEGATIVE_INFINITY</code> is the value -&#x221E; as
represented by a <code>decimal</code> instance.

<h3>POSITIVE_INFINITY</h3>

<P><span class="pcounter"></span> The value of <code>POSITIVE_INFINITY</code> is the value +&#x221E; as
represented by a <code>decimal</code> instance.

<h3>E</h3>

<P><span class="pcounter"></span> The value of <code>E</code> is the <code>decimal</code> value for <i>e</i>, the base of the
natural logarithms, which is approximately 2.718281828459045235360287471352662.



<h3>LN10</h3>

<P><span class="pcounter"></span>The value of <code>LN10</code> is the <code>decimal</code> value for the natural
logarithm of 10, which is approximately 2.302585092994045684017991454684364.



<h3>LN2</h3>

<P><span class="pcounter"></span>The value of <code>LN2</code> is the <code>decimal</code> value for the natural
logarithm of 2, which is approximately 0.6931471805599453094172321214581766.



<h3>LOG2E</h3>

<P><span class="pcounter"></span>The value of <code>LOG2E</code> is the <code>decimal</code> value for the base-2
logarithm of <i>e</i>, the base of the natural logarithms; this value is
approximately 1.442695040888963407359924681001892.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The value of <code>decimal.LOG2E</code> is approximately the reciprocal
of the value of <code>decimal.LN2</code>.



<h3>LOG10E</h3>

<P><span class="pcounter"></span>The value of <code>LOG10E</code> is the decimal value for the base-10
logarithm of <i>e</i>, the base of the natural logarithms; this value is
approximately 0.4342944819032518276511289189166051.



<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The value of <code>decimal.LOG10E</code> is approximately the reciprocal
of the value of <code>decimal.LN10</code>.

<h3>PI</h3>

<P><span class="pcounter"></span>The value of <code>PI</code> is the <code>decimal</code> value for &#x03C0;, the ratio of
the circumference of a circle to its diameter, which is approximately
3.141592653589793238462643383279503.



<h3>SQRT1_2</h3>

<P><span class="pcounter"></span>The value of <code>SQRT1_2</code> is the <code>decimal</code> value for the square
root of 1/2, which is approximately 0.7071067811865475244008443621048490.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The value of <code>decimal.SQRT1_2</code> is approximately the reciprocal
of the value of <code>decimal.SQRT2</code>.


     1/sqrt(2) = 0.7071067811865475244008443621048490392848359376884740365883398689953674
     as computed by math.sch -->

<h3>SQRT2</h3>

<P><span class="pcounter"></span>The value of <code>SQRT2</code> is the <code>decimal</code> value for the square root
of 2, which is approximately 1.414213562373095048801688724209698.



<h2>Methods on <code>decimal</code> instances</h2>

<h3>intrinsic::toString&nbsp;(&nbsp;radix=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toString</code> method converts this number value
to a string representation in a base given by <i>radix</i>.

<P><span class="pcounter"></span> If radix is the number 10 or undefined, then the result is as for
the <code>ToString</code> operator.

<P><span class="pcounter"></span> If radix is an integer from 2 to 36, but not 10, the result is an
implementation-dependent string

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>toString</code> method returns a string.

<P class="implsection"><b>Implementation</b>
<PRE>
override intrinsic function toString(radix = 10) : string {
    if (radix === 10 || radix === undefined)
        return string(this);
    if (radix is AnyNumber && radix >= 2 && radix &#60;= 36 && isIntegral(radix))
        return informative::toString(int(radix));
    throw new TypeError("Invalid radix argument to decimal.toString");
}
</PRE>

<h3>intrinsic::toLocaleString&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toLocaleString</code> method converts this number
value to a string value that represents the value of the integer
formatted according to the conventions of the host environment's
current locale.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>toLocaleString</code> method returns an
implementation-dependent string.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span> The intrinsic <code>toLocaleString</code> method is
implementation-dependent, and it is permissible, but not encouraged,
for it to return the same thing as the intrinsic <code>toString</code> method.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The first parameter to this function is likely to be used in a
future version of this standard; it is recommended that
implementations do not use this parameter position for anything else.

<h3>toJSONString</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toJSONString</code> method convert this <code>decimal</code>
object to JSON format (<CITE ref="RFC4627">RFC 4627</CITE>).

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>toJSONString</code> method returns a <code>string</code>.

<P class="implsection"><b>Implementation</b>
<PRE>
override intrinsic function toJSONString(pretty: boolean=false) : string
    JSON.formatNumber(this, pretty);
</PRE>


<h3>intrinsic::valueOf&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>valueOf</code> method returns the number value
represented by this <code>decimal</code> object: the object itself.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>valueOf</code> method returns its <code>this</code> object.

<P class="implsection"><b>Implementation</b>
<PRE>
override intrinsic function valueOf() : decimal
    this;
</PRE>


<h3>intrinsic::toFixed&nbsp;(&nbsp;fractionDigits=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toFixed</code> method converts this number value
to a string in fixed-point notation with <i>fractionDigits</i> digits
after the decimal point.  If <i>fractionDigits</i> is <b>undefined</b>, 0
is assumed.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>toFixed</code> method returns the fixed-point
notation string representation of this number value.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function toFixed(fractionDigits=0) : string
    double(this).intrinsic::toFixed(fractionDigits);
</PRE>

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #188.) That implementation is bogus.

<P><span class="pcounter"></span> An implementation is permitted to extend the behaviour of toFixed
for values of <i>fractionDigits</i> less than 0 or greater than 20.  In
this case <code>toFixed</code> would not necessarily throw <b>RangeError</b> for
such values.

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #188.) Greater number of fractionDigits is possible for decimal.

<p class="note"><b>NOTE</b>&nbsp;&nbsp; The output of <code>toFixed</code> may be more precise than <code>toString</code>
for some values because <code>toString</code> only prints enough significant
digits to distinguish the number from adjacent number values. For
example, <code>(1000000000000000128).toString()</code> returns
"1000000000000000100", while <code>(1000000000000000128).toFixed(0)</code>
returns "1000000000000000128".

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #188.) Better example / more precision (for decimal).

<h3>intrinsic::toExponential&nbsp;(&nbsp;fractionDigits=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toExponential</code> method converts this number value
to a string in exponential notation with one digit before the
significand's decimal point and <i>fractionDigits</i> digits after the
significand's decimal point.  If <i>fractionDigits</i> is <b>undefined</b>,
include as many significand digits as necessary to uniquely specify
the number (just like in <code>ToString</code> except that in this case the
number is always output in exponential notation).

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>toExponential</code> method returns the exponential
notation string representation of this number value.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function toExponential(fractionDigits=undefined) : string
    double(this).intrinsic::toExponential(fractionDigits);
</PRE>

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #188.) That implementation is bogus.

<P><span class="pcounter"></span>An implementation is permitted to extend the behaviour of
<code>toExponential</code> for values of <i>fractionDigits</i> less than 0 or
greater than 20.  In this case <code>toExponential</code> would not necessarily
throw <b>RangeError</b> for such values.

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #188.) Greater number of fractionDigits is possible for decimal.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  For implementations that provide more accurate conversions than
required by the rules above, it is recommended that the following
alternative version of step 19 be used as a guideline:

<P class="note">Let e, n, and f be integers such that <i>f &#x2265; 0</i>,
<i>10<SUP>f</SUP> &#x2264; n < 10<SUP>f+1</SUP></i>, the number value for
<i>n &#x00D7; 10<SUP>e-f</SUP></i> is <i>x</i>, and <i>f</i> is as small as
possible.  If there are multiple possibilities for <i>n</i>, choose the
value of <i>n</i> for which <i>n &#x00D7; 10<SUP>e-f</SUP></i> is closest in
value to <i>x</i>.  If there are two such possible values of <i>n</i>,
choose the one that is even.

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #188.) "Step 19" is obsolete.


<h3>intrinsic::toPrecision&nbsp;(&nbsp;precision=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toPrecision</code> method converts this number value
to a string, either in exponential notation with one digit before the
significand's decimal point and <i>precision</i>-1 digits after the
significand's decimal point or in fixed notation with <i>precision</i>
significant digits.  If precision is <b>undefined</b>, call <code>ToString</code>
(<span class="xref">operator:ToString</span>) instead.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>toPrecision</code> method returns the selected string
representation of this number value.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function toPrecision(precision=undefined) : string
    double(this).intrinsic::toPrecision(precision);
</PRE>

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #188.) That implementation is bogus.

<P><span class="pcounter"></span> An implementation is permitted to extend the behaviour of
<code>toPrecision</code> for values of precision less than 1 or greater than
21.  In this case <code>toPrecision</code> would not necessarily throw
<b>RangeError</b> for such values.

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #188.) Greater precision possible for decimal.




<H1 id="Math object"> The <code>Math</code> Object </H1>

<PRE>
FILE:                       spec/library/Math.html
DRAFT STATUS:               DRAFT 1 - ROUGH - 2007-09-19
REVIEWED AGAINST ES3:       NO
REVIEWED AGAINST ERRATA:    NO
REVIEWED AGAINST PROPOSALS: NO
REVIEWED AGAINST CODE:      NO
</PRE>

<P><span class="pcounter"></span> The global <code>Math</code> object is a single object that has some named
properties, some of which are functions.  The <code>Math</code> object is the
only instance of a helper class called <code>Math</code>.

<P><span class="pcounter"></span> The <code>Math</code> object acts as a container for built-in
mathematics-related functions and constants.


<h2>Synopsis</h2>

<P><span class="pcounter"></span> For convenience of notation the definition of the Math object uses
the private type names <code>AnyNumber</code> and <code>FloatNumber</code>.

<PRE>
type AnyNumber = (int,uint,double,decimal);
type FloatNumber = (double,decimal);
</PRE>

<P><span class="pcounter"></span> The intrinsic methods on the math object are restricted to
arguments of the type <code>AnyNumber</code>.

<P><span class="pcounter"></span> The <code>Math</code> object provides the following interface:

<PRE>
helper dynamic final class Math extends Object
{
    intrinsic function abs(x: AnyNumber): AnyNumber &#x0085
    intrinsic function acos(x: AnyNumber): FloatNumber &#x0085
    intrinsic function atan(x: AnyNumber): FloatNumber &#x0085
    intrinsic function atan2(y: AnyNumber, x: AnyNumber): FloatNumber &#x0085
    intrinsic function ceil(x: AnyNumber): AnyNumber &#x0085
    intrinsic function cos(x: AnyNumber): FloatNumber &#x0085
    intrinsic function exp(x: AnyNumber): FloatNumber &#x0085
    intrinsic function floor(x: AnyNumber): AnyNumber &#x0085
    intrinsic function log(x: AnyNumber): FloatNumber &#x0085
    intrinsic function max(x: AnyNumber, y: AnyNumber): AnyNumber &#x0085
    intrinsic function min(x: AnyNumber, y: AnyNumber): AnyNumber &#x0085
    intrinsic function pow(x: AnyNumber, y: AnyNumber): AnyNumber &#x0085
    intrinsic function random(): double &#x0085
    intrinsic function round(x: AnyNumber): AnyNumber &#x0085
    intrinsic function sin(x: AnyNumber): FloatNumber &#x0085
    intrinsic function sqrt(x: AnyNumber): AnyNumber &#x0085
    intrinsic function tan(x: AnyNumber): FloatNumber &#x0085

    const E: double = double.E
    const LN10: double = double.LN10
    const LN2: double = double.LN2
    const LOG2E: double = double.LOG2E
    const LOG10E: double = double.LOG10E
    const PI: double = double.PI
    const SQRT1_2: double = double.SQRT1_2
    const SQRT2: double = double.SQRT2
}
</PRE>

<P><span class="pcounter"></span> The constant values <code>E</code>, <code>LN10</code>, <code>LN2</code>, <code>LOG2E</code>,
<code>LOG10E</code>, <code>PI</code>, <code>SQRT1_2</code>, and <code>SQRT2</code> in the <code>Math</code> class
are of type <code>double</code> for compatibility with 3rd Edition.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  New code may find it more convenient to access these constant
values through the <code>double</code> or <code>decimal</code> classes, as appropriate,
to obtain values with the best precision for the particular type.

<P><span class="pcounter"></span> The <code>Math</code> object additionally provides the following dynamic
function properties.  These functions are not restricted in the types
of arguments they accept, but convert all their arguments to number.

<PRE>
    abs:    function (x) &#x0085; ,
    acos:   function (x) &#x0085; ,
    asin:   function (x) &#x0085; ,
    atan:   function (x) &#x0085; ,
    atan2:  function (y,x) &#x0085; ,
    ceil:   function (x) &#x0085; ,
    cos:    function (x) &#x0085; ,
    exp:    function (x) &#x0085; ,
    floor:  function (x) &#x0085; ,
    log:    function (x) &#x0085; ,
    max:    function (...xs) &#x0085; ,
    min:    function (...xs) &#x0085; ,
    pow:    function (x,y) &#x0085; ,
    random: function () &#x0085; ,
    round:  function (x) &#x0085; ,
    sin:    function (x) &#x0085; ,
    sqrt:   function (x) &#x0085; ,
    tan:    function (x) &#x0085;
</PRE>

<P><span class="pcounter"></span> The <code>[[Prototype]]</code> object of the <code>Math</code> object does not contain a
<code>constructor</code> property.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The constraint on <code>constructor</code> is for backward compatibility
and is also necessary to insure that the math object is a singleton
object.  But note that <code>Math.constructor</code> is still defined, it is
accessible through the prototype chain and is <code>Object.constructor</code>.


<h2>Primitive operations on numbers</h2>

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #189.) Describe the following helper and informative
functions here: copysign, sign, isPositive, isPositiveZero,
isNegativeZero, isOddInteger, coerceToCommonFloating.  Or describe
them in the chapter on numbers.  (More info in the bug.)


<h2>Intrinsic function properties of the Math object</h2>

<P><span class="pcounter"></span> In the function descriptions below, the symbols NaN, -0, +0, -&#x221E;
and +&#x221E; refer to the number values described in 8.5.

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  Clean up the cross-reference later.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The behaviour of the functions <code>acos</code>, <code>asin</code>, <code>atan</code>,
<code>atan2</code>, <code>cos</code>, <code>exp</code>, <code>log</code>, <code>pow</code>, <code>sin</code>, and <code>sqrt</code>
is not precisely specified here except to require specific results for
certain argument values that represent boundary cases of interest. For
other argument values, these functions are intended to compute
approximations to the results of familiar mathematical functions, but
some latitude is allowed in the choice of approximation
algorithms. The general intent is that an implementer should be able
to use the same mathematical library for ECMAScript on a given
hardware platform that is available to C programmers on that platform.

<P class="note"> Although the choice of algorithms is left to the
implementation, it is recommended (but not specified by this standard)
that implementations use the approximation algorithms for IEEE 754
arithmetic contained in fdlibm, the freely distributable mathematical
library from Sun Microsystems (<code>fdlibm-comment@sunpro.eng.sun.com</code>).
This specification also requires specific results for certain argument
values that represent boundary cases of interest.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The functions defined in this section preserve the
representation of the argument(s) in the result where this is
reasonable.  The functions <code>ceil</code>, <code>floor</code>, <code>pow</code>, and <code>sqrt</code>
produce <code>int</code> and <code>uint</code> results when their arguments are <code>int</code>
or <code>uint</code> values and the result is representable as <code>int</code> or
<code>uint</code>.  All functions map <code>double</code> and <code>decimal</code> arguments to
<code>double</code> and <code>decimal</code> results, respectively.


<h3>intrinsic::abs&nbsp;(x)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span>The intrinsic <code>abs</code> function computes the absolute value of
the number <i>x</i>, which has the same magnitude as <i>x</i> but has
positive sign.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span>The intrinsic <code>abs</code> function returns the absolute value of
<i>x</i>.  The representation of the result is the same as the
representation of <i>x</i> except that the absolute value of an <code>int</code>
may be represented as a <code>uint</code>.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span>
<PRE>
intrinsic function abs(x: AnyNumber): AnyNumber {
    switch type (x) {
    case (n: int) {
        return n &#60; 0 ? -n : n;
    }
    case (n: uint) {
        return n;
    }
    case (n: double) {
        if (isNaN(n)) return n;
        if (x == 0d) return 0d;
        return n &#60; 0d ? -n : n;
    }
    case (n: decimal) {
        if (isNaN(n)) return n;
        if (x == 0m) return 0m;
        return n &#60; 0m ? -n : n;
    }
    }
}
</PRE>


<h3>intrinsic::acos&nbsp;(x)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>acos</code> function computes an
implementation-dependent approximation to the arc cosine of the number
<i>x</i>.  The result is expressed in radians and ranges from +0 to +&#x03C0;.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>acos</code> function returns a floating-point number.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function acos(x: AnyNumber): FloatNumber {
    switch type (x) {
    case (n: (int,uint)) {
        return intrinsic::acos(double(n));
    }
    case (n: double) {
        if (isNaN(n) || n > 1d || n &#60; -1d) return NaN;
        if (n == 1d) return 0d;
        return informative::acosDouble(n);
    }
    case (n: decimal) {
        if (isNaN(n) || n > 1m || n &#60; 1m) return decimal.NaN;
        if (n == 1m) return 0m;
        return informative::acosDecimal(n);
    }
    }
}
</PRE>

<P><span class="pcounter"></span> The informative functions <code>acosDouble</code> and <code>acosDecimal</code>
implement representation-preserving approximate computation of the arc
cosine of their argument.

<PRE>
informative function acosDouble(x: double): double &#x0085
informative function acosDecimal(x: decimal): decimal &#x0085
</PRE>


<h3>intrinsic::asin&nbsp;(x)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>asin</code> function computes an
implementation-dependent approximation to the arc sine of the number
<i>x</i>.  The result is expressed in radians and ranges from -&#x03C0;/2 to
+&#x03C0;/2.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>asin</code> function returns a floating-point number.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function asin(x: AnyNumber): FloatNumber {
    switch type (x) {
    case (n: (int,uint)) {
        return intrinsic::asin(double(n));
    }
    case (n: double) {
        if (isNaN(n) || n > 1d || n &#60; -1d) return NaN;
        if (n == 0d) return n;
        return informative::asinDouble(n);
    }
    case (n: decimal) {
        if (isNaN(n) || n > 1m || n &#60; 1m) return decimal.NaN;
        if (n == 0m) return n;
        return informative::asinDecimal(n);
    }
    }
}
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp; The intrinsic <code>asin</code> function preserves the sign of <i>x</i> if x is 0.

<P><span class="pcounter"></span> The informative functions <code>asinDouble</code> and <code>asinDecimal</code>
implement representation-preserving approximate computation of the arc
sine of their argument.

<PRE>
informative function asinDouble(x: double): double &#x0085
informative function asinDecimal(x: decimal): decimal &#x0085
</PRE>


<h3>intrinsic::atan&nbsp;(x)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>atan</code> function computes an
implementation-dependent approximation to the arc tangent of the
number <i>x</i>.  The result is expressed in radians and ranges from
-&#x03C0;/2 to +&#x03C0;/2.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>atan</code> function returns a floating-point number.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function atan(x: AnyNumber): FloatNumber {
    switch type (x) {
    case (n: (int,uint)) {
        return intrinsic::atan(double(n));
    }
    case (n: double) {
        if (isNaN(n) || n == 0d) return n;
        if (!isFinite(n))
            return copysign(double.PI / 2d, n);
        return informative::atanDouble(n);
    }
    case (n: decimal) {
        if (isNaN(n) || n == 0m) return n;
        if (!isFinite(n))
            return copysign(decimal.PI / 2m, n);
        return informative::atanDecimal(n);
    }
    }
}
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp; The intrinsic <code>atan</code> function preserves the sign of <i>x</i> if x is 0.

<P><span class="pcounter"></span> The informative functions <code>atanDouble</code> and <code>atanDecimal</code>
implement representation-preserving approximate computation of the arc
tangent of their argument.

<PRE>
informative function atanDouble(x: double): double &#x0085
informative function atanDecimal(x: decimal): decimal &#x0085
</PRE>

<h3>intrinsic::atan2&nbsp;(y,&nbsp;x)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>atan2</code> function computes an
implementation-dependent approximation to the arc tangent of the
quotient <i>y/x</i> of the numbers <i>y</i> and <i>x</i>, where the signs of
<i>y</i> and <i>x</i> are used to determine the quadrant of the result.
Note that it is intentional and traditional for the two-argument arc
tangent function that the argument named <i>y</i> be first and the
argument named <i>x</i> be second. The result is expressed in radians and
ranges from -&#x03C0; to +&#x03C0;.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>atan2</code> function returns a floating-point
number.  The result is <code>decimal</code> of <i>y</i> or <i>x</i> is <code>decimal</code>,
otherwise <code>double</code>.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function atan2(y: AnyNumber, x: AnyNumber): FloatNumber {
    [y, x] = helper::coerceToCommonFloatNumber(y, x);

    let Type = x is double ? double : decimal;

    if (isNaN(x) || isNaN(y))
        return Type.NaN;
    if (y > 0 && x == 0)
        return Type.PI/2;
    if (helper::isPositiveZero(y))
        return helper::isPositive(x) ? Type(+0) : Type.PI;
    if (helper::isNegativeZero(y))
        return helper::isPositive(x) ? Type(-0) : -Type.PI;
    if (y &#60; 0 && x == 0)
        return -Type.PI/2;
    if (y != 0 && isFinite(y) && !isFinite(x) && x > 0)
        return Type(copysign(0, y));
    if (y != 0 && isFinite(y) && !isFinite(x) && x &#60; 0)
        return copysign(Type.PI, y);
    if (!isFinite(y) && isFinite(x))
        return copysign(Type.PI/2, y);
    if (!isFinite(y) && !isFinite(x))
        return copysign(x > 0 ? Type.PI/4 : 3*Type.PI/4, y);

    if (Type == double)
        return informative::atan2Double(y, x);
    return informative::atan2Decimal(y, x);
}
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  An implementation is free to produce approximations for all
computations involving <code>PI</code> in the preceding algorithm.

<P><span class="pcounter"></span> The informative functions <code>atan2Double</code> and <code>atan2Decimal</code>
implement representation-preserving approximate computation of the arc
tangent of the quotient of their arguments.

<PRE>
informative function atan2Double(y: double, x: double): double &#x0085
informative function atan2Decimal(y: decimal, x: decimal): decimal &#x0085
</PRE>


<h3>intrinsic::ceil&nbsp;(x)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>ceil</code> function computes the smallest (closest
to -&#x221E;) number value that is not less than <i>x</i> and is equal to
a mathematical integer. If <i>x</i> is already an integer, the result is
<i>x</i>.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The value of <code>Math.ceil(<i>x</i>)</code> is the same as the value of
<code>-Math.floor(-<i>x</i>)</code>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>ceil</code> function returns a number in the same
representation as <i>x</i>.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function ceil(x: AnyNumber): AnyNumber {
    switch type (x) {
    case (n: (int,uint)) {
        return n;
    }
    case (n: double) {
        if (!isFinite(n) || n == 0d) return n;
        if (-1d &#60; n && n &#60; 0d) return -0d;
        return informative::ceilDouble(n);
    }
    case (n: decimal) {
        if (!isFinite(n) || n == 0m) return n;
        if (-1m &#60; n && n &#60; 0m) return -0m;
        return informative::ceilDecimal(n);
    }
    }
}
</PRE>

<P><span class="pcounter"></span> The informative functions <code>ceilDouble</code> and <code>ceilDecimal</code>
implement representation-preserving computation of the ceiling of
their argument.

<PRE>
informative function ceilDouble(x: double): double &#x0085
informative function ceilDecimal(x: decimal): decimal &#x0085
</PRE>


<h3>intrinsic::cos&nbsp;(x)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>cos</code> method computes an
implementation-dependent approximation to the cosine of the number
<i>x</i>.  The argument is expressed in radians.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>cos</code> function returns a floating-point number.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function cos(x: AnyNumber): FloatNumber {
    switch type (x) {
    case (n: (int,uint)) {
        return intrinsic::cos(double(n));
    }
    case (n: double) {
        if (!isFinite(n)) return NaN;
        if (n == 0d) return 1d;
        return informative::cosDouble(n);
    }
    case (n: decimal) {
        if (!isFinite(n)) return decimal.NaN;
        if (n == 0m) return 1m;
        return informative::cosDecimal(n);
    }
    }
}
</PRE>

<P><span class="pcounter"></span> The informative functions <code>cosDouble</code> and <code>cosDecimal</code>
implement representation-preserving approximate computation of the cosine
of their argument.

<PRE>
informative function cosDouble(x: double): double &#x0085
informative function cosDecimal(x: decimal): decimal &#x0085
</PRE>

<h3>intrinsic::exp&nbsp;(x)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>exp</code> function computes an
implementation-dependent approximation to the exponential function of
the number <i>x</i> (<i>e<SUP>x</SUP></i>, where <i>e</i> is the base of the
natural logarithms).

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>exp</code> function returns a floating-point number.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function exp(x: AnyNumber): FloatNumber {
    switch type (x) {
    case (n: (int,uint)) {
        return intrinsic::exp(double(n));
    }
    case (n: double) {
        if (isNaN(n)) return n;
        if (n == 0d) return 1d;
        if (n == Infinity) return Infinity;
        if (n == -Infinity) return 0d;
        return informative::expDouble(n);
    }
    case (n: decimal) {
        if (isNaN(n)) return n;
        if (n == 0m) return 1m;
        if (n == decimal.POSITIVE_INFINITY) return decimal.POSITIVE_INFINITY;
        if (n == decimal.NEGATIVE_INFINITY) return 0m;
        return informative::expDecimal(n);
    }
    }
}
</PRE>

<P><span class="pcounter"></span> The informative functions <code>expDouble</code> and <code>expDecimal</code>
implement representation-preserving approximate computation of the
exponential function of their argument.

<PRE>
informative function expDouble(x: double): double &#x0085
informative function expDecimal(x: decimal): decimal &#x0085
</PRE>

<h3>intrinsic::floor&nbsp;(x)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>floor</code> function computes the greatest (closest
to +&#x221E;) number value that is not greater than <i>x</i> and is equal
to a mathematical integer. If <i>x</i> is already an integer, the result
is <i>x</i>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>floor</code> function returns a number in the same
representation as <i>x</i>.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function floor(x: AnyNumber): AnyNumber {
    switch type (x) {
    case (n: (int,uint)) {
        return n;
    }
    case (n: double) {
        if (!isFinite(n) || n == 0d) return n;
        if (0d &#60; n && n &#60; 1d) return +0d;
        return informative::floorDouble(n);
    }
    case (n: decimal) {
        if (!isFinite(n) || n == 0m) return n;
        if (0m &#60; n && n &#60; 1m) return +0m;
        return informative::floorDecimal(n);
    }
    }
}
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The value of <code>Math.floor(<i>x</i>)</code> is the same as the value of
<code>-Math.ceil(-<i>x</i>)</code>.

<P><span class="pcounter"></span> The informative functions <code>floorDouble</code> and <code>floorDecimal</code>
implement representation-preserving computation of the floor of their
argument.

<PRE>
informative function floorDouble(x: double): double &#x0085
informative function floorDecimal(x: decimal): decimal &#x0085
</PRE>


<h3>intrinsic::log&nbsp;(x)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>log</code> function computes an
implementation-dependent approximation to the natural logarithm of the
number <i>x</i>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>log</code> function returns a floating-point number.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function log(x: AnyNumber): FloatNumber {
    switch type (x) {
    case (n: (int,uint)) {
        return intrinsic::log(double(n));
    }
    case (n: double) {
        if (isNaN(n) || n &#60; 0d) return NaN;
        if (n == 0d) return -Infinity;
        if (n == 1d) return +0d;
        if (n == Infinity) return n;
        return informative::logDouble(n);
    }
    case (n: decimal) {
        if (isNaN(n) || n &#60; 0d) return decimal.NaN;
        if (n == 0m) return decimal.NEGATIVE_INFINITY;
        if (n == 1m) return +0m;
        if (n == decimal.POSITIVE_INFINITY) return n;
        return informative::logDecimal(n);
    }
    }
}
</PRE>

<P><span class="pcounter"></span> The informative functions <code>logDouble</code> and <code>logDecimal</code>
implement representation-preserving approximate computation of the
natural logarithm of their argument.

<PRE>
informative function logDouble(x: double): double &#x0085
informative function logDecimal(x: decimal): decimal &#x0085
</PRE>


<h3>intrinsic::max&nbsp;(x,&nbsp;y)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>max</code> method selects the numerically largest
(closest to +&#x221E;) value among <i>x</i> and <i>y</i>.  +0 is
considered larger than -0.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>max</code> method returns either <i>x</i> or <i>y</i>.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function max(x: AnyNumber, y: AnyNumber): AnyNumber {
    if (isNaN(x)) return x;
    if (isNaN(y)) return y;
    if (x > y) return x;
    if (y > x) return y;
    if (x is (int,uint) || x != 0) return x;

    let x_sign = sign(x),
        y_sign = sign(y);
    if (x_sign > y_sign) return x;
    if (y_sign > x_sign) return y;
    return x;
}
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  If <i>x</i> and <i>y</i> are numerically equal (and of the same sign
if they are both 0) then the implementation is free to return either
one of them.

<h3>intrinsic::min&nbsp;(x,&nbsp;y)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>min</code> method selects the numerically smallest
(closest to -&#x221E;) number among <i>x</i> and <i>y</i>.  -0 is
considered smaller than +0.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>min</code> method returns either <i>x</i> or <i>y</i>.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function min(x: AnyNumber, y: AnyNumber): AnyNumber {
    if (isNaN(x)) return x;
    if (isNaN(y)) return y;
    if (x &#60; y) return x;
    if (y &#60; x) return y;
    if (x is (int,uint) || x != 0) return x;

    let x_sign = sign(x),
        y_sign = sign(y);
    if (x_sign &#60; y_sign) return x;
    if (y_sign &#60; x_sign) return y;
    return x;
}
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  If <i>x</i> and <i>y</i> are numerically equal (and of the same sign
if they are both 0) then the implementation is free to return either
one of them.

<h3>intrinsic::pow&nbsp;(x,&nbsp;y)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>pow</code> function computes an
implementation-dependent approximation to the result of raising <i>x</i>
to the power <i>y</i>.

<P><span class="pcounter"></span> The intrinsic <code>pow</code> function produces a result in the
representation of <i>x</i>.  However, <code>int</code> and <code>uint</code> are only used
to represent the result if <i>x</i> and <i>y</i> are both <code>int</code> or
<code>uint</code> and <i>y</i> is nonnegative, and <i>x<SUP>y</SUP></i> is
representable in the representation of <i>x</i>.  Following the rules for
arithmetic, <code>int</code> results overflow to a <code>uint</code> or <code>double</code> as
appropriate, and <code>uint</code> overflows to <code>double</code>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>pow</code> function returns a number.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function pow(x: AnyNumber, y: AnyNumber): AnyNumber {
    if (x is int) {
        if (y is (int,uint) && y >= 0) {
            if (y == 0) return 1;
            if (x == 0) {
                if (y > 0) return 0;
                return Infinity;
            }
            return informative::powInt(x, int(y));
        }
        else
            x = double(x);
    }
    else if (x is uint) {
        if (y is (int,uint) && y >= 0) {
            if (y == 0) return 1u;
            if (x == 0) {
                if (y > 0) return 0u;
                return Infinity;
            }
            return informative::powUInt(x, uint(y));
        }
        else
            x = double(x);
    }

    [x,y] = helper::coerceToCommonFloatNumber(x,y);
    let Type = x is double ? double : decimal;

    if (isNaN(y)) return Type.NaN;
    if (y == 0) return Type(1);
    if (isNaN(x) && y != 0) return Type.NaN;
    if (abs(x) > 1 && y == Infinity) return Type.POSITIVE_INFINITY;
    if (abs(x) > 1 && y == -Infinity) return Type(+0);
    if (abs(x) == 1 && y == Infinity) return Type.NaN;
    if (abs(x) == 1 && y == -Infinity) return Type.NaN;
    if (abs(x) &#60; 1 && y == Infinity) return Type(+0);
    if (abs(x) &#60; 1 && y == -Infinity) return Type.POSITIVE_INFINITY;
    if (x == Infinity && y > 0) return Type.POSITIVE_INFINITY;
    if (x == Infinity && y &#60; 0) return Type(+0);
    if (x == -Infinity && y > 0 && helper::isOddInteger(y)) return Type.NEGATIVE_INFINITY;
    if (x == -Infinity && y > 0 && !helper::isOddInteger(y)) return Type.POSITIVE_INFINITY;
    if (x == -Infinity && y &#60; 0 && helper::isOddInteger(y)) return Type(-0);
    if (x == -Infinity && y &#60; 0 && !helper::isOddInteger(y)) return Type(+0);
    if (x == 0 && y > 0) return Type(+0);
    if (x == 0 && y &#60; 0) return Type.POSITIVE_INFINITY;
    if (helper::isNegativeZero(x) && y > 0 && helper::isOddInteger(y)) return Type(-0);
    if (helper::isNegativeZero(x) && y > 0 && !helper::isOddInteger(y)) return Type(+0);
    if (helper::isNegativeZero(x) && y &#60; 0 && helper::isOddInteger(y)) return Type.NEGATIVE_INFINITY;
    if (helper::isNegativeZero(x) && y &#60; 0 && !isOddInteger(y)) return Type.POSITIVE_INFINITY;
    if (x &#60; 0 && isFinite(x) && isFinite(y) && !isIntegral(y)) return Type.NaN;

    if (Type == double)
        return informative::powDouble(x, y);
    return informative::powDecimal(x, y);
}
</PRE>


<P><span class="pcounter"></span> The informative functions <code>powInt</code>, <code>powUInt</code>, <code>powDouble</code>, and <code>powDecimal</code>
implement representation-dependent computation of the value <i>x<SUP>y</SUP></i>.  <code>powInt</code> and
<code>powUInt</code> preserve the representation of <i>x</i> if possible as described above.

<PRE>
informative function powInt(x: int, y: int): (int,uint,double) &#x0085
informative function powUInt(x: uint, y: uint): (uint, double) &#x0085
informative function powDouble(x: double, y: double): double &#x0085
informative function powDecimal(x: decimal, y: decimal): decimal &#x0085
</PRE>

<h3>intrinsic::random&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>random</code> function computes a <code>double</code> value
with positive sign, greater than or equal to 0 but less than 1, chosen
randomly or pseudo randomly with approximately uniform distribution
over that range, using an implementation-dependent algorithm or
strategy. This function takes no arguments.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>random</code> function returns a <code>double</code>.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span> The intrinsic <code>random</code> function is implementation-dependent.

<h3>intrinsic::round&nbsp;(x)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>round</code> function computes the number value that
is closest to <i>x</i> and is equal to a mathematical integer. If two
integer number values are equally close to <i>x</i>, then the result is the
number value that is closer to +&#x221E;. If <i>x</i> is already an integer,
the result is <i>x</i>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>round</code> function returns a number, the representation
of which is always the same as the representation of the input <i>x</i>.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function round(x: AnyNumber): AnyNumber {
    switch type (x) {
    case (n: (int,uint)) {
        return n;
    }
    case (n: double) {
        if (!isFinite(n) || n == 0d) return n;
        if (0d &#60; n && n &#60; 0.5) return +0d;
        if (-0.5 &#60; n && n &#60; 0d) return -0d;
        return informative::roundDouble(n);
    }
    case (n: decimal) {
        if (!isFinite(n) || n == 0m) return n;
        if (0m &#60; n && n &#60; 0.5m) return +0m;
        if (-0.5m &#60; n && n &#60; 0m) return -0m;
        return informative::roundDecimal(n);
    }
    }
}
</PRE>

<P><span class="pcounter"></span> The informative functions <code>roundDouble</code> and <code>roundDecimal</code>
implement representation-preserving computation of the rounded value
of their argument.

<PRE>
informative function roundDouble(x: double):double &#x0085
informative function roundDecimal(x: decimal):decimal &#x0085
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp; 
The intrinsic <code>round</code> function preserves the sign of <i>x</i> if <i>x</i> is 0.

<p class="note"><b>NOTE</b>&nbsp;&nbsp; 
<code>Math.round(3.5)</code> returns 4, but <code>Math.round(-3.5)</code> returns -3.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The value of <code>Math.round(<i>x</i>)</code> is the same as the value of
<code>Math.floor(<i>x</i>+0.5)</code>, except when <i>x</i> is -0 or is less than 0
but greater than or equal to -0.5; for these cases
<code>Math.round(<i>x</i>)</code> returns -0, but <code>Math.floor(<i>x</i>+0.5)</code>
returns +0.


<h3>intrinsic::sin&nbsp;(x)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>sin</code> function computes an
implementation-dependent approximation to the sine of the number
<i>x</i>.  The argument is expressed in radians.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>sin</code> function returns a floating-point number.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function sin(x: AnyNumber): FloatNumber {
    switch type (x) {
    case (n: (int,uint)) {
        return intrinsic::sin(double(n));
    }
    case (n: double) {
        if (!isFinite(n)) return NaN;
        if (n == 0d) return n;
        return informative::sinDouble(n);
    }
    case (n: decimal) {
        if (!isFinite(n)) return decimal.NaN;
        if (n == 0m) return n;
        return informative::sinDecimal(n);
    }
    }
}
</PRE>

<P><span class="pcounter"></span> The informative functions <code>sinDouble</code> and <code>sinDecimal</code>
implement representation-preserving approximate computation of the sine
of their argument.

<PRE>
informative function sinDouble(x: double):double &#x0085
informative function sinDecimal(x: decimal):decimal &#x0085
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp; 
The intrinsic <code>sin</code> function preserves the sign of <i>x</i> if <i>x</i> is 0.


<h3>intrinsic::sqrt&nbsp;(x)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>sqrt</code> method computes an
implementation-dependent approximation to the square root of the
number <i>x</i>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>sqrt</code> method returns a number.  The
representation of the result is the same as the representation of
<i>x</i> if possible; in particular, if <i>x</i> is of type <code>int</code> or
<code>uint</code> and <i>x &#x2265; 0</i>, then the result is of type <code>int</code> or
<code>uint</code> if <i>x</i> is a square.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function sqrt(x: AnyNumber): AnyNumber {
    switch type (x) {
    case (n: int) {
        if (n &#60; 0) return NaN;
        return informative::sqrtInt(n);
    }
    case (n: uint) {
        return informative::sqrtUint(n);
    }
    case (n: double) {
        if (isNaN(n) || n &#60; 0d) return NaN;
        if (n == 0d || n == Infinity) return n;
        return informative::sqrtDouble(n);
    }
    case (n: decimal) {
        if (isNaN(n) || n &#60; 0m) return decimal.NaN;
        if (n == 0m || n == decimal.POSITIVE_INFINITY) return n;
        return informative::sqrtDecimal(n);
    }
    }
}
</PRE>


<h3>intrinsic::tan&nbsp;(x)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>tan</code> function computes an
implementation-dependent approximation to the tangent of <i>x</i>.  The
argument is expressed in radians.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>tan</code> function returns a floating-point number.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function sin(x: AnyNumber): FloatNumber {
    switch type (x) {
    case (n: (int,uint)) {
        return intrinsic::sin(double(n));
    }
    case (n: double) {
        if (!isFinite(n)) return NaN;
        if (n == 0d) return n;
        return informative::sinDouble(n);
    }
    case (n: decimal) {
        if (!isFinite(n)) return decimal.NaN;
        if (n == 0m) return n;
        return informative::sinDecimal(n);
    }
    }
}
</PRE>

<P><span class="pcounter"></span> The informative functions <code>tanDouble</code> and <code>tanDecimal</code>
implement representation-preserving approximate computation of the tangent
of their argument.

<PRE>
informative function tanDouble(x: double):double &#x0085
informative function tanDecimal(x: decimal):decimal &#x0085
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp; 
The intrinsic <code>tan</code> function preserves the sign of <i>x</i> if <i>x</i> is 0.


<h2>Other function properties of the Math object</h2>

<P><span class="pcounter"></span> Every function listed in this section applies the <code>toAnyNumber</code>
function to each of its arguments (in left-to-right order if there is
more than one) and then performs a computation on the resulting number
value(s) by invoking the corresponding intrinsic method.

<PRE>
Math.public::abs =
    function (x) intrinsic::Math.intrinsic::abs(x);

Math.public::acos =
    function (x) intrinsic::Math.intrinsic::acos(helper::toAnyNumber(x));

Math.public::asin =
    function (x) intrinsic::Math.intrinsic::asin(helper::toAnyNumber(x));

Math.public::atan =
    function (x) intrinsic::Math.intrinsic::atan(helper::toAnyNumber(x));

Math.public::atan2 =
    function (y,x)
    intrinsic::Math.intrinsic::atan2(helper::toAnyNumber(y), helper::toAnyNumber(x));

Math.public::ceil =
    function (x) intrinsic::Math.intrinsic::ceil(helper::toAnyNumber(x));

Math.public::cos =
    function (x) intrinsic::Math.intrinsic::cos(helper::toAnyNumber(x));

Math.public::exp =
    function (x) intrinsic::Math.intrinsic::exp(helper::toAnyNumber(x));

Math.public::floor =
    function (x) intrinsic::Math.intrinsic::floor(helper::toAnyNumber(x));

Math.public::log =
    function (x) intrinsic::Math.intrinsic::log(helper::toAnyNumber(x));

Math.public::pow =
    function (x, y)
    intrinsic::Math.intrinsic::pow(helper::toAnyNumber(x), helper::toAnyNumber(y));

Math.public::random =
    function () intrinsic::Math.intrinsic::random();

Math.public::round =
    function (x) intrinsic::Math.intrinsic::round(helper::toAnyNumber(x));

Math.public::sin =
    function (x) intrinsic::Math.intrinsic::sin(helper::toAnyNumber(x));

Math.public::sqrt =
    function (x) intrinsic::Math.intrinsic::sqrt(helper::toAnyNumber(x));

Math.public::tan =
    function (x) intrinsic::Math.intrinsic::tan(helper::toAnyNumber(x));

</PRE>

<P><span class="pcounter"></span> The <code>max</code> and <code>min</code> functions are more general than their
corresponding intrinsic methods: they accept zero or more arguments
and apply their corresponding intrinsic methods to the current result
and the next argument, in left-to-right order.

<PRE>
Math.public::max =
    function max(...xs) {
        if (xs.length == 0)
        return -Infinity;
        let result = helper::toAnyNumber(xs[0]);
        for ( let i=1 ; i &#60; xs.length; ++i ) {
            result = intrinsic::Math.intrinsic::max(result, helper::toAnyNumber(xs[i]));
            if (isNaN(result))
                break;
        }
        return result;
    };

Math.public::min =
    function min(...xs) {
        if (xs.length == 0)
        return Infinity;
        let result = helper::toAnyNumber(xs[0]);
        for ( let i=1 ; i &#60; xs.length; ++i ) {
            result = intrinsic::Math.intrinsic::min(result, helper::toAnyNumber(xs[i]));
            if (isNaN(result))
                break;
        }
        return result;
    };
</PRE>





<H1 id="class Date"> The class <code>Date</code> </h1>

<pre>
FILE:                       spec/library/Date.html
DRAFT STATUS:               DRAFT 1 - ROUGH - 2007-09-20
REVIEWED AGAINST ES3:       NO
REVIEWED AGAINST ERRATA:    NO
REVIEWED AGAINST BASE DOC:  NO
REVIEWED AGAINST PROPOSALS: NO
REVIEWED AGAINST CODE:      NO
</pre>

<P><span class="pcounter"></span> The <code>Date</code> object serves two purposes: as a record of an instant
in time, and as a simple timer.

<P><span class="pcounter"></span> Time is measured in ECMAScript in milliseconds since 01 January,
1970 UTC (the "epoch"), and a <code>Date</code> object contains a number
indicating a particular instant in time to within a millisecond
relative to the epoch.  The number may also be NaN, indicating that
the Date object does not represent a specific instant of time.

<P><span class="pcounter"></span> A <code>Date</code> object also contains a record of its time of creation
to nanosecond precision, and can be queried for the elapsed time since
its creation to within a nanosecond.

<h2>Synopsis</h2>

<P><span class="pcounter"></span> The <code>Date</code> class provides this interface:


<PRE>
dynamic class Date extends Object
{
    function Date(year=NOARG, month=NOARG, date=NOARG, hours=NOARG, minutes=NOARG, seconds=NOARG, ms=NOARG) &#x0085
    meta static function invoke(...args)   // args are ignored. &#x0085

    static intrinsic function parse(s:string, reference:double=0.0) : double &#x0085
    static intrinsic function UTC(year: double, &#x0085
    static function now() : double &#x0085

    static var parse = function parse(str, reference:double=0.0) &#x0085
    static var UTC = &#x0085

    static const length: uint = 7;

    override intrinsic function toString() : string &#x0085
    intrinsic function toDateString() : string &#x0085
    intrinsic function toTimeString():string &#x0085
    override intrinsic function toLocaleString() : string &#x0085
    intrinsic function toLocaleDateString() : string &#x0085
    intrinsic function toLocaleTimeString() : string &#x0085
    intrinsic function toUTCString() : string &#x0085
    intrinsic function toISOString() : string &#x0085
    override intrinsic function toJSONString(pretty: boolean=false) &#x0085
    intrinsic function nanoAge() : double &#x0085
    intrinsic function getTime() : double &#x0085
    intrinsic function getYear() : double &#x0085
    intrinsic function getFullYear() : double &#x0085
    intrinsic function getUTCFullYear() : double &#x0085
    intrinsic function getMonth() : double &#x0085
    intrinsic function getUTCMonth() : double &#x0085
    intrinsic function getDate() : double &#x0085
    intrinsic function getUTCDate() : double &#x0085
    intrinsic function getDay() : double &#x0085
    intrinsic function getUTCDay() : double &#x0085
    intrinsic function getHours() : double &#x0085
    intrinsic function getUTCHours() : double &#x0085
    intrinsic function getMinutes() : double &#x0085
    intrinsic function getUTCMinutes() : double &#x0085
    intrinsic function getSeconds() : double &#x0085
    intrinsic function getUTCSeconds() : double &#x0085
    intrinsic function getMilliseconds() : double &#x0085
    intrinsic function getUTCMilliseconds() : double &#x0085
    intrinsic function getTimezoneOffset() : double &#x0085

    intrinsic function setTime(t:double) : double &#x0085
    intrinsic function setYear(this:Date, year:double) &#x0085
    intrinsic function setFullYear(year:double, &#x0085
    intrinsic function setUTCFullYear(year:double, &#x0085
    intrinsic function setMonth(month:double, date:double = getDate()):double &#x0085
    intrinsic function setUTCMonth(month:double, date:double = getUTCDate()):double &#x0085
    intrinsic function setDate(date: double): double &#x0085
    intrinsic function setUTCDate(date: double): double &#x0085
    intrinsic function setHours(hour: double, &#x0085
    intrinsic function setUTCHours(hour: double, &#x0085
    intrinsic function setMinutes(min:double, &#x0085
    intrinsic function setUTCMinutes(min:double, &#x0085
    intrinsic function setSeconds(sec:double, ms:double = getMilliseconds()) 
        : double &#x0085
    intrinsic function setUTCSeconds(sec:double, ms:double = getUTCMilliseconds()) 
        : double &#x0085
    intrinsic function setMilliseconds(ms:double) : double &#x0085
    intrinsic function setUTCMilliseconds(ms:double) : double &#x0085

    function get time(this:Date) : double &#x0085
    function get year(this:Date) : double &#x0085
    function get fullYear(this:Date) : double &#x0085
    function get UTCFullYear(this:Date) : double &#x0085
    function get month(this:Date) : double &#x0085
    function get UTCMonth(this:Date) : double &#x0085
    function get date(this:Date) : double &#x0085
    function get UTCDate(this:Date) : double &#x0085
    function get day(this:Date) : double &#x0085
    function get UTCDay(this:Date) : double &#x0085
    function get hours(this:Date) : double &#x0085
    function get UTCHours(this:Date) : double &#x0085
    function get minutes(this:Date) : double &#x0085
    function get UTCMinutes(this:Date) : double &#x0085
    function get seconds(this:Date) : double &#x0085
    function get UTCSeconds(this:Date) : double &#x0085
    function get milliseconds(this:Date) : double &#x0085
    function get UTCMilliseconds(this:Date) : double &#x0085
    
    function set time(this:Date, t : double) : double &#x0085
    function set year(this:Date, t: double) : double &#x0085
    function set fullYear(this:Date, t : double) : double &#x0085
    function set UTCFullYear(this:Date, t : double) : double &#x0085
    function set month(this:Date, t : double) : double &#x0085
    function set UTCMonth(this:Date, t : double) : double &#x0085
    function set date(this:Date, t : double) : double &#x0085
    function set UTCDate(this:Date, t : double) : double &#x0085
    function set hours(this:Date, t : double) : double &#x0085
    function set UTCHours(this:Date, t : double) : double &#x0085
    function set minutes(this:Date, t : double) : double &#x0085
    function set UTCMinutes(this:Date, t : double) : double &#x0085
    function set seconds(this:Date, t : double) : double &#x0085
    function set UTCSeconds(this:Date, t : double) : double &#x0085
    function set milliseconds(this:Date, t : double) : double &#x0085
    function set UTCMilliseconds(this:Date, t : double) : double &#x0085

    private var timeval: double = &#x0085;
}
</PRE>

<P><span class="pcounter"></span> The <code>Date</code> prototype object is itself a <code>Date</code> object whose
time value is NaN.  It provides the following direct properties:

<PRE>
    toString:           function () &#x0085; ,
    toDateString:       function () &#x0085; ,
    toTimeString:       function () &#x0085; ,
    toLocaleString:     function () &#x0085; ,
    toLocaleDateString: function () &#x0085; ,
    toLocaleTimeString: function () &#x0085; ,
    toUTCString:        function () &#x0085; ,
    toISOString:        function () &#x0085; ,
    toJSONString:       function (pretty=false) &#x0085; ,
    valueOf:            function () &#x0085; ,
    getTime:            function () &#x0085; ,
    getFullYear:        function () &#x0085; ,
    getUTCFullYear:     function () &#x0085; ,
    getMonth:           function () &#x0085; ,
    getUTCMonth:        function () &#x0085; ,
    getDate:            function () &#x0085; ,
    getUTCDate:         function () &#x0085; ,
    getDay:             function () &#x0085; ,
    getUTCDay:          function () &#x0085; ,
    getHours:           function () &#x0085; ,
    getUTCHours:        function () &#x0085; ,
    getMinutes:         function () &#x0085; ,
    getUTCMinutes:      function () &#x0085; ,
    getSeconds:         function () &#x0085; ,
    getUTCSeconds:      function () &#x0085; ,
    getMilliseconds:    function () &#x0085; ,
    getUTCMilliseconds: function () &#x0085; ,
    getTimezoneOffset:  function () &#x0085; ,
    setTime:            function (time) &#x0085; ,
    setMilliseconds:    function (ms) &#x0085; ,
    setUTCMilliseconds: function (ms) &#x0085; ,
    setSeconds:         function (sec, ms=undefined) &#x0085; ,
    setUTCSeconds:      function (sec, ms=undefined) &#x0085; ,
    setMinutes:         function (min, sec=undefined, ms=undefined) &#x0085; ,
    setUTCMinutes:      function (min, sec=undefined, ms=undefined) &#x0085; ,
    setHours:           function (hour, min=undefined, sec=undefined, ms=undefined) &#x0085; ,
    setUTCHours:        function (hour, min=undefined, sec=undefined, ms=undefined) &#x0085; ,
    setDate:            function (date) &#x0085; ,
    setUTCDate:         function (date) &#x0085; ,
    setMonth:           function (month, date=undefined) &#x0085; ,
    setUTCMonth:        function (month, date=undefined) &#x0085; ,
    setFullYear:        function (year, month=undefined, date=undefined) &#x0085; ,
    setUTCFullYear:     function (year, month=undefined, date=undefined) &#x0085; ,
</PRE>


<h2>Overview of Date Objects and Definitions of Helper Functions</h2>

<P><span class="pcounter"></span> A <code>Date</code> object contains a private property <code>timeval</code> that
indicates a particular instant in time to within a millisecond.  The
number may also be <b>NaN</b>, indicating that the <code>Date</code> object does not
represent a specific instant of time.

<P><span class="pcounter"></span> The following sections define a number of helper functions for
operating on time values.  Note that, in every case, if any argument
to such a function is <b>NaN</b>, the result will be <b>NaN</b>.

<P><span class="pcounter"></span> For the sake of succinctness, the <code>helper</code> and <code>informative</code>
namespaces are open in all the definitions that follow.


<h3>Time Range</h3>

<P><span class="pcounter"></span> Time is measured in ECMAScript in milliseconds since 01 January,
1970 UTC. Leap seconds are ignored. It is assumed that there are
exactly 86,400,000 milliseconds per day. ECMAScript <code>double</code> values
can represent all integers from -9,007,199,254,740,991 to
9,007,199,254,740,991; this range suffices to measure times to
millisecond precision for any instant that is within approximately
285,616 years, either forward or backward, from 01 January, 1970 UTC.

<P><span class="pcounter"></span> The actual range of times supported by ECMAScript Date objects is
slightly smaller: exactly -100,000,000 days to 100,000,000 days
measured relative to midnight at the beginning of 01 January, 1970
UTC. This gives a range of 8,640,000,000,000,000 milliseconds to
either side of 01 January, 1970 UTC.

<P><span class="pcounter"></span> The exact moment of midnight at the beginning of 01 January, 1970
UTC is represented by the value +0.

<h3>Constants</h3>

<P><span class="pcounter"></span> The following simple constants are used by the helper functions
defined below.

<PRE>
helper const hoursPerDay = 24;

helper const minutesPerHour = 60;

helper const secondsPerMinute = 60;

helper const daysPerYear = 365.2425;

helper const msPerSecond = 1000;

helper const msPerMinute = msPerSecond * secondsPerMinute;

helper const msPerHour = msPerMinute * minutesPerHour;

helper const msPerDay = msPerHour * hoursPerDay;

helper const msPerYear = msPerDay * daysPerYear;
</PRE>

<P><span class="pcounter"></span> The table <code>monthOffsets</code> contains the day offset within a
non-leap year of the first day of each month:

<PRE>
helper const monthOffsets = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
</PRE>

<h3>Day Number and Time within Day</h3>

<P><span class="pcounter"></span>A given time value <i>t</i> belongs to day number <code>Day(<i>t</i>)</code>:

<PRE>
helper function Day(t : double) : double
    Math.floor(t / msPerDay);
</PRE>

<P><span class="pcounter"></span>The remainder is called the time within the day, <code>TimeWithinDay(<i>t</i>)</code>:

<PRE>
helper function TimeWithinDay(t : double) : double
    t % msPerDay;
</PRE>


<H3 id="year number"> Year Number </h3>

<P><span class="pcounter"></span>ECMAScript uses an extrapolated Gregorian system to map a day
number to a year number and to determine the month and date within
that year.  In this system, leap years are precisely those which are
(divisible by 4) and ((not divisible by 100) or (divisible by
400)). The number of days in year number <i>y</i> is therefore defined by
<code>DaysInYear(<i>y</i>)</code>:

<PRE>
helper function DaysInYear(y : double) : double {
    if (y % 4 !== 0 || y % 100 === 0 && y % 400 !== 0)
        return 365;
    else
        return 366;
}
</PRE>

<P><span class="pcounter"></span>All non-leap years have 365 days with the usual number of days per
month and leap years have an extra day in February.  The day number of
the first day of year <i>y</i> is given by <code>DayFromYear(<i>y</i>)</code>:

<PRE>
helper function DayFromYear(y : double) : double
    365 * (y-1970) + Math.floor((y-1969)/4) - Math.floor((y-1901)/100) + Math.floor((y-1601)/400);
</PRE>

<P><span class="pcounter"></span>The time value of the start of a year <i>y</i> is <code>TimefromYear(<i>y</i>)</code>:

<PRE>
helper function TimeFromYear(y : double) : double
    msPerDay * DayFromYear(y);
</PRE>

<P><span class="pcounter"></span> A time value <i>t</i> determines a year by <code>YearFromTime(<i>t</i>)</code>,
which yields the largest integer <i>y</i> (closest to positive infinity)
such that <code>TimeFromYear(<i>y</i>) &#x2264; <i>t</i></code>.

<P><span class="pcounter"></span> The function <code>YearFromTime</code> is not defined precisely by this Standard.
<PRE>
informative static function YearFromTime(t: double): double &#x0085;
</PRE>

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #190.) Is there any good reason not to define how
<code>YearFromTime</code> should be computed?  The RI uses a non-iterative
algorithm which I believe comes from SpiderMonkey.  I have seen
iterative algorithms elsewhere.

<P><span class="pcounter"></span>The leap-year function <code>InLeapYear</code> is 1 for a time within a leap
year and otherwise is zero:

<PRE>
helper function InLeapYear(t : double) : double
    (DaysInYear(YearFromTime(t)) == 365) ? 0 : 1;
</PRE>


<H3 id="month number"> Month Number </H3>

<P><span class="pcounter"></span> Months are identified by an integer in the range 0 to 11,
inclusive.  The mapping from a time value <i>t</i> to a month number is
defined by <code>MonthFromTime(<i>t</i>)</code> :

<PRE>
helper function MonthFromTime(t : double) : double {
    let dwy = DayWithinYear(t),
        ily = InLeapYear(t);
    for ( let i=monthOffsets.length-1; i >= 0; i-- ) {
        let firstDayOfMonth = monthOffsets[i];
        if (i >= 2)
            firstDayOfMonth += ily;
        if (dwy >= firstDayOfMonth)
            return i;
    }
}

helper function DayWithinYear(t : double) : double
    Day(t) - DayFromYear(YearFromTime(t));
</PRE>

<P><span class="pcounter"></span> A month value of 0 specifies January; 1 specifies February; 2
specifies March; 3 specifies April; 4 specifies May; 5 specifies June;
6 specifies July; 7 specifies August; 8 specifies September; 9
specifies October; 10 specifies November; and 11 specifies December.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  <code>MonthFromTime(0)=0</code>, corresponding to Thursday, 01&nbsp;January, 1970.


<H3 id="date number"> Date Number </h3>

<P><span class="pcounter"></span> A date number is identified by an integer in the range 1 through
31, inclusive.  The mapping from a time value <i>t</i> to a month number
is defined by <code>DateFromTime(<i>t</i>)</code>:

<PRE>
helper function DateFromTime(t : double) : double {
    let dwy = DayWithinYear(t),
        mft = MonthFromTime(t),
        ily = InLeapYear(t);
    return (dwy+1) - (monthOffsets[mft]) - (mft >= 2 ? ily : 0);
}
</PRE>


<H3 id="week day"> Week Day </h3>

<P><span class="pcounter"></span>The weekday for a particular time value <i>t</i> is defined as <code>WeekDay(<i>t</i>)</code>:

<PRE>
helper function WeekDay(t : double) : double {
    let v = (Day(t) + 4) % 7;
    if (v &#60; 0)
        return v + 7;
    return v;
}
</PRE>

<P><span class="pcounter"></span>A weekday value of 0 specifies Sunday; 1 specifies Monday; 2
specifies Tuesday; 3 specifies Wednesday; 4 specifies Thursday; 5
specifies Friday; and 6 specifies Saturday.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  <code>WeekDay(0)=4</code>, corresponding to Thursday, 01&nbsp;January, 1970.


<H3 id="time zone adjustment"> Local Time Zone Adjustment </H3>

<P><span class="pcounter"></span> An implementation of ECMAScript is expected to determine the local
time zone adjustment.  The local time zone adjustment is a value
<code>LocalTZA</code> measured in milliseconds which when added to UTC
represents the local standard time.  Daylight saving time is not
reflected by <code>LocalTZA</code>.

<PRE>
informative function LocalTZA(): double &#x0085;
</PRE>

<P><span class="pcounter"></span> The value <code>LocalTZA</code> does not vary with time but depends only on
the geographic location.

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #129.) This is bogus because it assumes time zone boundaries are
fixed for all eternity.  Yet time zone (standard time) is political;
changing political conditions can lead to adoption of a different
standard time (analogous to the changes in daylight savings time
adjustment).  So the above assertion needs to go, and probably be
replaced by language similar to that we want to adopt for
DaylightSavingsTA, which encourages "best effort for the given time".


<H3 id="dst adjustment"> Daylight Saving Time Adjustment </H3>

<P><span class="pcounter"></span> An implementation of ECMAScript is expected to determine the
daylight saving time algorithm.  The algorithm to determine the
daylight saving time adjustment for a time <i>t</i>, implemented by
<code>DaylightSavingTA(<i>t</i>)</code>, measured in milliseconds, must depend
only on four things:

<OL>
<LI> The time since the beginning of the year: <code><i>t</i> - TimeFromYear(YearFromTime(<i>t</i>))</code>

<LI> Whether t is in a leap year: <code>InLeapYear(<i>t</i>)</code>

<LI> The week day of the beginning of the year: <code>WeekDay(TimeFromYear(YearFromTime(<i>t</i>))</code>

<LI> The geographic location.
</OL>

<P><span class="pcounter"></span> The implementation of ECMAScript should not try to determine
whether the exact time <i>t</i> was subject to daylight saving time, but
just whether daylight saving time would have been in effect if the
current daylight saving time algorithm had been used at the time.
This avoids complications such as taking into account the years that
the locale observed daylight saving time year round.

<P><span class="pcounter"></span> If the host environment provides functionality for determining
daylight saving time, the implementation of ECMAScript is free to map
the year in question to an equivalent year (same leapyear-ness and
same starting week day for the year) for which the host environment
provides daylight saving time information.  The only restriction is
that all equivalent years should produce the same result.

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #129.) We've already agreed that the above is bogus; the
implementation needs to make a "best effort" to find the correct
adjustment for the time <i>t</i>, in the year of <i>t</i>.  More to come
here.  Also see note above for <code>LocalTZA</code>.

<h3>Local Time</h3>

<P><span class="pcounter"></span>Conversion from UTC to local time is defined by

<PRE>
helper function LocalTime(t : double) : double
    t + LocalTZA() + DaylightSavingsTA(t);
</PRE>

<P><span class="pcounter"></span>Conversion from local time to UTC is defined by

<PRE>
helper function UTCTime(t : double) : double
    t - LocalTZA() - DaylightSavingsTA(t - LocalTZA());
</PRE>

<P><span class="pcounter"></span>Note that <code>UTCTime(LocalTime(<i>t</i>))</code> is not necessarily always
equal to <i>t</i> because the former expands as
<code><i>t</i>+DaylightSavingsTA(<i>t</i>)-DaylightSavingsTA(<i>t</i>-LocalTZA())</code>.


<H3 id="hours, minutes, seconds, and milliseconds"> Hours, Minutes, Seconds, and Milliseconds </H3>

<P><span class="pcounter"></span>The following functions are useful in decomposing time values:

<PRE>
helper function HourFromTime(t : double) : double {
    let v = Math.floor(t / msPerHour) % hoursPerDay;
    if (v &#60; 0)
        return v + hoursPerDay;
    return v;
}

helper function MinFromTime(t : double) : double {
    let v = Math.floor(t / msPerMinute) % minutesPerHour;
    if (v &#60; 0)
        return v + minutesPerHour;
    return v;
}

helper function SecFromTime(t : double) : double {
    let v = Math.floor(t / msPerSecond) % secondsPerMinute;
    if (v &#60; 0)
        return v + secondsPerMinute;
    return v;
}

helper function msFromTime(t : double) : double
    t % msPerSecond;
</PRE>


<h3>MakeTime&nbsp;(hour,&nbsp;min,&nbsp;sec,&nbsp;ms)</h3>

<P><span class="pcounter"></span>The operator MakeTime calculates a number of milliseconds from its
four arguments, which must be ECMAScript number values. This operator
functions as follows:

<PRE>
helper function MakeTime(hour:double, min:double, sec:double, ms:double ):double {
    if (!isFinite(hour) || !isFinite(min) || !isFinite(sec) || !isFinite(ms))
        return NaN;

    return (helper::toInteger(hour) * msPerHour +
            helper::toInteger(min) * msPerMinute +
            helper::toInteger(sec) * msPerSecond +
            helper::toInteger(ms));
}
</PRE>

<h3>MakeDay&nbsp;(year,&nbsp;month,&nbsp;date)</h3>

<P><span class="pcounter"></span>The helper function <code>MakeDay</code> calculates a number of days from
its three arguments, which must be ECMAScript <code>double</code> values:

<PRE>
helper function MakeDay(year : double, month : double, date : double) : double {
    if (!isFinite(year) || !isFinite(month) || !isFinite(date))
        return NaN;

    year = helper::toInteger(year);
    month = helper::toInteger(month);
    date = helper::toInteger(date);

    /* INFORMATIVE, the spec is non-operational. */
    year += Math.floor(month / 12);

    month = month % 12;
    if (month &#60; 0)
        month += 12;

    let leap = (DaysInYear(year) == 366);

    let yearday = Math.floor(TimeFromYear(year) / msPerDay);
    let monthday = DayFromMonth(month, leap);

    return yearday + monthday + date - 1;
}
</PRE>

<h3>MakeDate&nbsp;(day,&nbsp;time)</h3>

<P><span class="pcounter"></span>The helper function <code>MakeDate</code> calculates a number of
milliseconds from its two arguments, which must be ECMAScript
<code>double</code> values:

<PRE>
helper function MakeDate(day : double, time : double) : double {
    if (!isFinite(day) || !isFinite(time))
        return NaN;

    return day * msPerDay + time;
}
</PRE>

<h3>TimeClip&nbsp;(time)</h3>

<P><span class="pcounter"></span>The helper function <code>TimeClip</code> calculates a number of
milliseconds from its argument, which must be an ECMAScript <code>double</code>
value:

<PRE>
helper function TimeClip(t : double) : double
    (!isFinite(t) || Math.abs(t) > 8.64e15) ? NaN : adjustZero(helper::toInteger(t));
</PRE>
informative function adjustZero(t: double): double &#x0085

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The informative function <code>adjustZero(<i>t</i>)</code> can either
return <i>t</i> unchanged or it can add (+0) to it.  The point of this
freedom is that an implementation is permitted a choice of internal
representations of time values, for example as a 64-bit signed integer
or as a 64-bit floating-point value.  Depending on the implementation,
this internal representation may or may not distinguish -0 and +0.


<h2>Date strings</h2>

<P><span class="pcounter"></span> Dates can be converted to string representations for purposes of
human consumption and data transmission in a number of ways, many of
them locale-dependent.

<P><span class="pcounter"></span> Some of the string representations of dates are required to be
lossless, which is to say that converting a time value to a string and
then parsing that string as a Date will always yield the same time
value.  Other string representations are implementation-dependent and
it is not guaranteed that they can be parsed to yield the same time
value (or that they can be parsed at all).

<P><span class="pcounter"></span> This Standard defines numerous methods on <code>Date</code> instances to
generate strings from time values: <code>toString</code>, <code>toDateString</code>,
<code>toTimeString</code>, <code>toLocaleString</code>, <code>toLocaleDateString</code>,
<code>toLocaleTimeString</code>, <code>toUTCString</code>, and <code>toISOString</code>.

<P><span class="pcounter"></span> The <code>toString</code> and <code>toUTCString</code> methods convert time values
to a string losslessly except for fractional seconds, which may not be
represented in the string.  The format of these strings is
implementation-dependent.

<P><span class="pcounter"></span> The <code>toISOString</code> method converts time values to a string
losslessly, and the string conforms to the ISO date grammar defined
below.

<P><span class="pcounter"></span> This Standard defines the static <code>parse</code> method on the <code>Date</code>
class to parse strings and compute time values represented by those
strings.  The <code>parse</code> method is only required to parse all strings
that conform to the ISO date grammar defined below, as well as all
strings produced by the <code>toString</code> and <code>toUTCString</code> methods on
<code>Date</code> instances.

<P><span class="pcounter"></span> The grammar for ISO date strings is defined by the following
regular expression:

<PRE>
helper const isoTimestamp =
    /^
     # Date, optional
     (?: (?P&#60;year> - [0-9]+ | [0-9]{4} [0-9]* )
      (?: - (?P&#60;month> [0-9]{2} )
       (?: - (?P&#60;day> [0-9]{2} ) )? )? )?
     T
     # Time, optional
     (?: (?P&#60;hour> [0-9]{2} )
      (?: : (?P&#60;minutes> [0-9]{2} )
       (?: : (?P&#60;seconds> [0-9]{2} )
        (?: \. (?P&#60;fraction> [0-9]+ ) )? )? )? )?
     # Timezone, optional
     (?: (?P&#60;zulu> Z )
      | (?P&#60;offs>
         (?P&#60;tzdir> \+ | - )
         (?P&#60;tzhr> [0-9]{2} )
         (?: : (?P&#60;tzmin> [0-9]{2} ) )? ) )?
     $/x;
</PRE>

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #192.) Replace the regexp by a proper grammar, eventually.


<h2>Methods on the Date class</h2>

<h3>new&nbsp;Date&nbsp;(year=&#x0085;,&nbsp;month=&#x0085;,&nbsp;date=&#x0085;,&nbsp;hours=&#x0085;,&nbsp;minutes=&#x0085;,&nbsp;seconds=&#x0085;,&nbsp;ms=&#x0085;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> When the <code>Date</code> constructor is called as part of a <code>new&nbsp;Date</code> expression it initialises 
the newly created object by setting its private <code>timeval</code> property.

<P><span class="pcounter"></span> The <code>Date</code> constructor can be called with zero, one, or two to seven arguments, 
and sets <code>timeval</code> in different ways depending on how it is called.

<P class="implsection"><b>Implementation</b>
<PRE>
function Date(year=NOARG, month=NOARG, date=NOARG, hours=NOARG, minutes=NOARG, seconds=NOARG, ms=NOARG) {
    informative::setupNanoAge();

    switch (NOARG) {
    case year:
        timeval = Date.now();
        return;

    case month: {
        let v = ToPrimitive(year);
        if (v is string)
            return parse(v);

        timeval = TimeClip(double(v));
        return;
    }

    default:
        ms = double(ms);

    case ms:
        seconds = double(seconds);

    case seconds:
        minutes = double(minutes);

    case minutes:
        hours = double(hours);

    case hours:
        date = double(date);

    case date:
        year = double(year);
        month = double(month);

        let intYear : int = helper::toInteger(year);
        if (!isNaN(year) && 0 &#60;= intYear && intYear &#60;= 99)
            intYear += 1900;
        timeval = TimeClip(UTCTime(MakeDate(MakeDay(intYear, month, date),
                                            MakeTime(hours, minutes, seconds, ms))));
    }
}
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The default value <code>NOARG</code> is an unforgeable private value and is
used to detect the difference between an unsupplied parameter and a
parameter value of <b>undefined</b>.


<h3>Date&nbsp;(...args)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> When the Date class is called as a function rather than as a
constructor, it converts the current time (as returned by the static
method <code>now</code> on <code>Date</code>) to a string.

<P><span class="pcounter"></span> All arguments are ignored.  A string is created as if by the
expression <code>(new Date()).toString()</code>.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The function call <code>Date(&#x0085;)</code> is not equivalent to the
object creation expression <code>new Date(&#x0085;)</code> with the same
arguments.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>Date</code> class called as a function returns a <code>string</code> object.

<P class="implsection"><b>Implementation</b>
<PRE>
meta static function invoke(...args)   // args are ignored.
    (new Date()).public::toString();
</PRE>


<h3>intrinsic::parse&nbsp;(s,&nbsp;reference=&#x0085;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static intrinsic <code>parse</code> method applies the <code>string</code>
function to its argument <i>s</i> and interprets the resulting string as
a date.  The string may be interpreted as a local time, a UTC time, or
a time in some other time zone, depending on the contents of the
string.

<P><span class="pcounter"></span> The value <i>reference</i> (defaulting to zero) is a time value that
will provide default values for any fields missing from the string.

<P><span class="pcounter"></span>If <i>x</i> is any Date object whose milliseconds amount is zero
within a particular implementation of ECMAScript, then all of the
following expressions should produce the same numeric value in that
implementation, if all the properties referenced have their initial
values:

<PRE>
x.valueOf()
Date.parse(x.toString())
Date.parse(x.toUTCString())
</PRE>

<P><span class="pcounter"></span>However, the expression <code>Date.parse(x.toLocaleString())</code> is not
required to produce the same number value as the preceding three
expressions and, in general, the value produced by Date.parse is
implementation-dependent when given any string value that could not be
produced in that implementation by the toString or toUTCString method.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>parse</code> method returns a number, the UTC time
value corresponding to the date represented by the string.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span> The static <code>parse</code> method parses a string that conforms to
the ISO grammar as an ISO date string.  Otherwise, the parsing is
implementation-dependent.

<PRE>
static intrinsic function parse(s:string, reference:double=0.0) : double {

    function fractionToMilliseconds(frac: string): double
        Math.floor(1000 * (parseInt(frac) / Math.pow(10, frac.length)));

    let isoRes = isoTimestamp.exec(s);
    let defaults = new Date(reference);
    if (isoRes) {
        let year = isoRes.year !== undefined ? parseInt(isoRes.year) : defaults.UTCYear;
        let month = isoRes.month !== undefined ? parseInt(isoRes.month)-1 : defaults.UTCMonth;
        let day = isoRes.day !== undefined ? parseInt(isoRes.day) : defaults.UTCDay;
        let hour = isoRes.hour !== undefined ? parseInt(isoRes.hour) : defaults.UTCHour;
        let mins = isoRes.minutes !== undefined ? parseInt(isoRes.minutes) : defaults.UTCMinutes;
        let secs = isoRes.seconds !== undefined ? parseInt(isoRes.seconds) : defaults.UTCSeconds;
        let millisecs = isoRes.fraction !== undefined ?
            fractionToMilliseconds(isoRes.fraction) :
            defaults.UTCMilliseconds;
        let tzo = defaults.timezoneOffset;
        if (isoRes.zulu !== undefined)
            tzo = 0;
        else if (isoRes.offs !== undefined) {
            tzo = parseInt(isoRes.tzhr) * 60;
            if (isoRes.tzmin !== undefined)
                tzo += parseInt(isoRes.tzmin);
            if (isoRes.tzdir === "-")
                tzo = -tzo;
        }
        return new Date.UTC(year, month, day, hour, mins, secs, millisecs) - tzo;
    }
    else
        return informative::fromDateString(s, reference);
}
</PRE>


<h3>parse(&nbsp;s,&nbsp;reference=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>parse</code> method applies the <code>string</code> function to
its argument <i>s</i> and the <code>double</code> function to its argument
<i>reference</i> (which defaults to zero), and then calls the intrinsic
<code>parse</code> method on the resulting values.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>parse</code> method returns a number, the UTC time
value corresponding to the date represented by the string.

<P class="implsection"><b>Implementation</b>
<PRE>
static var parse = function parse(str, reference:double=0.0) {
    return Date.parse(string(str), reference);
}
</PRE>


<h3>intrinsic::UTC&nbsp;(year,&nbsp;month,&nbsp;date=&#x0085;,&nbsp;hours=&#x0085;,&nbsp;minutes=&#x0085;,&nbsp;seconds=&#x0085;,&nbsp;ms=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> When the static intrinsic <code>UTC</code> method is called with two to
seven arguments, it computes the date from <i>year</i>, <i>month</i> and
(optionally) <i>date</i>, <i>hours</i>, <i>minutes</i>, <i>seconds</i> and <i>ms</i>.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The <code>UTC</code> method differs from the <code>Date</code> constructor in two
ways: it returns a time value as a number, rather than creating a
<code>Date</code> object, and it interprets the arguments in UTC rather than as
local time.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static intrinsic <code>UTC</code> method returns a time value.

<P class="implsection"><b>Implementation</b>
<PRE>
static intrinsic function UTC(year: double,
                              month: double,
                              date: double=1,
                              hours: double=0,
                              minutes: double=0,
                              seconds: double=0,
                              ms: double=0) : double
{
    let intYear = helper::toInteger(year);
    if (!isNaN(year) && 0 &#60;= intYear && intYear &#60;= 99)
        intYear += 1900;
    return TimeClip(MakeDate(MakeDay(intYear, month, date),
                             MakeTime(hours, minutes, seconds, ms)));
}
</PRE>

<h3>UTC&nbsp;(year,&nbsp;month,&nbsp;date=&#x0085;,&nbsp;hours=&#x0085;,&nbsp;minutes=&#x0085;,&nbsp;seconds=&#x0085;,&nbsp;ms=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> When the static intrinsic <code>UTC</code> method is called with fewer
than two arguments, the behaviour is implementation dependent.  When
the <code>UTC</code> method is called with two to seven arguments, it computes
the date from <i>year</i>, <i>month</i> and (optionally) <i>date</i>,
<i>hours</i>, <i>minutes</i>, <i>seconds</i> and <i>ms</i> by converting all
arguments to <code>double</code> values and calling the static intrinsic
<code>UTC</code> method.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>UTC</code> method returns a time value.

<P class="implsection"><b>Implementation</b>
<PRE>
static var UTC =
    function UTC(year, month, date=NOARG, hours=NOARG, minutes=NOARG, seconds=NOARG, ms=NOARG) {
        switch (NOARG) {
        case date:    date = 1;
        case hours:   hours = 0;
        case minutes: minutes = 0;
        case seconds: seconds = 0;
        case ms:      ms = 0;
        }
        return Date.UTC(double(year),
                        double(month),
                        double(date),
                        double(hours),
                        double(minutes),
                        double(seconds),
                        double(ms));
    };
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The default value <code>NOARG</code> is an unforgeable private value and is
used to detect the difference between an unsupplied parameter and a
parameter value of <b>undefined</b>.

<h3>now</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>now</code> method produces the time value at the time
of the call.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>now</code> method returns a <code>double</code> representing a
time value.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span> The static <code>now</code> method is implementation-dependent.


<h2>Methods on Date instances</h2>

<h3>intrinsic::toString&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toString</code> method converts the <code>Date</code> value to
a string.  The contents of the string are intended to represent the
value in the current time zone in a convenient, human-readable
form.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  It is intended that for any <code>Date</code> value <i>d</i>, the result of
<code>Date.parse(<i>d</i>.toString())</code> is equal to <i>d</i>.  (See <span class="xref">Date.parse</span>.)

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> A <code>string</code> value.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span> The intrinsic <code>toString</code> method is implementation-dependent.


<h3>intrinsic::toDateString&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toLocaleString</code> method converts the "date"
portion of the <code>Date</code> value to a string.  The contents of the string are
intended to represent the value in the current time zone in a
convenient, human-readable form.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> A <code>string</code> value.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span> The intrinsic <code>toDateString</code> method is implementation-dependent.

<h3>intrinsic::toTimeString&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toTimeString</code> method converts the "time"
portion of the <code>Date</code> value to a string.  The contents of the string are
intended to represent the value in the current time zone in a
convenient, human-readable form.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> A <code>string</code> value.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span> The intrinsic <code>toTimeString</code> method is implementation-dependent.


<h3>intrinsic::toLocaleString&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toLocaleString</code> method converts the <code>Date</code> value
to a string.  The contents of the string are intended to represent the
value in the current time zone in a convenient, human-readable form that
corresponds to the conventions of the host environment's current locale.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The first parameter to this function is likely to be used in a
future version of this standard; it is recommended that
implementations do not use this parameter position for anything else.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> A <code>string</code> value.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span> The intrinsic <code>toLocaleString</code> method is implementation-dependent.

<h3>intrinsic::toLocaleDateString&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toLocaleDateString</code> method converts the "date"
portion of the <code>Date</code> value to a string.  The contents of the string are
intended to represent the value in the current time zone in a
convenient, human-readable form that corresponds to the conventions of
the host environment's current locale.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The first parameter to this function is likely to be used in a
future version of this standard; it is recommended that
implementations do not use this parameter position for anything else.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> A <code>string</code> value.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span> The intrinsic <code>toLocaleDateString</code> method is implementation-dependent.


<h3>intrinsic::toLocaleTimeString&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toLocaleTimeString</code> method converts the "time"
portion of the <code>Date</code> value to a string.  The contents of the string are
intended to represent the value in the current time zone in a
convenient, human-readable form that corresponds to the conventions of
the host environment's current locale.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The first parameter to this function is likely to be used in a
future version of this standard; it is recommended that
implementations do not use this parameter position for anything else.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> A <code>string</code> value.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span> The intrinsic <code>toLocaleTimeString</code> method is
implementation-dependent.


<h3>intrinsic::toUTCString&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toUTCString</code> method converts the <code>Date</code> value to
a string.  The contents of the string are intended to represent the
value in UTC in a convenient, human-readable form.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> A <code>string</code> value.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span> The intrinsic <code>toUTCString</code> method is implementation-dependent.


<h3>intrinsic::toISOString&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toISOString</code> method converts the <code>Date</code> value to
a string.  The string conforms to the ISO time and date grammar
presented in section <span class="xref">ISO date grammar</span>.  All fields are
present in the string and the shortest possible nonempty string of
digits follows the period in the time part.  The time zone is always
UTC, denoted by a suffix <code>Z</code>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> A <code>string</code> value.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function toISOString() : string {
    return (formatYears(UTCFullYear) + "-" +
            zeroFill(UTCMonth+1, 2) + "-" +
            zeroFill(UTCDate, 2) +
            "T" +
            zeroFill(UTCHours, 2) + ":" +
            zeroFill(UTCMinutes, 2) + ":" +
            zeroFill(UTCSeconds, 2) + "." +
            removeTrailingZeroes(int(UTCMilliseconds)) +
            "Z");
}

helper function formatYears(n: double): string {
    if (n >= 0 && n &#60;= 9999)
        return zeroFill(int(n), 4);
    else
        return string(n);
}
</PRE>

<P><span class="pcounter"></span> The helper functions <code>removeTrailingZeroes</code> and <code>zeroFill</code> are
described in section <span class="xref">Minor date helpers</span>.

<h3>intrinsic::toJSONString&nbsp;(&nbsp;pretty=false&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toJSONString</code> method convert this date object
to JSON format (<CITE ref="RFC4627">RFC 4627</CITE>).

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>toJSONString</code> method returns a string.

<P class="implsection"><b>Implementation</b>
<PRE>
override intrinsic function toJSONString(pretty: boolean=false)
    JSON.formatDate(this, pretty);
</PRE>


<h3>intrinsic::nanoAge()</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>nanoAge</code> method computes an approximation of
the number of nanoseconds of real time that have elapsed since this
<code>Date</code> object was created.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The approximation is of unspecified quality, and may vary in
both accuracy and precision from platform to platform.  The
approximation will necessarily lose precision as its object ages,
since it is expressed as a double: after approximately 104 days of
real time, its object will have been alive for over 2<SUP>53</SUP>
nanoseconds, so the result of this call will carry more than 2
nanoseconds rounding error after 104 days, and more than 4 nanoseconds
rounding error after 208 days.  Code wishing to measure greater
periods of real time may either construct fresh Date objects after 104
days, or accept the gradual loss of precision.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> A <code>double</code> object.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span> The static <code>nanoAge</code> method is implementation-dependent.


<h3>intrinsic::valueOf&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>valueOf</code> method returns the time value of the
<code>Date</code> object.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> A <code>double</code> object.

<P class="implsection"><b>Implementation</b>
<PRE>
override intrinsic function valueOf() : Object
    getTime();
</PRE>


<h3>intrinsic::getTime&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>getTime</code> method retrieves the full time value of the Date object.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> This time value.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function getTime() : double
    timeval;
</PRE>

<h3>intrinisic::getFullYear&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>getFullYear</code> method retrieves the year number of the Date object, in the local time zone.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> A year number (<span class="xref">year number</span>).

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function getFullYear() : double
    let (t = timeval)
        isNaN(t) ? t : YearFromTime(LocalTime(t));
</PRE>

<h3>intrinisic::getUTCFullYear&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>getUTCFullYear</code> method retrieves the year number of the Date object, in UTC.

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  Is the phrasing "in UTC" appropriate?  (Ditto for all following functions.)

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> A year number (<span class="xref">year number</span>).

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function getUTCFullYear() : double
    let (t = timeval)
        isNaN(t) ? t : YearFromTime(t);
</PRE>


<h3>intrinisic::getMonth&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>getMonth</code> method retrieves the month number of the Date object, in the local time zone.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> A month number (<span class="xref">month number</span>).

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function getMonth() : double
    let (t = timeval)
        isNaN(t) ? t : MonthFromTime(LocalTime(t));
</PRE>

<h3>intrinisic::getUTCMonth&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>getUTCMonth</code> method retrieves the month number of the Date object, in UTC.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> A month number (<span class="xref">month number</span>).

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function getUTCMonth() : double
    let (t = timeval)
        isNaN(t) ? t : MonthFromTime(t);
</PRE>

<h3>intrinisic::getDate&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>getDate</code> method retrieves the date number of the Date object, in the local time zone.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> A date number (<span class="xref">date number</span>).

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function getDate() : double
    let (t = timeval)
        isNaN(t) ? t : DateFromTime(LocalTime(t));
</PRE>

<h3>intrinisic::getUTCDate&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>getUTCDate</code> method retrieves the date number of the Date object, in UTC.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> A date number (<span class="xref">date number</span>).

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function getUTCDate() : double
    let (t = timeval)
        isNaN(t) ? t : DateFromTime(t);
</PRE>

<h3>intrinisic::getDay&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>getDay</code> method retrieves the day number of the Date object, in the local time zone.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> A day number (<span class="xref">day number</span>).

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function getDay() : double
    let (t = timeval)
        isNaN(t) ? t : WeekDay(LocalTime(t));
</PRE>

<h3>intrinisic::getUTCDay&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>getUTCDay</code> method retrieves the day number of the Date object, in UTC.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> A day number (<span class="xref">day number</span>).

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function getUTCDay() : double
    let (t = timeval)
        isNaN(t) ? t : WeekDay(t);
</PRE>

<h3>intrinisic::getHours&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>getHours</code> method retrieves the hours value of the Date object, in the local time zone.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> An hours value (<span class="xref">hours, minutes, seconds, and milliseconds</span>).

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function getHours() : double
    let (t = timeval)
        isNaN(t) ? t : HourFromTime(LocalTime(t));
</PRE>

<h3>intrinisic::getUTCHours&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>getUTCHours</code> method retrieves the hours value of the Date object, in UTC.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> An hours value (<span class="xref">hours, minutes, seconds, and milliseconds</span>).

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function getUTCHours() : double
    let (t = timeval)
        isNaN(t) ? t : HourFromTime(t);
</PRE>

<h3>intrinisic::getMinutes&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>getMinutes</code> method retrieves the minutes value of the Date object, in the local time zone.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> A minutes value (<span class="xref">hours, minutes, seconds, and milliseconds</span>).

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function getMinutes() : double
    let (t = timeval)
        isNaN(t) ? t : MinFromTime(LocalTime(t));
</PRE>

<h3>intrinisic::getUTCMinutes&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>getUTCMinutes</code> method retrieves the minutes value of the Date object, in UTC.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> A minutes value (<span class="xref">hours, minutes, seconds, and milliseconds</span>).

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function getUTCMinutes() : double
    let (t = timeval)
        isNaN(t) ? t : MinFromTime(t);
</PRE>

<h3>intrinisic::getSeconds&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>getSeconds</code> method retrieves the seconds value of the Date object, in the local time zone.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> A seconds value (<span class="xref">hours, minutes, seconds, and milliseconds</span>).

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function getSeconds() : double
    let (t = timeval)
        isNaN(t) ? t : SecFromTime(LocalTime(t));
</PRE>

<h3>intrinisic::getUTCSeconds&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>getUTCSeconds</code> method retrieves the seconds value of the Date object, in UTC.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> A seconds value (<span class="xref">hours, minutes, seconds, and milliseconds</span>).

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function getUTCSeconds() : double
    let (t = timeval)
        isNaN(t) ? t : SecFromTime(t);
</PRE>

<h3>intrinisic::getMilliseconds&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>getMilliseconds</code> method retrieves the milliseconds value of the Date object, in the local time zone.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> A milliseconds value (<span class="xref">hours, minutes, seconds, and milliseconds</span>).

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function getMilliseconds() : double
    let (t = timeval)
        isNaN(t) ? t : msFromTime(LocalTime(t));
</PRE>

<h3>intrinisic::getUTCMilliseconds&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>getUTCMilliseconds</code> method retrieves the milliseconds value of the Date object, in UTC.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> A milliseconds value (<span class="xref">hours, minutes, seconds, and milliseconds</span>).

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function getUTCMilliseconds() : double
    let (t = timeval)
        isNaN(t) ? t : msFromTime(t);
</PRE>

<h3>intrinisic::getTimezoneOffset&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> Computes the difference between local time and UTC time.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> A possibly non-integer number of minutes.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function getTimezoneOffset() : double
    let (t = timeval)
        isNaN(t) ? t : (t - LocalTime(t)) / msPerMinute;
</PRE>

<h3>intrinisic::setTime&nbsp;(time)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>setTime</code> method sets the time value of the Date object.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The new time value.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function setTime(t:double) : double
    timeval = TimeClip(t);
</PRE>

<h3>intrinisic::setMilliseconds&nbsp;(ms)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>setMilliseconds</code> method sets the milliseconds value of the Date object, taking <i>ms</i> to be
a value in the local time zone.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The new time value.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function setMilliseconds(ms:double) : double
    timeval = let (t = LocalTime(timeval))
                  UTCTime(MakeDate(Day(t), MakeTime(HourFromTime(t),
                                                    MinFromTime(t),
                                                    SecFromTime(t),
                                                    ms)));
</PRE>


<h3>intrinisic::setUTCMilliseconds&nbsp;(ms)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>setUTCMilliseconds</code> method sets the milliseconds value of the Date object, taking <i>ms</i> to be
a value in UTC.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The new time value.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function setUTCMilliseconds(ms:double) : double
    timeval = let (t = timeval)
                  MakeDate(Day(t), MakeTime(HourFromTime(t),
                                            MinFromTime(t),
                                            SecFromTime(t),
                                            ms));
</PRE>


<h3>intrinisic::setSeconds&nbsp;(sec,&nbsp;ms=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>setSeconds</code> method sets the seconds value (and
optionally the milliseconds value) of the Date object, taking <i>sec</i>
and <i>ms</i> to be values in the local time zone.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The new time value.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function setSeconds(sec:double, ms:double = getMilliseconds()) : double
    timeval = let (t = LocalTime(timeval))
                  UTCTime(MakeDate(Day(t), MakeTime(HourFromTime(t),
                                                    MinFromTime(t),
                                                    sec,
                                                    ms)));
</PRE>

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #193.) Default arguments: is this the way we want it?

<P class="fixme"> For this and the following methods the signature has
the following impliciation: if a program subclasses Date and overrides
the intrinsic <code>getMilliseconds()</code> method, the new method <i>will</i> be
invoked if setSeconds is called with one argument.

<P class="fixme"> There are various ways to avoid this, though I don't
think it's really a problem that there is this dependence, except that
it binds implementations in how they represent and handle dates.

<P class="fixme"> 3rd Edition has imprecise language here, it says
that if ms is not provided by the caller then its value will be as if
<i>ms</i> were specified with the value <i>getMilliseconds()</i>.  Whether
that implies that that method is called (and that the user could
override it) or not is not at all clear.


<h3>intrinisic::setUTCSeconds&nbsp;(sec,&nbsp;ms=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>setUTCSeconds</code> method sets the seconds value (and optionally the 
milliseconds value) of the Date object,  taking <i>sec</i> and <i>ms</i> to be values in UTC.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The new time value.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function setUTCSeconds(sec:double, ms:double = getUTCMilliseconds()) : double
    timeval = let (t = timeval)
                  MakeDate(Day(t), MakeTime(HourFromTime(t),
                                            MinFromTime(t),
                                            sec,
                                            ms));
</PRE>

<h3>intrinisic::setMinutes&nbsp;(min,&nbsp;sec=&#x0085;,&nbsp;ms=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>setMinutes</code> method sets the minutes value (and optionally the seconds and 
milliseconds values) of the Date object,  taking <i>min</i>, <i>sec</i> and <i>ms</i> to be values in the 
local time zone.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The new time value.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function setMinutes(min:double,
                              sec:double = getSeconds(),
                              ms:double = getMilliseconds()) : double
    timeval = let (t = LocalTime(timeval))
                  UTCTime(MakeDate(Day(t), MakeTime(HourFromTime(t),
                                                    min,
                                                    sec,
                                                    ms)));
</PRE>

<h3>intrinisic::setUTCMinutes&nbsp;(min,&nbsp;sec=&#x0085;,&nbsp;ms=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>setUTCMinutes</code> method sets the minutes value (and optionally the seconds 
and milliseconds values) of the Date object,  taking <i>min</i>, <i>sec</i> and <i>ms</i> to be values in UTC.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The new time value.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function setUTCMinutes(min:double,
                                 sec:double = getUTCSeconds(),
                                 ms:double = getUTCMilliseconds()) : double
    timeval = let (t = timeval)
                  MakeDate(Day(t), MakeTime(HourFromTime(t),
                                            min,
                                            sec,
                                            ms));
</PRE>

<h3>intrinisic::setHours&nbsp;(hour,&nbsp;min=minutes,&nbsp;sec=&#x0085;,&nbsp;ms=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>setHours</code> method sets the hours value (and optionally the minutes, seconds, and 
milliseconds values) of the Date object,  taking <i>hour</i>, <i>min</i>, <i>sec</i> and <i>ms</i> to be values in the 
local time zone.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The new time value.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function setHours(hour: double,
                            min: double = getMinutes(),
                            sec: double = getSeconds(),
                            ms: double = getMilliseconds()) : double
    timeval = let (t = LocalTime(timeval))
                  UTCTime(MakeDate(Day(t), MakeTime(hour,
                                                    min,
                                                    sec,
                                                    ms)));
</PRE>

<h3>intrinisic::setUTCHours&nbsp;(hour,&nbsp;min=&#x0085;,&nbsp;sec=&#x0085;,&nbsp;ms=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>setUTCHours</code> method sets the hours value (and optionally the minutes, seconds, and 
milliseconds values) of the Date object,  taking <i>hour</i>, <i>min</i>, <i>sec</i> and <i>ms</i> to be values in UTC.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The new time value.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function setUTCHours(hour: double,
                               min: double = getUTCMinutes(),
                               sec: double = getUTCSeconds(),
                               ms: double = getUTCMilliseconds()) : double
    timeval = let (t = timeval)
                  MakeDate(Day(t), MakeTime(hour,
                                            min,
                                            sec,
                                            ms));
</PRE>

<h3>intrinisic::setDate&nbsp;(date)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>setDate</code> method sets the date value of the Date object, taking <i>date</i> to be
a value in the local time zone.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The new time value.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function setDate(date: double): double
    timeval = let (t = LocalTime(timeval))
                  UTCTime(MakeDate(MakeDay(YearFromTime(t), MonthFromTime(t), date),
                                   TimeWithinDay(t)));
</PRE>

<h3>intrinisic::setUTCDate&nbsp;(date)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>setUTCDate</code> method sets the date value of the Date object, taking <i>date</i> to be
a value in UTC.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The new time value.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function setUTCDate(date: double): double
    timeval = let (t = timeval)
                  MakeDate(MakeDay(YearFromTime(t), MonthFromTime(t), date),
                           TimeWithinDay(t));
</PRE>

<h3>intrinisic::setMonth&nbsp;(month,&nbsp;date=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>setMonth</code> method sets the month value (and optionally the date value) of 
the Date object, taking <i>month</i> and <i>date</i> to be values in the local time zone.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The new time value.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function setMonth(month:double, date:double = getDate()):double
    timeval = let (t = LocalTime(timeval))
                  UTCTime(MakeDate(MakeDay(YearFromTime(t), month, date),
                                   TimeWithinDay(t)));
</PRE>

<h3>intrinisic::setUTCMonth&nbsp;(month,&nbsp;date=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>setUTCMonth</code> method sets the month value (and optionally the date value) of 
the Date object, taking <i>month</i> and <i>date</i> to be values in UTC.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The new time value.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function setUTCMonth(month:double, date:double = getUTCDate()):double
    timeval = let (t = timeval)
                  MakeDate(MakeDay(YearFromTime(t), month, date),
                           TimeWithinDay(t));
</PRE>

<h3>intrinisic::setFullYear&nbsp;(year,&nbsp;month=&#x0085;,&nbsp;date=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>setFullYear</code> method sets the year value (and optionally the month and date 
values) of the Date object, taking <i>year</i>, <i>month</i>, and <i>date</i> to be values in the local time zone.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The new time value.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function setFullYear(year:double,
                               month:double = getMonth(),
                               date:double = getDate()) : double
    timeval = let (t = LocalTime(timeval))
                  UTCTime(MakeDate(MakeDay(year, month, date),
                                   TimeWithinDay(t)));
</PRE>

<h3>intrinisic::setUTCFullYear&nbsp;(year,&nbsp;month=&#x0085;,&nbsp;date=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>setFullYear</code> method sets the year value (and optionally the month and date 
values) of the Date object, taking <i>year</i>, <i>month</i>, and <i>date</i> to be values in UTC.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The new time value.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function setUTCFullYear(year:double,
                                  month:double = getUTCMonth(),
                                  date:double = getUTCDate()) : double
    timeval = let (t = timeval)
                  MakeDate(MakeDay(year, month, date),
                           TimeWithinDay(t));
</PRE>


<h2>Getters on Date instances</h2>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The Date object provides a number of getters that call the
object's corresponding accessor methods.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The getters all return what their corresponding accessor methods return.

<P class="implsection"><b>Implementation</b>
<PRE>
function get time(this:Date) : double
    getTime();

function get year(this:Date) : double
    getYear();

function get fullYear(this:Date) : double
    getFullYear();

function get UTCFullYear(this:Date) : double
    getUTCFullYear();

function get month(this:Date) : double
    getMonth();

function get UTCMonth(this:Date) : double
    getUTCMonth();

function get date(this:Date) : double
    getDate();

function get UTCDate(this:Date) : double
    getUTCDate();

function get day(this:Date) : double
    getDay();

function get UTCDay(this:Date) : double
    getUTCDay();

function get hours(this:Date) : double
    getHours();

function get UTCHours(this:Date) : double
    getUTCHours();

function get minutes(this:Date) : double
    getMinutes();

function get UTCMinutes(this:Date) : double
    getUTCMinutes();

function get seconds(this:Date) : double
    getSeconds();

function get UTCSeconds(this:Date) : double
    getUTCSeconds();

function get milliseconds(this:Date) : double
    getMilliseconds();

function get UTCMilliseconds(this:Date) : double
    getUTCMilliseconds();
</PRE>

<h2>Setters on Date instances</h2>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The Date object provides a number of setters that call the
object's corresponding updater methods.  Since the setters only accept
a single argument, the updaters will be called with default arguments
for all arguments beyond the first.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The setters all return what their corresponding updater methods return.

<P class="implsection"><b>Implementation</b>
<PRE>
function set time(this:Date, t : double) : double
    setTime(t);

function set year(this:Date, t: double) : double
    setYear(t);

function set fullYear(this:Date, t : double) : double
    setFullYear(t);

function set UTCFullYear(this:Date, t : double) : double
    setUTCFullYear(t);

function set month(this:Date, t : double) : double
    setMonth(t);

function set UTCMonth(this:Date, t : double) : double
    setUTCMonth(t);

function set date(this:Date, t : double) : double
    setDate(t);

function set UTCDate(this:Date, t : double) : double
    setUTCDate(t);

function set hours(this:Date, t : double) : double
    setHours(t);

function set UTCHours(this:Date, t : double) : double
    setUTCHours(t);

function set minutes(this:Date, t : double) : double
    setMinutes(t);

function set UTCMinutes(this:Date, t : double) : double
    setUTCMinutes(t);

function set seconds(this:Date, t : double) : double
    setSeconds(t);

function set UTCSeconds(this:Date, t : double) : double
    setUTCSeconds(t);

function set milliseconds(this:Date, t : double) : double
    setMilliseconds(t);

function set UTCMilliseconds(this:Date, t : double) : double
    setUTCMilliseconds(t);
</PRE>




<h2>Method properties on the <code>Date</code> prototype object</h2>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The <code>Date</code> prototype methods are not generic; their <code>this</code>
object must be a <code>Date</code>.  The methods forward the call to the
corresponding intrinsic method in all cases.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>Date</code> prototype methods return the values returned by
the intrinsic methods they call.

<P class="implsection"><b>Implementation</b>
<PRE>
prototype function toString(this:Date)
    this.intrinsic::toString();

prototype function toDateString(this:Date)
    this.toDateString();

prototype function toTimeString(this:Date)
    this.toTimeString();

prototype function toLocaleString(this:Date)
    this.toLocaleString();

prototype function toLocaleDateString(this:Date)
    this.toLocaleDateString();

prototype function toLocaleTimeString(this:Date)
    this.toLocaleTimeString();

prototype function toUTCString(this:Date)
    this.toUTCString();

prototype function toISOString(this:Date)
    this.toISOString();

prototype function valueOf(this:Date)
    this.valueOf();

prototype function getTime(this:Date)
    this.intrinsic::getTime();

prototype function getFullYear(this:Date)
    this.intrinsic::getFullYear();

prototype function getUTCFullYear(this:Date)
    this.intrinsic::getUTCFullYear();

prototype function getMonth(this:Date)
    this.intrinsic::getMonth();

prototype function getUTCMonth(this:Date)
    this.intrinsic::getUTCMonth();

prototype function getDate(this:Date)
    this.intrinsic::getDate();

prototype function getUTCDate(this:Date)
    this.intrinsic::getUTCDate();

prototype function getDay(this:Date)
    this.intrinsic::getDay();

prototype function getUTCDay(this:Date)
    this.intrinsic::getUTCDay();

prototype function getHours(this:Date)
    this.intrinsic::getHours();

prototype function getUTCHours(this:Date)
    this.intrinsic::getUTCHours();

prototype function getMinutes(this:Date)
    this.intrinsic::getMinutes();

prototype function getUTCMinutes(this:Date)
    this.intrinsic::getUTCMinutes();

prototype function getSeconds(this:Date)
    this.intrinsic::getSeconds();

prototype function getUTCSeconds(this:Date)
    this.intrinsic::getUTCSeconds();

prototype function getMilliseconds(this:Date)
    this.intrinsic::getMilliseconds();

prototype function getUTCMilliseconds(this:Date)
    this.intrinsic::getUTCMilliseconds();

prototype function getTimezoneOffset(this:Date)
    this.intrinsic::getTimezoneOffset();

prototype function setTime(this:Date, t)
    this.intrinsic::setTime(double(t));

prototype function setMilliseconds(this:Date, ms)
    this.intrinsic::setMilliseconds(double(ms))

prototype function setUTCMilliseconds(this:Date, ms)
    this.intrinsic::setUTCMilliseconds(double(ms));

prototype function setSeconds(this:Date, sec, ms = getMilliseconds())
    this.intrinsic::setSeconds(double(sec), double(ms));

prototype function setUTCSeconds(this:Date, sec, ms = getUTCMilliseconds())
    this.intrinsic::setUTCSeconds(double(sec), double(ms));

prototype function setMinutes(this:Date, min, sec = getSeconds(), ms = getMilliseconds())
    this.intrinsic::setMinutes(double(min), double(sec), double(ms));

prototype function setUTCMinutes(this:Date, min, sec = getUTCSeconds(), ms = getUTCMilliseconds())
    this.intrinsic::setUTCMinutes(double(min), double(sec), double(ms));

prototype function setHours(this:Date, hour, min=getMinutes(), sec=getSeconds(), ms=getMilliseconds())
    this.intrinsic::setHours(double(hour), double(min), double(sec), double(ms));

prototype function setUTCHours(this:Date,
                               hour,
                               min=getUTCMinutes(),
                               sec=getUTCSeconds(),
                               ms=getUTCMilliseconds())
    this.intrinsic::setUTCHours(double(hour), double(min), double(sec), double(ms));

prototype function setDate(this:Date, date)
    this.intrinsic::setDate(double(date));

prototype function setUTCDate(this:Date, date)
    this.intrinsic::setUTCDate(double(date));

prototype function setMonth(this:Date, month, date=getDate())
    this.intrinsic::setMonth(double(month), double(date));

prototype function setUTCMonth(this:Date, month, date=getUTCDate())
    this.intrinsic::setUTCMonth(double(month), double(date));

prototype function setFullYear(this:Date, year, month=getMonth(), date=getDate())
    this.intrinsic::setFullYear(double(year), double(month), double(date));

prototype function setUTCFullYear(this:Date, year, month=getUTCMonth(), date=getUTCDate())
    this.intrinsic::setUTCFullYear(double(year), double(month), double(date));
</PRE>



<H1 id="class RegExp"> The class <code>RegExp</code> </H1>

<PRE>
FILE:                       spec/library/RegExp.html
DRAFT STATUS:               DRAFT 1 - ROUGH - 2007-09-20
REVIEWED AGAINST ES3:       NO
REVIEWED AGAINST ERRATA:    NO
REVIEWED AGAINST BASE DOC:  NO
REVIEWED AGAINST PROPOSALS: NO
REVIEWED AGAINST CODE:      NO
</PRE>


<P><span class="pcounter"></span> The class <code>RegExp</code> is a dynamic, nullable, non-final, direct
subclass of <code>Object</code>.

<P><span class="pcounter"></span> A RegExp object contains a regular expression <i>pattern</i> and the
associated <i>flags</i>.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The form and functionality of regular expressions is modelled
after the regular expression facility in the Perl 5 programming
language.

<P><span class="pcounter"></span> A regular expression is transformed ("compiled") into a
<i>matcher</i> function that can be used to <i>match</i> an <i>input
string</i>: to test whether the input string has a certain form or
contains substrings of a certain form, where the form is defined by
the regular expression.

<P><span class="pcounter"></span> The intrinsic <code>exec</code> method on a <code>RegExp</code> object drives the
matching by invoking the matcher on a string and an offset within the
string to determine whether the pattern would match starting at
exactly that offset within the string, and, if it does match, what the
values of the capturing parentheses would be.

<P><span class="pcounter"></span> Regular expression patterns are written down using a compact and
rich source syntax that is separate from the syntax of the surrounding
language.  A grammar for this syntax is presented below (<span class="xref">RegExp grammar</span>).

<P><span class="pcounter"></span> The regular expression flags modify the meaning of the pattern in
various ways, for example by specifying case-insensitivity, the
meaning of white space, or how to perform the matching.

<P><span class="pcounter"></span> This Standard defines the meaning of regular expressions in two
stages: declaratively as a mapping from surface syntax to abstract
syntax trees, and then operationally (in ECMAScript itself) as an
interpreter that performs matching of input strings by interpreting
those abstract syntax trees.

<P><span class="pcounter"></span> Compiling a pattern may throw a <code>SyntaxError</code> exception; on the
other hand, once the pattern is successfully compiled, applying the
compiled pattern to find a match in a string cannot throw an exception
(except for any host-defined exceptions that can occur anywhere such
as out-of-memory).

<P><span class="pcounter"></span> The abstract syntax trees for regular expressions are represented
as trees of ECMAScript objects.  These objects are all instances of
specific ECMAScript classes, which are presented below (<span class="xref">RegExp ASTs</span>).

<h2>Synopsis</h2>

<P><span class="pcounter"></span> The class <code>RegExp</code> provides the following interface:

<PRE>
dynamic class RegExp
{
    function RegExp( pattern, flags ) &#x0085
    meta static function invoke( pattern, flags ) &#x0085

    static const length: uint = 2

    override intrinsic function toString() : string &#x0085

    intrinsic function exec(s : string) : Array &#x0085
    intrinsic function test(s : string) : boolean &#x0085

    meta function invoke(s : string) : Array &#x0085

    const source: string = &#x0085; 
    const global: boolean = &#x0085;
    const ignoreCase: boolean = &#x0085;
    const multiline: boolean = &#x0085;
    const extended: boolean = &#x0085;
    const sticky: boolean = &#x0085;

    final function get lastIndex() &#x0085
    final function set lastIndex(x) &#x0085
}
</PRE>

<P><span class="pcounter"></span> The <code>RegExp</code> prototype object provides the following direct
dynamic properties:

<PRE>
    exec:     function (s) &#x0085; ,
    test:     function (s) &#x0085; ,
    toString: function () &#x0085;
</PRE>

<h2>Surface syntax and mapping to abstract syntax trees</h2>

<h3 id="RegExp grammar"> Grammar </h3>

<P><span class="pcounter"></span> The <code>RegExp</code> constructor applies the following grammar to the
pattern string.  A <b>SyntaxError</b> exception is thrown if the
grammar cannot recognize the string as an expansion of the nonterminal
<i>Pattern</i>.

<P><span class="pcounter"></span> The grammar acts as a transformer from segments of the pattern
string into abstract syntax (sub)trees.  A transformation computation
of one of the following types is associated with each production in
the grammar.

<UL>

  <LI> The construction of an abstract syntax tree node.  Construction
  appears as the call to a factory function for the node, denoted by
  an identifier in boldface with an initial capital letter.  The
  factory functions map directly to the constructors for the
  respective abstract syntax tree classes, described in section <span class="xref">RegExp.matching</span>.

  <LI> The computation of a value, which may be a string, a number, or
  an abstract syntax tree node.  Computation appears as the call to a
  helper function, denoted by an identifier in boldface with an
  initial lower-case letter.

  <LI> The construction or destructuring of value tuples that carry
  multiple values from a production to a surrounding production.
  Tuple construction and destructuring use the ECMAScript syntax for
  constructing and destructuring Array values.
  
  <LI> The extraction of a token value from the production.
  Extraction appears as the use of the name of the token in the
  computation.

</UL>

<P><span class="pcounter"></span> The definition language also has side computations, side
conditions, and error conditions.  These are suffixed to a
transformation computation.

<UL>

  <LI> Side computations bind temporary names to values and are
  introduced by <code>where</code> clauses.

  <LI> Side conditions test the applicability of a production and are
  introduced by <code>provided</code> clauses.

  <LI> Error conditions throw a <b>SyntaxError</b> exception if they do
  not hold and are introduced by <code>requires</code> clauses.

</UL>

<PRE style="font-style: italic; page-break-inside: avoid">
Pattern ::
    Disjunction                  => <b>RegExpMatcher</b>( Disjunction )
</PRE>
<PRE style="font-style: italic; page-break-inside: avoid">
Disjunction ::
    Alternative                  => Alternative
    Alternative <span class="literal">|</span> Disjunction    => <b>Disjunct</b>( Alternative, Disjunction )
</PRE>
<PRE style="font-style: italic; page-break-inside: avoid">
Alternative ::
    [empty]                      => <b>Empty</b>()
    Alternative Term             => <b>Conjunct</b>( Alternative, Term )
</PRE>
<PRE style="font-style: italic; page-break-inside: avoid">
Term ::
    Assertion                    => Assertion
    Atom                         => Atom
    Atom Quantifier              => <b>Quantified</b>(parenIndex,
                                               parenCount,
                                               atom,
                                               min,
                                               max,
                                               greedy)
                                    where [min, max, greedy] = Quantifier
                                    requires min &#x2264; max
</PRE>
<PRE style="font-style: italic; page-break-inside: avoid">
Assertion ::
    <span class="literal">^</span>                            => <b>AssertStartOfInput</b>()
    <span class="literal">$</span>                            => <b>AssertEndOfInput</b>()
    <span class="literal">\</span> <span class="literal">b</span>                          => <b>AssertWordBoundary</b>()
    <span class="literal">\</span> <span class="literal">B</span>                          => <b>AssertNotWordBounary</b>()
</PRE>
<PRE style="font-style: italic; page-break-inside: avoid">
Quantifier ::
    QuantifierPrefix             => [min, max, <b>true</b>] where [min, max] = QuantifierPrefix
    QuantifierPrefix <span class="literal">?</span>           => [min, max, <b>false</b>] where [min, max] = QuantifierPrefix
</PRE>
<PRE style="font-style: italic; page-break-inside: avoid">
QuantifierPrefix ::
    <span class="literal">*</span>                            => [0, &#x221E;]
    <span class="literal">+</span>                            => [1, &#x221E;]
    <span class="literal">?</span>                            => [0, 1]
    <span class="literal">{</span> DecimalDigits <span class="literal">}</span>            => [DecimalDigits, DecimalDigits]
    <span class="literal">{</span> DecimalDigits <span class="literal">,</span> <span class="literal">}</span>          => [DecimalDigits, &#x221E;]
    <span class="literal">{</span> DecimalDigits<sub>1</sub> <span class="literal">,</span> DecimalDigits<sub>2</sub> <span class="literal">}</span>
                                 => [DecimalDigits<sub>1</sub>, DecimalDigits<sub>2</sub>]
</PRE>
<PRE style="font-style: italic; page-break-inside: avoid">
Atom ::
    PatternCharacter             => <b>CharacterSet</b>( <b>CharsetAdhoc</b>( PatternCharacter ) )
    <span class="literal">.</span>                            => <b>CharacterSet</b>( <b>CharsetComplement</b>( charset_linebreak ) )
    <span class="literal">\</span> DecimalEscape              => <b>Backref</b>( DecimalEscape )
                                    requires that the regular expression as a whole has
                                             at least DecimalEscape capturing parentheses
    <span class="literal">\</span> CharacterEscape            => <b>CharacterSet</b>( <b>CharsetAdhoc</b>( CharacterEscape ) ) )
    <span class="literal">\</span> CharacterClassEscape       => <b>CharacterSet</b>( CharacterClassEscape )
    CharacterClass               => <b>CharacterSet</b>( CharacterClass )
    <span class="literal">(</span> Disjunction <span class="literal">)</span>              => <b>Capturing</b>( Disjunction, parenIndex+1 )
    <span class="literal">(</span> <span class="literal">?</span> <span class="literal">:</span> Disjunction <span class="literal">)</span>          => Disjunction
    <span class="literal">(</span> <span class="literal">?</span> <span class="literal">=</span> Disjunction <span class="literal">)</span>          => <b>PositiveLookahead</b>( Disjunction )
    <span class="literal">(</span> <span class="literal">?</span> <span class="literal">!</span> Disjunction <span class="literal">)</span>          => <b>NegativeLookahead</b>( Disjunction )
    <span class="literal">(</span> <span class="literal">?</span> <span class="literal">#</span> <span style="font-size: smaller; font-style: normal">[sequence matching [^)]*]</span> <span class="literal">)</span> => <b>Empty</b>()
    <span class="literal">(</span> <span class="literal">?</span> <span class="literal">P</span> <span class="literal"><</span> Identifier <span class="literal">></span> Disjunction <span class="literal">)</span>
                                 => <b>Capturing</b>( Disjunction, <b>capno</b>( Identifier ) )
                                    where <b>capno</B>( Identifier ) is defined as parenIndex+1
    <span class="literal">(</span> <span class="literal">?</span> <span class="literal">P</span> <span class="literal">=</span> Identifier <span class="literal">)</span>         => <b>Backref</b>( <b>capno</b>( Identifier ) )
</PRE>
<PRE style="font-style: italic; page-break-inside: avoid">
PatternCharacter ::
    SourceCharacter <span class="literal">but not any of ^ $ \ . * + ? ( ) [ ] { } |</span>
                                 => SourceCharacter
</PRE>
<PRE style="font-style: italic; page-break-inside: avoid">
CharacterEscape ::
    ControlEscape                => ControlEscape
    <span class="literal">c</span> ControlLetter              => <b>chr</b>(<b>ord</b>( ControlLetter ) / 32)
    HexEscapeSequence            => HexEscapeSequence
    UnicodeEscapeSequence        => UnicodeEscapeSequence
    IdentityEscape               => IdentityEscape
</PRE>
<PRE style="font-style: italic; page-break-inside: avoid">
ControlEscape ::
    <span class="literal">f</span>                            => <span class="literal">'\u000C'</span>
    <span class="literal">n</span>                            => <span class="literal">'\u000A'</span>
    <span class="literal">r</span>                            => <span class="literal">'\u000D'</span>
    <span class="literal">t</span>                            => <span class="literal">'\u0009'</span>
    <span class="literal">v</span>                            => <span class="literal">'\u000B'</span>
</PRE>
<PRE style="font-style: italic; page-break-inside: avoid">
ControlLetter :: <span class="literal">one of</span>
    <span class="literal">a b c d e f g h i j k l m n o p q r s t u v w x y z</span>
    <span class="literal">A B C D E F G H I J K L M N O P Q R S T U V W X Y Z</span>
                                 => ControlLetter
</PRE>
<PRE style="font-style: italic; page-break-inside: avoid">
IdentityEscape ::
    SourceCharacter <span class="literal">but not</span> IdentifierPart
                                 => SourceCharacter
</PRE>
<PRE style="font-style: italic; page-break-inside: avoid">
DecimalEscape ::
    DecimalIntegerLiteral <span style="font-size: smaller; font-style: normal">[lookahead not in DecimalDigit]</span>
                                 => <b>dec</b>( DecimalIntegerLiteral )
</PRE>
<PRE style="font-style: italic; page-break-inside: avoid">
CharacterClassEscape ::
    <span class="literal">d</span>                           => charset_digit
    <span class="literal">D</span>                           => <b>CharsetComplement</b>( charset_digit )
    <span class="literal">s</span>                           => charset_space
    <span class="literal">S</span>                           => <b>CharsetComplement</b>( charset_space )
    <span class="literal">w</span>                           => charset_word
    <span class="literal">W</span>                           => <b>CharsetComplement</b>( charset_word )
    <span class="literal">p</span> <span class="literal">{</span> UnicodeClass <span class="literal">}</span>          => <b>unicodeClass</b>( UnicodeClass )
    <span class="literal">P</span> <span class="literal">{</span> UnicodeClass <span class="literal">}</span>          => <b>CharsetComplement</b>( <b>unicodeClass</b>( UnicodeClass ) )
</PRE>
<PRE style="font-style: italic; page-break-inside: avoid">
CharacterClass ::
    <span class="literal">[</span> CharacterClassBody <span class="literal">]</span>      => <b>merge</b>( U, I )
                                   where [U, I] = CharacterClassBody
</PRE>
<PRE style="font-style: italic; page-break-inside: avoid">
CharacterClassBody ::
    <span style="font-size: smaller; font-style: normal">[lookahead not in {^}]</span> ClassRanges
                                => ClassRanges
    <span class="literal">^</span> ClassRanges               => [[ <b>CharsetComplement</b>( merge( U, I ) ) ], []]
                                   where [U, I] = ClassRanges
</PRE>
<PRE style="font-style: italic; page-break-inside: avoid">
ClassRanges ::
    [empty]                     => [[ <b>CharsetEmpty</b>() ], []]
    NonemptyClassranges         => NonemptyClassRanges
</PRE>
<PRE style="font-style: italic; page-break-inside: avoid">
NonemptyClassRanges ::
    ClassRange                  => ClassRange
    ClassRange NonemptyClassRanges
                                => [[union<sub>1</sub>, union<sub>2</sub>&#x0085;], [intersection<sub>1</sub>, intersection<sub>2</sub>&#x0085;]]
                                   where [union<sub>1</sub>, intersection<sub>1</sub>] = ClassRange
                                     and [union<sub>2</sub>&#x0085;, intersection<sub>2</sub>&#x0085;] = NonemptyClassRanges
</PRE>
<PRE style="font-style: italic; page-break-inside: avoid">
ClassRange ::
    ClassAtom                   => [[ClassAtom],[]]
                                   provided the next production does not apply
    ClassAtom<sub>1</sub> <span class="literal">-</span> ClassAtom<sub>2</sub>      => [[<b>CharsetRange</b>(ClassAtom<sub>1</sub>, ClassAtom<sub>2</sub>)],[]]
                                    requires that ClassAtom<sub>1</sub> and ClassAtom<sub>2</sub>
                                             have one element each and that
                                             the code point value of ClassAtom<sub>1</sub>
                                             is &#x2264; the code point value of ClassAtom<sub>2</sub>
    <span class="literal">&</span> <span class="literal">&</span> <span class="literal">[</span> CharacterClassBody <span class="literal">]</span>  => [[], [ <b>merge</b>( U, I ) ]]
                                    where [U, I] = CharacterClassBody
</PRE>
<PRE style="font-style: italic; page-break-inside: avoid">
ClassAtom ::
    <span class="literal">-</span>                            => <b>CharsetAdhoc</b>(<span class="literal">'-'</span>)
    <span class="literal">\</span> DecimalEscape              => <b>CharsetAdhoc</b>( <b>chr</b>( DecimalEscape ) )
    <span class="literal">\</span> <span class="literal">b</span>                          => <b>CharsetAdhoc</b>( <span class="literal">'\u0008'</span> )
    <span class="literal">\</span> CharacterEscape            => <b>CharsetAdhoc</b>( CharacterEscape )
    <span class="literal">\</span> CharacterClassEscape       => CharacterClassEscape
    SourceCharacter <span class="literal">but not one of \ ] -</span>
                                 => <b>CharsetAdhoc</b>( SourceCharacter )
</PRE>
<PRE style="font-style: italic; page-break-inside: avoid">
UnicodeClass ::
    Identifier                   => Identifier
                                    provided Identifier spells one of these names:
                                    <span class="literal">C Cc Cf Cn Co Cs L Ll Lm Lo Lt Lu M Mc Me Mn N Nd Nl No</span>
                                    <span class="literal">P Pc Pd Pe Pf Pi Po Ps S Sc Sk Sm So Z Zl Zp Zs</span>
</PRE>

<P><span class="pcounter"></span> <i>SourceCharacter</i>, <i>HexEscapeSequence</i>, <i>UnicodeEscapeSequence</i>, and
<i>IdentityEscape</i> are defined as part of the general ECMAScript
grammar (<span class="xref">language.grammar</span>) and all produce one-character
strings.

<P><span class="pcounter"></span> To every expansion of a production there belongs two variables,
<i>parenIndex</i> and <i>parenCount</i>.  <i>ParenIndex</i> represents the
number of left capturing parentheses in the entire regular expression
that occur to the left of the production expansion's initial token.
<i>ParenCount</i> represents the number of left capturing parentheses in
the expansion of the production.

<P><span class="pcounter"></span> Character set unions and intersections are represented explicitly
as data structures that reference the subsets that are the operands of
the union or intersection operator, respectively; sets are not
flattened.

<P><span class="pcounter"></span> There are four predefined character sets:
<UL>
  <LI> <i>charset_linebreak</i> contains the Unicode line terminator characters &lt;LF>, &lt;CR>, &lt;LS>, and &lt;PS>.
  <LI> <i>charset_digit</i> contains the decimal digit characters <code>0</code> through <code>9</code>
  <LI> <i>charset_space</i> contains all the Unicode <i>WhiteSpace</i> (<span class="xref">Unicode.whitespace</span>)
  and <i>LineTerminator</i> (<span class="xref">Unicode.lineterminator</span>) characters
  <LI> <i>charset_word</i> contains the upper-case letters <code>A</code> through <code>Z</code>,
       the lower-case letters <code>a</code> through <code>z</code>, the decimal digit characters <code>0</code> through <code>9</code>, and the underscore <code>_</code>.
</UL>

<P><span class="pcounter"></span> The helper function <code>chr</code> converts a Unicode code point value into the
corresponding Unicode character (a one-character string).

<P><span class="pcounter"></span> The helper function <code>ord</code> converts a one-character string into a
Unicode code point value.

<P><span class="pcounter"></span> The helper function <code>dec</code> converts the textual representation of
a nonnegative decimal integer into its integer value.

<P><span class="pcounter"></span> The helper function <code>merge</code> creates a single character set from
two collections of sets <i>U</i> and <i>I</i>, where the result set is the
union of the sets of <i>U</i>, intersected with the intersection of the
sets of <i>I</i> unless <i>I</i> is empty.

<P><span class="pcounter"></span> The helper function <code>capno</code> maps identifiers to capture numbers.

<P><span class="pcounter"></span> The helper function <code>unicodeClass</code> maps a one or two character
Unicode class name to a character set containing the characters in
that Unicode class.

<P><span class="pcounter"></span> Even if the pattern ignores case, the case of the two ends of a
range is significant in determining which characters belong to the
range. Thus, for example, the pattern <code>/[E-F]/i</code> matches only the
letters <code>E</code>, <code>F</code>, <code>e</code>, and <code>f</code>, while the pattern <code>/[E-f]/i</code>
matches all upper and lower-case ASCII letters as well as the symbols
<code>[</code>, <code>\</code>, <code>]</code>, <code>^</code>, <code>_</code>, and <code>`</code>.

<P><span class="pcounter"></span> A <i>ClassAtom</i> can use any of the escape sequences that are
allowed in the rest of the regular expression except for <code>\b</code>,
<code>\B</code>, and backreferences.  Inside a CharacterClass, <code>\b</code> means the
backspace character, while <code>\B</code> and backreferences raise errors.
Using a backreference inside a <i>ClassAtom</i> causes an error.

<P><span class="pcounter"></span> <i>ClassRanges</i> can expand into single <i>ClassAtoms</i> and/or
ranges of two <i>ClassAtoms</i> separated by dashes.  In the latter case
the <i>ClassRanges</i> includes all characters between the first
ClassAtom and the second <i>ClassAtom</i>, inclusive; an error occurs if
either <i>ClassAtom</i> does not represent a single character (for
example, if one is <code>\w</code>) or if the first <i>ClassAtom</i>'s code point
value is greater than the second <i>ClassAtom</i>'s code point value.

<P><span class="pcounter"></span> A <code>-</code> character can be treated literally or it can denote a
range.  It is treated literally if it is the first or last character
of <i>ClassRanges</i>, the beginning or end limit of a range
specification, or immediately follows a range specification.


<h3>White space and line comments</h3>

<P><span class="pcounter"></span> The grammar takes on one of two meanings depending on whether the
<code>x</code> flag was supplied to the regular expression constructor.

<P><span class="pcounter"></span> If the <code>x</code> flag was not supplied then all white space is treated
as literal characters (typically <i>SourceCharacter</i>) and the <code>#</code>
character, outside the context of the <code>(?#</code> character sequence, does
not mean anything special -- it is just another <i>SourceCharacter</i>.

<P><span class="pcounter"></span> If the <code>x</code> flag was supplied then white space is ignored in a
number of contexts and the <code>#</code> character, outside the context of the
<code>(?#</code> character sequence, starts a comment that ends when a line
terminator character is seen (the line terminator is not part of the
comment).  White space and line comments act as token separators but
are otherwise completely ignored.  The multi-character tokens of the
regular expression grammar inside which white space and line comments
break the token are:

<UL>
  <LI> the character sequences <code>(?:</code>, <code>(?=</code>, <code>(?!</code>, <code>(?#</code>, <code>(?P=</code>, <code>(?P<</code>, and <code>&&[</code>
  <LI> the character sequences starting with a backslash (<code>\</code>), except that white space and line
  comments are allowed immediately following the backslash
  <LI> <i>DecimalDigits</i> and <i>Identifier</i>
</UL>

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #194.) The definition on where whitespace is ignored /
not ignored needs to be stronger, particularly around backspace.  Eg,
<NOBR><code>\p{N}</code></NOBR> is the same as <NOBR><code>\p{ N }</code></NOBR> but not
the same as <NOBR><code>\p {N}</code></NOBR>.  We could go fascist and say that
the middle of those three is not allowed, but that seems unnatural.


<h2>Abstract syntax trees</h2>

<P><span class="pcounter"></span> The abstract syntax trees for regular expressions are represented
as trees of instances of the ECMAScript classes <code>Disjunct</code>,
<code>Conjunct</code>, <code>AssertStartOfInput</code>, <code>AssertEndOfInput</code>,
<code>AssertWordBoundary</code>, <code>AssertNotWordBoundary</code>, <code>Quantified</code>,
<code>Capturing</code>, <code>Backref</code>, <code>PositiveLookahead</code>,
<code>NegativeLookahead</code>, <code>CharacterSet</code>, and <code>Empty</code>.

<P><span class="pcounter"></span> These abstract syntax tree classes all implement the <code>Matcher</code>
interface, which requires them to provide a <code>match</code> method that
takes a matching context, a matching state, and a continuation, and
returns a result:

<PRE>
interface Matcher {
    function match(ctx: Context, x: State, c: Continuation): MatchResult
}
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The types <code>Context</code>, <code>State</code>, <code>Continuation</code>, and
<code>MatchResult</code> are described later, along with the matching
algorithm.

<P><span class="pcounter"></span> An additional set of classes, comprised of <code>CharsetEmpty</code>,
<code>CharsetUnion</code>, <code>CharsetIntersection</code>, <code>CharsetComplement</code>,
<code>CharsetRange</code>, and <code>CharsetAdhoc</code>, represents character sets and
unions, intersections, and complements of characters sets.  Each of
these implements the <code>CharsetMatcher</code> interface, which takes a
matching context and a single-character string and returns a truth
value:

<PRE>
interface CharsetMatcher {
    function match(ctx: Context, s: string): boolean;
}
</PRE>

<P><span class="pcounter"></span> All abstract syntax tree classes are described in detail below.


<h2>Matching</h2>

<P><span class="pcounter"></span> The <code>match</code> method of the object that implements the <code>Matcher</code>
interface attempts to match a middle subpattern (determined by the
type of matcher and its internal settings) of the pattern against the
input string, starting at the intermediate state given by its
<code>State</code> argument.  The <code>Continuation</code> argument is a closure that
matches the rest of the pattern.  After matching the subpattern of a
pattern to obtain a new <code>State</code>, the matcher then calls
<code>Continuation</code> on the new state to test if the rest of the pattern can
match as well.  If it can, the matcher returns the state returned by
the continuation; if not, the matcher may try different choices at its
choice points, repeatedly calling the continuation until it either
succeeds or all possibilities have been exhausted.

<P><span class="pcounter"></span> The interface to this machinery is the class <code>RegExpMatcher</code>,
which takes as arguments an input, a start position, and some flags,
and which constructs a matcher context, an internal state, and a final
continuation and then invokes its internal matcher on these values,
returning the result returned by the matcher.

<P><span class="pcounter"></span> A <code>Context</code> object describes constant values used by all the
matchers during the matching.

<PRE>
class Context
{
    const input       : string,
          inputLength : uint,
          ignoreCase  : boolean,
          multiline   : boolean
}
</PRE>

<P><span class="pcounter"></span> <code>input</code> is the string being matched by the regular
expression pattern; <code>inputLength</code> is the number of characters in
<code>input</code>; <code>ignoreCase</code> is <b>true</b> if the matching is
case-insensitive; and <code>multiline</code> is <b>true</b> if the matching allows
the <code>^</code> assertion to match at the beginning of a line and the <code>$</code>
assertion to match at the end of a line (and not just at the beginning
and end of the input, respectively).

<P><span class="pcounter"></span> A <code>State</code> object represents partial match states in the regular
expression matching algorithms.

<PRE>
class State
{
   const endIndex: uint,
         captures: CapArray
}

type CapArray = [(string,undefined)]
</PRE>


<P><span class="pcounter"></span> The <code>endIndex</code> is one plus the index of the last input character
matched so far by the pattern, while <code>captures</code> holds the results of
capturing parentheses. <code>Captures</code> is an array whose length is the
number of left capturing parentheses in the <i>pattern</i>.  The <i>n</i>th
element of <code>captures</code> is either a string that represents the value
obtained by the <i>n</i>th set of capturing parentheses or <b>undefined</b>
if the <i>n</i>th set of capturing parentheses hasn't been reached yet.
Due to backtracking, many states may be in use at any time during the
matching process.

<P><span class="pcounter"></span> A <code>MatchResult</code> is either a <code>State</code> or the special token
<b>failure</b> that indicates that the match failed:

<PRE>
type MatchResult = (State, &#x0085;)
const failure = &#x0085;
</PRE>
  
<P><span class="pcounter"></span> A Continuation function is a closure that takes a <code>Context</code> and
a <code>State</code> and returns a <code>MatchResult</code>:

<PRE>
type Continuation = function(Context, State): MatchResult;
</PRE>

<P><span class="pcounter"></span> The continuation attempts to match the remaining portion
(specified by the closure's already-bound arguments) of the pattern
against the input string, starting at the intermediate state given by
its <code>State</code> argument.  If the match succeeds, the continuation
returns the final <code>State</code> that it reached; if the match fails, the
continuation returns <b>failure</b>.


<h3>RegExpMatcher</h3>

<P><span class="pcounter"></span> The class <code>RegExpMatcher</code> drives the matching.  When its <code>match</code> method is invoked
it creates a <code>Context</code>, a <code>State</code>, a <code>Continuation</code>, and then it invokes its matcher
object---the result of compiling the <i>pattern</i>---on these values, returning the result
returned by the matcher.

<PRE>
function RegExpMatcher(matcher, nCapturingParens)
    : matcher = matcher
    , nCapturingParens = nCapturingParens
{
}

const matcher:          Matcher,
      nCapturingParens: uint

function match( input: string, endIndex: int, multiline: boolean, ignoreCase: boolean )
    : MatchResult
{
    return matcher.match(new Context(input, multiline, ignoreCase),
                         new State(endIndex, makeCapArray(nCapturingParens+1)),
                         function (ctx: Context, x: State): State? { return x } );
}
</PRE>

<P><span class="pcounter"></span> Capture arrays are created by <code>makeCapArray</code> and copied and
partly cleared by <code>copyCapArray</code>:

<PRE>
function makeCapArray(len: uint): CapArray {
    let a = []: CapArray;
    for ( let i = 0 ; i &#60; len ; i++ )
        a[i] = undefined;
    return a;
}

function copyCapArray(a: CapArray, parenIndex: uint, parenCount: uint): CapArray {
    let b = makeCapArray(a.length);
    for ( let i = 0 ; i &#60; a.length ; i++ )
        b[i] = a[i];

    for ( let k = parenIndex+1 ; k &#60;= parenIndex+parenCount ; k++ )
        b[k] = undefined;
    return b;
}
</PRE>

<h3>Disjunct</h3>

<P><span class="pcounter"></span> The class <code>Disjunct</code> represents a matcher that allows two alternatives:
<PRE>
function Disjunct(m1, m2) : m1=m1, m2=m2 {}

const m1: Matcher,
      m2: Matcher

public function match(ctx: Context, x: State, c: Continuation): MatchResult {
    let r = m1.match(ctx, x, c);
    if (r != failure)
        return r;
    return m2.match(ctx, x, c);
}
</PRE>

<P><span class="pcounter"></span> A <code>Disjunct</code> first tries to match the left alternative <i>m1</i>
(followed by the sequel of the regular expression); if it fails, it
tries to match the right alternative <i>m2</i> (followed by the sequel of
the regular expression). If <i>m1</i>, <i>m2</i>, and the sequel all have
choice points, all choices in the sequel are tried before moving on to
the next choice in <i>m1</i>. If choices in <i>m1</i> are exhausted, <i>m2</i>
is tried instead of <i>m1</i>.  Any capturing parentheses inside a
portion of the pattern skipped by <code>|</code> produce undefined values
instead of strings.  Thus, for example,

<PRE>
    /a|ab/.exec("abc")
</PRE>

returns the result "a" and not "ab". Moreover,

<PRE>
    /((a)|(ab))((c)|(bc))/.exec("abc")
</PRE>

returns the array

<PRE>
    ["abc", "a", "a", undefined, "bc", undefined, "bc"]
</PRE>

and not

<PRE>
    ["abc", "ab", undefined, "ab", "c", "c", undefined]
</PRE>


<h3>Conjunct</h3>

<P><span class="pcounter"></span> The class <code>Conjunct</code> represents a matcher that requires the
matching of two consecutive terms:

<PRE>
function Conjunct(m1, m2) : m1=m1, m2=m2 {}

const m1: Matcher,
      m2: Matcher

public function match(ctx: Context, x: State, c: Continuation): MatchResult {
    return m1.match(ctx,
                    x,
                    (function (ctx: Context, y: State): MatchResult
                         m2.match(ctx, y, c)) );
}
</PRE>

<P><span class="pcounter"></span> A <code>Conjunct</code> tries simultaneoulsly to match the terms <i>m1</i> and
<i>m2</i> on consecutive portions of the input string.  If <i>m1</i>,
<i>m2</i>, and the sequel of the regular expression all have choice
points, all choices in the sequel are tried before moving on to the
next choice in <i>m2</i>, and all choices in <i>m2</i> are tried before
moving on to the next choice in <i>m1</i>.

<h4>AssertStartOfInput</h4>

<P><span class="pcounter"></span> The Start-of-Input assertion succeeds without consuming input if
the current input position is at the start of the input or if the
match is multiline and the current position is at the start of a line.

<PRE>
public function match(ctx: Context, x: State, c: Continuation): MatchResult {
    let e = x.endIndex;
    if (e == 0 || ctx.multiline && isTerminator(ctx.input[e-1]))
        return c(ctx, x);
    return failure;
}
</PRE>

<P><span class="pcounter"></span> The helper function <code>isTerminator</code> takes a character <i>c</i> and
returns <b>true</b> if <i>c</i> is one of the Unicode line terminator
characters &lt;LF>, &lt;CR>, &lt;LS>, and &lt;PS>.

<h4>AssertEndOfInput</h4>

<P><span class="pcounter"></span> The End-of-Input assertion succeeds without consuming input if the
current input position is at the end of the input or if the match is
multiline and the current position is at the end of a line.

<PRE>
public function match(ctx: Context, x: State, c: Continuation): MatchResult {
    let e = x.endIndex;
    if (e == ctx.inputLength || ctx.multiline && isTerminator(ctx.input[e]))
        return c(ctx, x);
    return failure;
}
</PRE>

<h4>AssertWordBoundary</h4>

<P><span class="pcounter"></span> The Word-Boundary assertion succeeds without consuming input if
the current input position is inside a word and the previous position
is outside a word, or vice versa.

<PRE>
public function match(ctx: Context, x: State, c: Continuation): MatchResult {
    let e = x.endIndex;
    if (isREWordChar(ctx, e-1) != isREWordChar(ctx, e))
        return c(ctx, x);
    return failure;
}
</PRE>

<P><span class="pcounter"></span> The test for word character also takes boundary conditions into consideration:

<PRE>
function isREWordChar(ctx: Context, e: int): boolean {
    if (e == -1 || e == ctx.inputLength)
        return false;
    let c = ctx.input[e];
    return isWordChar(ctx.input[e]);
}
</PRE>

<P><span class="pcounter"></span> The helper function <code>isWordChar</code> takes a character <i>c</i> and
returns <b>true</b> if <i>c</i> is one of the upper-case ASCII letters <code>A</code>
through <code>Z</code>, one of the lower-case ASCII letters <code>a</code> through
<code>z</code>, one of the ASCII decimal digits <code>0</code> through <code>9</code>, or the
ASCII underbar <code>_</code>.

<h4>AssertNotWordBoundary</h4>

<P><span class="pcounter"></span> The Not-Word-Boundary assertion succeeds without consuming input
if neither the current input position is inside a word and the
previous position is outside a word, nor vice versa.

<PRE>
public function match(ctx: Context, x: State, c: Continuation): MatchResult {
    let e = x.endIndex;
    if (isREWordChar(ctx, e-1) == isREWordChar(ctx, e))
        return c(ctx, x);
    return failure;
}
</PRE>


<h3>Quantified</h3>

<P><span class="pcounter"></span> The class <code>Quantified</code> represents a matcher that succeeds if its
submatch <i>m</i> matches the input a certain number of times.

<PRE>
function Quantified(parenIndex, parenCount, m, min, max, greedy)
    : parenIndex=parenIndex
    , parenCount=parenCount
    , m=m
    , min=min
    , max=max
    , greedy=greedy

const parenIndex: uint,
      parenCount: uint,
      m: Matcher,
      min: double,
      max: double,
      greedy: boolean

public function match(ctx: Context, x: State, c: Continuation): MatchResult {

    function RepeatMatcher(min: double, max: double, x: State): MatchResult {
        function d(ctx: Context, y: State): MatchResult {
            if (min == 0 && y.endIndex == x.endIndex)
                return failure;
            else
                return RepeatMatcher(Math.max(0, min-1), max-1, y);
        }

        if (max == 0)
            return c(ctx, x);

        let xr = new State(x.endIndex, copyCapArray(x.captures, parenIndex, parenCount));

        if (min != 0)
            return m.match(ctx, xr, d);

        if (!greedy) {
            let z = c(ctx, x);
            if (z != failure)
                return z;
            return m.match(ctx, xr, d);
        }
        else {
            let z = m.match(ctx, xr, d);
            if (z != failure)
                return z;
            return c(ctx, x);
        }
    }

    return RepeatMatcher(min, max, x);
}
</PRE>

<P><span class="pcounter"></span> A pattern term <i>m</i> followed by a quantifier is repeated the
number of times specified by the quantifier.  A quantifier can be
non-greedy, in which case <i>m</i> is repeated as few times as possible
while still matching the sequel, or it can be greedy, in which case
<i>m</i> is repeated as many times as possible while still matching the
sequel.  <i>M</i> is repeated rather than the input string that it
matches, so different repetitions of <i>m</i> can match different input
substrings.

<P><span class="pcounter"></span> If <i>m</i> and the sequel of the regular expression all have choice
points, <i>m</i> is first matched as many (or as few, if non-greedy)
times as possible.  All choices in the sequel are tried before moving
on to the next choice in the last repetition of <i>m</i>.  All choices in
the last (nth) repetition of <i>m</i> are tried before moving on to the
next choice in the next-to-last (n-1)st repetition of <i>m</i>; at which
point it may turn out that more or fewer repetitions of <i>m</i> are now
possible; these are exhausted (again, starting with either as few or
as many as possible) before moving on to the next choice in the
(n-1)st repetition of Atom and so on.

<P><span class="pcounter"></span>Compare
<PRE>
    /a[a-z]{2,4}/.exec("abcdefghi")
</PRE>

which returns <code>"abcde"</code> with

<PRE>
    /a[a-z]{2,4}?/.exec("abcdefghi")
</PRE>

which returns <code>"abc"</code>.

<P><span class="pcounter"></span> Consider also

<PRE>
    /(aa|aabaac|ba|b|c)*/.exec("aabaac")
</PRE>

which, by the choice point ordering above, returns the array

<PRE>
    ["aaba", "ba"]
</PRE>

and not any of:

<PRE>
    ["aabaac", "aabaac"]
    ["aabaac", "c"]
</PRE>

<P><span class="pcounter"></span> The above ordering of choice points can be used to write a regular
expression that calculates the greatest common divisor of two numbers
(represented in unary notation). The following example calculates the
<i>gcd</i> of 10 and 15:

<PRE>
    "aaaaaaaaaa,aaaaaaaaaaaaaaa".replace(/^(a+)\1*,\1+$/,"$1")
</PRE>

which returns the <i>gcd</i> in unary notation <code>"aaaaa"</code>.

<P><span class="pcounter"></span> The helper function <code>copyCapArray</code> clears the portion of the
captures array between <i>parenIndex+1</i> and <i>parenIndex+parenCount</i>
inclusive each time <i>m</i> is repeated.  We can see its behaviour in the
regular expression

<PRE>
    /(z)((a+)?(b+)?(c))*/.exec("zaacbbbcac")
</PRE>

which returns the array

<PRE>
   ["zaacbbbcac", "z", "ac", "a", undefined, "c"]
</PRE>

and not

<PRE>
   ["zaacbbbcac", "z", "ac", "a", "bbb", "c"]
</PRE>

because each iteration of the outermost <code>*</code> clears all captured
strings contained in <i>m</i>, which in this case includes capture
strings numbered 2, 3, and 4.

<P><span class="pcounter"></span> The initial test of <code>RepeatMatcher</code>'s closure <code>d</code> states that,
once the minimum number of repetitions has been satisfied, any more
expansions of <i>m</i> that match the empty string are not considered for
further repetitions.  This prevents the regular expression engine from
falling into an infinite loop on patterns such as:

<PRE>
   /(a*)*/.exec("b")
</PRE>

or the slightly more complicated:

<PRE>
   /(a*)b\1+/.exec("baaaac")
</PRE>

which returns the array

<PRE>
   ["b", ""]
</PRE>

<h3>PositiveLookahead</h3>

<P><span class="pcounter"></span> The positive lookahead matcher succeeds without consuming input if
its contained matcher can match the input at the current location:

<PRE>
function PositiveLookahead(m) : m=m {}

const m: Matcher

public function match(ctx: Context, x: State, c: Continuation): MatchResult {
    let r = m.match(ctx,
                    x,
                    (function (ctx, y: State): MatchResult
                         y) );
    if (r == failure)
        return failure;
    return c(ctx, new State(x.endIndex, r.captures));
}
</PRE>

<P><span class="pcounter"></span> If <i>m</i> can match at the current position in several ways, only
the first one is tried.  Unlike other regular expression operators,
there is no backtracking into a <code>(?=</code> form (this unusual behaviour
is inherited from Perl).  This only matters when the <i>m</i>
contains capturing parentheses and the sequel of the pattern contains
backreferences to those captures.  For example,

<PRE>
    /(?=(a+))/.exec("baaabac")
</PRE>

matches the empty string immediately after the first <code>b</code> and therefore
returns the array:

<PRE>
    ["", "aaa"]
</PRE>

<P><span class="pcounter"></span> To illustrate the lack of backtracking into the lookahead, consider:

<PRE>
    /(?=(a+))a*b\1/.exec("baaabac")
</PRE>

This expression returns

<PRE>
    ["aba", "a"]
</PRE>

and not:

<PRE>
    ["aaaba", "a"]
</PRE>


<h3>NegativeLookahead</h3>

<P><span class="pcounter"></span> The negative lookahead matcher succeeds without consuming input if
its contained matcher fails to match the input at the current
location:

<PRE>
function NegativeLookahead(m) : m=m {}

const m: Matcher

public function match(ctx: Context, x: State, c: Continuation): MatchResult {
    let r = m.match(ctx,
                    x,
                    (function (ctx, y: State): MatchResult
                         y) );
    if (r != failure)
        return failure;
    return c(ctx, x);
}
</PRE>

<P><span class="pcounter"></span> <i>M</i> can contain capturing parentheses, but backreferences to
them only make sense from within <i>m</i> itself.  Backreferences to
these capturing parentheses from elsewhere in the pattern always
return <b>undefined</b> because the negative lookahead must fail for the
pattern to succeed.  For example,

<PRE>
    /(.*?)a(?!(a+)b\2c)\2(.*)/.exec("baaabaac")
</PRE>

looks for an <code>a</code> not immediately followed by some positive number
<i>n</i> of <code>a</code>'s, a <code>b</code>, another <i>n</i> <code>a</code>'s (specified by the
first <code>\2</code>) and a <code>c</code>. The second <code>\2</code> is outside the negative
lookahead, so it matches against undefined and therefore always
succeeds.  The whole expression returns the array:

<PRE>
    ["baaabaac", "ba", undefined, "abaac"]
</PRE>


<h3>CharacterSet</h3>

<P><span class="pcounter"></span> A <code>CharacterSet</code> matches the input at the current location if
the canonical representation of the character at the current location
is a member of the character set.

<PRE>
function CharacterSet(cs)
    : cs=cs {}

const cs: CharsetMatcher;

public function match(ctx: Context, x: State, c: Continuation) /*: MatchResult */ {
    let e = x.endIndex;
    let cap = x.captures;
    if (e == ctx.inputLength)
        return failure;
    let cc = Canonicalize(ctx, ctx.input[e]);
    let res = cs.match(ctx, cc);
    if (!res)
        return failure;
    return c(ctx, new State(e+1, cap));
}
</PRE>

<P><span class="pcounter"></span> The helper function <code>Canonicalize</code> converts a character to its
canonical form.  In case-significant matches the canonical form is the
character itself.  In case-insignificant matches all characters are
converted to upper case immediately before they are compared.

<PRE>
function Canonicalize(ctx, ch) {
    if (!ctx.ignoreCase)
        return ch;
    let u = ch.toUpperCase();
    if (u.length != 1)
        return ch;
    if (ch.charCodeAt(0) >= 128 && u.charCodeAt(0) &#60; 128)
        return ch;
    return u;
}
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  If converting a character to upper case would expand that
character into more than one character (such as converting "&#x00df;"
(\u00DF) into "SS"), then the character is left as-is instead.  The
character is also left as-is if it is not an ASCII character but
converting it to upper case would make it into an ASCII character.
This prevents Unicode characters such as \u0131 and \u017F from
matching regular expressions such as <code>/[a-z]/i</code>, which are only
intended to match ASCII letters.  Furthermore, if these conversions
were allowed, then <code>/[^\W]/i</code> would match each of <code>a</code>, <code>b</code>,
&#x0085;, <code>h</code>, but not <code>i</code> or <code>s</code>.


<h4>Character sets</h4>

<P><span class="pcounter"></span> A character set as passed to the <code>CharacterSet</code> constructor is a
mathematical set of characters.  However, in this Standard the sets
are provided with a concrete representation in order to present their
semantics operationally.

<P><span class="pcounter"></span> A character set is represented as a tree of objects that represent
unions, intersections, complements, ranges, and primitive sets
containing some number of single characters.  These data types are
presented in the following sections.

<h4>CharsetEmpty</h4>

<P><span class="pcounter"></span> The empty character set contains no characters, so matching always
fails.

<PRE>
public function match(ctx: Context, c: string): boolean {
    return false;
}
</PRE>

<h4>CharsetUnion</h4>

<P><span class="pcounter"></span> The union of two sets contains a character if either set contains it.

<PRE>
function CharsetUnion(m1,m2) : m1=m1, m2=m2 {}

const m1: Charset,
      m2: Charset

public function match(ctx: Context, c: string): boolean {
    return m1.match(ctx, c) || m2.match(ctx, c);
}
</PRE>

<h4>CharsetIntersection</h4>

<P><span class="pcounter"></span> The intersection of two sets contains a character if both sets contain it.

<PRE>
function CharsetIntersection(m1,m2) : m1=m1, m2=m2 {}

const m1: Charset,
      m2: Charset

public function match(ctx: Context, c: string): boolean {
    return m1.match(ctx, c) && m2.match(ctx, c);
}
</PRE>

<h4>CharsetComplement</h4>

<P><span class="pcounter"></span> A complemented character set contains a character if the contained set does
not contain the character.

<PRE>
function CharsetComplement(m) : m=m {}

const m: Charset

public function match(ctx: Context, c: string): boolean {
    return !m.match(ctx, c);
}
</PRE>

<h4>CharsetRange</h4>

<P><span class="pcounter"></span> A set representing a range contains a character if the character
matches the canonicalized value of one of the characters in the range.

<PRE>
function CharsetRange(lo,hi) : lo=lo, hi=hi {}

const lo: string,
      hi: string

public function match(ctx: Context, c: string): boolean {
    let lo_code = lo.charCodeAt(0);
    let hi_code = hi.charCodeAt(0);
    for ( let i=lo_code ; i &#60;= hi_code ; i++ )
        if (Canonicalize(ctx, string.fromCharCode(i)) == c)
            return true;
    return false;
}
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The strings <code>lo</code> and <code>hi</code> both contain a single character.

<h4>CharsetAdhoc</h4>

<P><span class="pcounter"></span> An ad-hoc character set contains a character <i>c</i> if the <i>c</i> is
equal to the canonicalized value of one of the characters in the set.

<PRE>
function CharsetAdhoc(cs) : cs=explodeString(cs) {}

const cs: [string]

public function match(ctx: Context, c: string): boolean {
    for ( let i=0 ; i &#60; cs.length ; i++ ) {
        if (Canonicalize(ctx, cs[i]) == c)
            return true;
    }
    return false;
}
</PRE>

<P><span class="pcounter"></span> The helper function <code>explodeString</code> converts a string into an
array containing the individual characters in the string, each
represented as a one-character string.

<PRE>
public function explodeString(s : string) : [string] {
    let cs = [] : [string];
    for ( let i=0 ; i &#60; s.length ; i++ )
        cs[i] = s[i];
    return cs;
}
</PRE>

<h3>Capturing</h3>

<P><span class="pcounter"></span> A capturing matcher succeeds if its contained matcher <i>m</i>
matches the input at the current location.  The string that is matched
by the contained matcher is saved in the captures array at index
<i>parenIndex</i>.

<PRE>
function Capturing(m, parenIndex) : m=m, parenIndex=parenIndex {}

const m: Matcher,
      parenIndex: uint

public function match(ctx: Context, x: State, c: Continuation): MatchResult {

    let function d( ctx: Context, y: State ): MatchResult {
        let cap = copyCapArray( y.captures, 0, 0 );
        let xe = x.endIndex;
        let ye = y.endIndex;
        cap[parenIndex+1] = ctx.input.substring(xe, ye);
        return c(ctx, new State(ye, cap));
    }

    return m.match(ctx, x, d);
}
</PRE>


<h3>Backref</h3>

<P><span class="pcounter"></span> A back-referencing matcher succeeds if the input at the current location
exactly matches the value in the captures array at index <i>capno</i>.

<PRE>
function Backref(capno) : capno=capno {}

const capno: uint

public function match(ctx: Context, x: State, c: Continuation): MatchResult {
    let cap = x.captures;
    let s = cap[capno];
    if (s == null)
        return c(ctx, x);
    let e = x.endIndex;
    let len = s.length;
    let f = e+len;
    if (f > ctx.inputLength)
        return failure;
    for ( let i=0 ; i &#60; len ; i++ )
        if (Canonicalize(ctx, s[i]) != Canonicalize(ctx, ctx.input[e+i]))
            return failure;
    return c(ctx, new State(f, cap));
}
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  An escape sequence of the form <code>\</code> followed by a nonzero
decimal number <i>n</i> matches the result of the <i>n</i>th set of
capturing parentheses (see 15.10.2.11).  If the <i>n</i>th entry in the
captures array is undefined because it hasn't captured anything, then
the backreference always succeeds.


<h3>Empty</h3>

<P><span class="pcounter"></span> An empty match succeeds without consuming input.

<PRE>
public function match(ctx: Context, x: State, c: Continuation): MatchResult {
    return c(ctx, x);
}
</PRE>


<h2>Methods on the class <code>RegExp</code></h2>

<h3>new&nbsp;RegExp(pattern,&nbsp;flags)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The <code>RegExp</code> constructor creates a new regular expression.
<i>Pattern</i> can be an existing regular expression, in which case the
source and flags for the new object is taken from <i>pattern</i>.

<P class="implsection"><b>Implementation</b>
<PRE>
function RegExp( pattern, flags ) {
    let src : string = "";

    if (pattern is RegExp) {
        if (flags === undefined) {
            src = pattern.source;
            flags = pattern.flags;
        }
        else
            throw new TypeError("Illegal construction of regular expression");
    }
    else {
        src = pattern === undefined ? "" : string(pattern);
        flags = flags === undefined ? "" : string(flags);
    }

    let usedflags = { m: false, i: false, g: false, x: false, y: false };

    for ( let i=0 ; i &#60; flags.length ; i++ ) {
        let f = flags[i];
        if (!(f in usedflags))
            throw new SyntaxError("Invalid flag: " + f);
        if (usedflags[f])
            throw new SyntaxError("Duplicated flag: " + f);
        usedflags[f] = true;
    }

    [matcher,names] = (new RegExpCompiler(src, usedflags)).compile();

    multiline = usedflags.m;
    ignoreCase = usedflags.i;
    global = usedflags.g;
    extended = usedflags.x;
    sticky = usedflags.y;
    lastIndex = 0;
    source = src;
}
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  If the characters of <i>src</i> do not have the form <i>Pattern</i>,
then a <b>SyntaxError</b> exception will be thrown.

<P><span class="pcounter"></span> The class <code>RegExp</code> has two internal properties <code>matcher</code> and
and <code>names</code>:

<PRE>
private const matcher: Matcher,
              names:   [string?]
</PRE>

<P><span class="pcounter"></span> The <code>matcher</code> property holds the regular expression matcher
object (the result of compiling the regular expression).  The
<code>names</code> property holds a string in position <i>i</i> if capturing
submatch <i>i</i> in the pattern string was given a name; the string
is that name.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  If pattern is a <i>StringLiteral</i>, the usual escape sequence
substitutions are performed before the string is processed by
<code>RegExp</code>. If <i>pattern</i> must contain an escape sequence to be
recognised by <code>RegExp</code>, the <code>"\"</code> character must be escaped within
the <i>StringLiteral</i> to prevent its being removed when the contents
of the <i>StringLiteral</i> are formed.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The <code>source</code> property of the newly constructed object is set
to an implementation-defined string value in the form of a <i>Pattern</i>
based on <i>src</i>.


<h3>RegExp(pattern,&nbsp;flags)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The <code>RegExp</code> class object invoked as a function converts
<i>pattern</i> to <code>RegExp</code>.

<P><span class="pcounter"></span> If <i>pattern</i> is a <code>RegExp</code> object and <i>flags</i> is undefined,
then return <i>pattern</i> unchanged.  Otherwise construct a new regular
expression from <i>pattern</i> and <i>flags</i> and return that.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>RegExp</code> function returns a <code>RegExp</code> object.

<P class="implsection"><b>Implementation</b>
<PRE>
meta static function invoke( pattern, flags ) {
    if (pattern is RegExp && flags === undefined)
        return pattern;
    else
        return new RegExp(pattern, flags);
}
</PRE>


<h2>Methods on <code>RegExp</code> instances</h2>


<h3>intrinsic::exec&nbsp;(&nbsp;s&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>exec</code> method performs a regular expression
match of the string <i>s</i> against the regular expression.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>exec</code> method returns an <code>Array</code> object
containing the results of the match, or <b>null</b> if the string did not
match.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function exec(s : string) : Array {
    let length = s.length;
    let i = lastIndex;
    if (!global)
        i = 0;
    let res = failure;
    while (true) {
        if (i &#60; 0 || i > length) {
            lastIndex = 0;
            return null;
        }
        res = matcher.match(s, i, multiline, ignoreCase);
        if (res !== failure)
            break;
        ++i;
    }
    if (global)
        lastIndex = res.endIndex;
    let a = new Array(res.captures.length);
    a.index = i;
    a.input = s;
    a.length = res.captures.length;
    a[0] = s.substring(i,res.endIndex);
    for ( let j=1 ; j &#60; res.captures.length ; j++ )
        a[j] = res.captures[j];
    for ( let j=1 ; j &#60; names.length ; j++ )
        if (names[j] !== null)
            a[names[j]] = res.captures[j];
    return a;
}
</PRE>

<h3>intrinsic::test&nbsp;(&nbsp;s&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>test</code> method tests whether the string <i>s</i>
can be successfully matched against the regular expression.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>test</code> method returns <b>true</b> if the string
can be matched, and otherwise <b>false</b>.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function test(s : string) : boolean
     exec(s) !== null;
</PRE>


<h3>intrinsic::toString()</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toString</code> method converts the regular
expression to a string.

<P><span class="pcounter"></span> Let <i>src</i> be a string in the form of a <i>Pattern</i> representing
the current regular expression.  <i>src</i> may or may not be identical
to the <code>source</code> property or to the source code supplied to the
<code>RegExp</code> constructor; however, if <i>src</i> were supplied to the
<code>RegExp</code> constructor along with the current regular expression's
flags, the resulting regular expression must behave identically to the
current regular expression.

<P><span class="pcounter"></span> The intrinsic <code>toString</code> method produces a string value formed
by concatenating the strings "/", <i>src</i>, and "/"; plus "g" if the
<code>global</code> property is true, "i" if the <code>ignoreCase</code> property is
true, "m" if the <code>multiline</code> property is true, "x" if the
<code>extended</code> property is true, and "y" if the <code>sticky</code> property is
true.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  An implementation may choose to take advantage of <i>src</i> being
allowed to be different from the source passed to the <code>RegExp</code>
constructor to escape special characters in <i>src</i>.  For example, in
the regular expression obtained from <code>new RegExp("/")</code>, <i>src</i> could
be, among other possibilities, "/" or "\/". The latter would permit
the entire result ("/\//") of the <code>toString</code> call to have the form
<i>RegularExpressionLiteral</i>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>toString</code> method returns a string.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span> The intrinsic <code>toString</code> method is implementation-defined.

<h3>meta::invoke&nbsp;(&nbsp;s&nbsp;)</h3>

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> When a <code>RegExp</code> object is called as a function, it invokes
the <code>exec</code> method on its argument and returns what <code>exec</code> returns.

<P class="implsection"><b>Implementation</b>
<PRE>
meta function invoke(s : string) : Array
    exec(s);
</PRE>

<h2>Value properties on <code>RegExp</code> instances</h2>

<h3>source</h3>

<P><span class="pcounter"></span> The value of the <code>source</code> property is <code>string</code> in the form of a
Pattern representing the current regular expression.

<h3>global</h3>

<P><span class="pcounter"></span> The value of the <code>global</code> property is a <code>boolean</code> value
indicating whether the flags contained the character <code>"g"</code>.

<h3>ignoreCase</h3>

<P><span class="pcounter"></span>The value of the <code>ignoreCase</code> property is a <code>boolean</code> value
indicating whether the flags contained the character <code>"i"</code>.

<h3>multiline</h3>

<P><span class="pcounter"></span> The value of the <code>multiline</code> property is a <code>boolean</code> value
indicating whether the flags contained the character <code>"m"</code>.

<h3>extended</h3>

<P><span class="pcounter"></span> The value of the <code>extended</code> property is a <code>boolean</code> value
indicating whether the flags contained the character <code>"x"</code>.

<h3>sticky</h3>

<P><span class="pcounter"></span> The value of the <code>sticky</code> property is a <code>boolean</code> value
indicating whether the flags contained the character "y".

<h3>lastIndex</h3>

<P><span class="pcounter"></span> The value of the <code>lastIndex</code> property is an integer that
specifies the string position at which to start the next match.

<P><span class="pcounter"></span> The value is converted to integer on setting.

<P class="implsection"><b>Implementation</b>
final function get lastIndex() &#x0085
final function set lastIndex(x) &#x0085


<h2>Methods on the <code>RegExp</code> prototype object</h2>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The methods on the <code>RegExp</code> prototype object call their
intrinsic counterparts.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The methods on the <code>RegExp</code> prototype object return what
their intrinsic counterparts return.

<P class="implsection"><b>Implementation</b>
<PRE>
prototype function exec(this:RegExp, s)
    this.exec(string(s));

prototype function test(this:RegExp, s)
    this.test(string(s));

prototype function toString(this:RegExp)
    this.intrinsic::toString();
</PRE>




<H1 id="class Vector"> The class <code>Vector</code> </h1>

<pre>
FILE:                       spec/library/Vector.html
DRAFT STATUS:               DRAFT 1 - ROUGH - 2007-09-20
REVIEWED AGAINST ES3:       N/A
REVIEWED AGAINST ERRATA:    N/A
REVIEWED AGAINST BASE DOC:  N/A
REVIEWED AGAINST PROPOSALS: NO
REVIEWED AGAINST CODE:      NO
</pre>

<P><span class="pcounter"></span> The class <code>Vector</code> is a parameterized, final, dynamic, direct
subclass of <code>Object</code>.  It represents dense, typed, 0-based,
one-dimensional arrays with bounds checking and optionally fixed
length.

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #196.) It may not be necessary for <code>Vector</code> to be
final, as long as the catchall getters and setters and the getters and
setters for <code>length</code> are final.

<P><span class="pcounter"></span> The class <code>Vector</code> provides two benefits.  One is optimization:
the restrictions placed on the class---denseness and a predefined
iteration order---make it possible for ECMAScript implementations to
implement it particularly efficiently.  The other is error checking:
<code>Vector</code> provides stronger type checking and bounds checking than
<code>Array</code>.

<p class="note"><b>COMPATIBILITY NOTE</b>&nbsp;&nbsp;  The class <code>Vector</code> is new in the 4th Edition of this Standard.

<P><span class="pcounter"></span> The class <code>Vector</code> provides a method suite that is largely
compatible with the class <code>Array</code>.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  It is likely that many current uses of <code>Array</code> can switch to
use <code>Vector</code> without much work, and receive the benefits of stronger
type and bounds checking.

<P><span class="pcounter"></span> The type parameter of the <code>Vector</code> is called its <i>base type</i>.

<P><span class="pcounter"></span> As the <code>Vector</code> class is dynamic, new properties can be added to
its instances but any property whose name is a number (an instance of
any class in the type <code>Numbers</code>) is handled specially.  These
properties are called <i>indexed properties</i>.

<P><span class="pcounter"></span> Only indexed properties named by nonnegative integers less than
the value of the property <code>length</code> are defined, and only indexed
properties named by nonnegative integers less than 2<SUP>32</SUP>-1
can be defined.

<P><span class="pcounter"></span> Any attempt to read an undefined indexed property results in a
<b>RangeError</b> exception being thrown.

<P><span class="pcounter"></span> Any attempt to write an undefined indexed property results in a
<b>RangeError</b> being thrown unless the index is equal to the current
value of <code>length</code>, the current value of <code>length</code> is not
2<SUP>32</SUP>-1, and the value of the property <code>fixed</code> is not
<b>true</b>.

<P><span class="pcounter"></span> The property <code>fixed</code> is a flag that determines whether the
vector has a fixed length or not.  Any attempt to update the value of
<code>length</code> fails if the <code>fixed</code> property has the value <b>true</b>.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  If <code>v</code> is a <code>Vector</code> then reading and writing <code>v[3.14]</code>
or <code>v[-3]</code> will always fail, though reading and writing
<code>v["3.14"]</code> or <code>v["-3"]</code> will succeed.  

<P class="note"> This deviates from the 3rd Edition, where strings and
numbers are interchangeable as property names.  But that's no longer
quite true in 4th Edition anyway (we have name spaces and Name
objects).

<P class="note">Most attempts to set or get properties that are named
by numbers that are not valid array indices are probably errors,
especially if the object is an Array.  Most attempts to read beyond
the end of an Array are probably errors.  And in a number of cases,
attempts to write beyond the end of an Array are probably errors too.
The <code>Vector</code> class makes it possible to discover these errors.

<P><span class="pcounter"></span> A vector does not have "holes" in its index range: all indexed
properties named by nonnegative integers less than <code>length</code> are
always defined.


<h2>Synopsis</h2>

<P><span class="pcounter"></span> The class <code>Vector</code> provides the following interface:

<PRE>
final class Vector.&#60;T>
{
    function Vector(length: uint=0, fixed: boolean=false) &#x0085
    meta static function invoke(object) &#x0085

    static const length = 2;

    intrinsic function toString() &#x0085
    intrinsic function toLocaleString() &#x0085
    intrinsic function concat(...items): Vector.&#60;T> &#x0085
    intrinsic function every(checker: Checker, thisObj: Object=null): boolean &#x0085
    intrinsic function filter(checker: Checker, thisObj: Object=null): Vector.&#60;T> &#x0085
    intrinsic function forEach(eacher: Eacher, thisObj: Object=null): void &#x0085
    intrinsic function indexOf(value: T, from: AnyNumber=0): AnyNumber &#x0085
    intrinsic function join(separator: string=","): string &#x0085
    intrinsic function lastIndexOf(value: T, from: AnyNumber=Infinity): AnyNumber &#x0085
    intrinsic function map(mapper:Mapper, thisObj:Object=null) &#x0085
    intrinsic function pop(): T &#x0085
    intrinsic function push(...items): uint &#x0085
    intrinsic function reverse(): Vector.&#60;T> &#x0085
    intrinsic function shift(): T &#x0085
    intrinsic function slice(start: AnyNumber=0, end: AnyNumber=Infinity)
        : Vector.&#60;T> &#x0085
    intrinsic function some(checker: Checker, thisObj: Object=null): boolean &#x0085
    intrinsic function sort(comparefn: function(T, T): AnyNumber): Vector.&#60;T> &#x0085
    intrinsic function splice(start: AnyNumber, deleteCount: AnyNumber, ...items)
        : Vector.&#60;T> &#x0085
    intrinsic function unshift(...items): uint &#x0085

    iterator function get(deep: boolean = false) : iterator::IteratorType.&#60;uint> &#x0085
    iterator function getKeys(deep: boolean = false) : iterator:
        :IteratorType.&#60;uint> &#x0085
    iterator function getValues(deep: boolean = false) : iterator::IteratorType.&#60;T> &#x0085
    iterator function getItems(deep: boolean = false) : iterator:
        :IteratorType.&#60;[uint,V]> &#x0085

    var fixed: boolean &#x0085

    function get length() &#x0085
    function set length(len: AnyNumber) &#x0085

    meta function get(name): T &#x0085
    meta function set(name, v) &#x0085
}
</PRE>

<P><span class="pcounter"></span> The types <code>Checker</code>, <code>Eacher</code>, and <code>Mapper</code> are as for the <code>Array</code> class
(see <span class="xref">class Array</span>).

<P><span class="pcounter"></span> The <code>Vector</code> prototype object provides these direct properties:

<PRE>
    toString:       function () &#x0085;
    toLocaleString: function () &#x0085;
    concat:         function (...items) &#x0085;
    every:          function (checker, thisObj) &#x0085;
    filter:         function (checker, thisObj) &#x0085;
    forEach:        function (eacher, thisObj) &#x0085;
    indexOf:        function (value, from) &#x0085;
    join:           function (separator) &#x0085;
    lastIndexOf:    function (value, from) &#x0085;
    map:            function (mapper, thisObj) &#x0085;
    pop:            function () &#x0085;
    push:           function (...items) &#x0085;
    reverse:        function () &#x0085;
    shift:          function () &#x0085;
    slice:          function (start, end) &#x0085;
    some:           function (checker, thisObj) &#x0085;
    sort:           function (comparefn) &#x0085;
    splice:         function (start, deleteCount, ...items) &#x0085;
    unshift:        function (...items) &#x0085;
</PRE>


<h2>Methods on the <code>Vector</code> class object</h2>

<h3>new&nbsp;Vector.&lt;T&gt;&nbsp;(&nbsp;length=&#x0085;,&nbsp;fixed=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The <code>Vector</code> constructor initializes a new <code>Vector</code> object.

<P><span class="pcounter"></span> <i>Length</i> is the inital value of the <code>length</code> property.  Its
default value is zero.  Every indexed element of the new vector below
<i>length</i> is initialized to <b>undefined</b> cast to the base type
<i>T</i>.

<P><span class="pcounter"></span> <i>Fixed</i> is the initial value of the <code>fixed</code> property.  Its
default value is <b>false</b>.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span> The <code>Vector</code> constructor is implementation-defined.


<h3>Vector.&lt;T&gt;(&nbsp;object&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> When the <code>Vector</code> class object is called as a function, it creates a new
variable-length <code>Vector</code> object of the requested base type, giving it the initial
length of the <code>length</code> property of <i>object</i> and initial element values extracted
from <i>object</i> between indices <code>0</code> and <i>object</i><code>.length</code>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>Vector</code> class object called as a function returns a new <code>Vector</code> object.

<P class="implsection"><b>Implementation</b>
<PRE>
meta static function invoke(object) {
    let length = uint(object.length);
    let result = new Vector.&#60;T>(length);
    for ( let i=0 ; i &#60; length ; i++ )
        result[i] = object[i];
    return result;
}
</PRE>


<h2>Methods on <code>Vector</code> instances</h2>

<h3>intrinsic::toString&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toString</code> method converts the vector to a <code>string</code>.
It has the same effect as if the <code>join</code> method were invoked for this
object with no argument.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>toString</code> method returns a <code>string</code>.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function toString()
    join();
</PRE>

<h3>intrinsic::toLocaleString&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toLocaleString</code> method converts the <code>Vector</code>
to a string in the following manner.

Elements of this <code>Vector</code> are converted to strings using their
public <code>toLocaleString</code> methods, and these strings are then
concatenated, separated by occurrences of a separator string that has
been derived in an implementation-defined locale-specific way.  The
result of calling this function is intended to be analogous to the
result of <code>toString</code>, except that the result of this function is
intended to be locale-specific.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>toLocaleString</code> method returns a <code>string</code>.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function toLocaleString() {
    let limit = length;
    let separator = informative::localeSpecificSeparatorString;
    let s = "";
    let i = 0;

    while (true) {
        let x = this[i];
        if (x !== undefined && x !== null)
            s += x.public::toLocaleString();
        if (++i == limit)
            break;
        s += separator;
    }
    return s;
}
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The first parameter to this method is likely to be used in a
future version of this standard; it is recommended that
implementations do not use this parameter position for anything else.

<h3>intrinsic::concat&nbsp;(&nbsp;...items&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>concat</code> method collects the vector elements
from <code>this</code> followed by the vector elements from the additional
<i>items</i>, in order, into a new <code>Vector</code> object.  All the <i>items</i>
must be <code>Vector</code> instances whose base types are subtypes of the base
type of <code>this</code>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>concat</code> method returns a new <code>Vector</code> object with the
same base type as <code>this</code>.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function concat(...items): Vector.&#60;T>
    helper::concat(items);

helper function concat(items) {
    let v = new Vector.&#60;T>;
    let k = 0;

    for ( let i=0 ; i &#60; length ; i++ )
        v[k++] = this[i];

    for ( let j=0 ; j &#60; items.length ; j++ ) {
        let item: Vector.&#60;T> = items[j];
        for ( let i=0 ; i &#60; item.length ; i++ )
            v[k++] = item[i];
    }

    return v;
}
</PRE>

<h3>intrinsic::every&nbsp;(&nbsp;checker,&nbsp;thisObj=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>every</code> method calls <i>checker</i> on every
vector element of <code>this</code> in increasing index order, stopping as soon
as any call returns <b>false</b>.

<P><span class="pcounter"></span><i>Checker</i> is called with three arguments: the vector element
value, the vector element index, and <code>this</code> itself.  <i>ThisObj</i>
is used as the <code>this</code> object in the call.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>every</code> method returns <b>true</b> if all the calls to
<i>checker</i> returned true values, otherwise it returns <b>false</b>.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function every(checker: Checker, thisObj: Object=null): boolean {
    for ( let i=0, limit=length ; i &#60; limit ; i++ )
        if (!checker.call(thisObj, this[i], i, this))
            return false;
    return true;
}
</PRE>

<h3>intrinsic::filter&nbsp;(&nbsp;checker,&nbsp;thisObj=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>filter</code> method calls <i>checker</i> on every
vector element of <code>this</code> in increasing index order, collecting all
the vector elements for which checker returns a true value.

<P><span class="pcounter"></span> <i>Checker</i> is called with three arguments: the vector element
value, the vector element index, and <code>this</code> itself.  <i>ThisObj</i> is
used as the <code>this</code> object in the call.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>filter</code> method returns a new <code>Vector</code> object with the
same base type as <code>this</code>, containing the elements that were
collected, in the order they were collected.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function filter(checker: Checker, thisObj: Object=null): Vector.&#60;T> {
    var result = new Vector.&#60;T>;
    for ( let i=0, limit=length ; i &#60; limit ; i++ )
        if (checker.call(thisObj, this[i], i, this))
            result.push(this[i]);
    return result;
}
</PRE>

<h3>intrinsic::forEach&nbsp;(&nbsp;eacher,&nbsp;thisObj=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>forEach</code> method calls <i>eacher</i> on every
vector element of <code>this</code> in increasing index order, discarding any
return value of <i>eacher</i>.

<P><span class="pcounter"></span> <i>Eacher</i> is called with three arguments: the vector element
value, the vector element index, and <code>this</code>.  <i>ThisObj</i> is used as
the <code>this</code> object in the call.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>forEach</code> method does not return a value.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function forEach(eacher: Eacher, thisObj: Object=null): void {
    for ( let i=0, limit=length ; i &#60; limit ; i++ )
        eacher.call(thisObj, this[i], i, this);
}
</PRE>

<h3>intrinsic::indexOf&nbsp;(&nbsp;value,&nbsp;from=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>indexOf</code> method compares <i>value</i> with every
vector element of <code>this</code> in increasing index order, starting at the
index <i>from</i>, stopping when a vector element is equal to <i>value</i>
by the <code>===</code> operator.

<P><span class="pcounter"></span> If <i>from</i> is negative, it is treated as
<code>this.length+<i>from</i></code>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>indexOf</code> method returns the vector index the first
time <i>value</i> is equal to an element, or -1 if no such element is
found.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function indexOf(value: T, from: AnyNumber=0): AnyNumber {
    let start = helper::clamp( from, length );
    for ( let i=start, limit=length ; i &#60; limit ; i++ )
        if (this[i] === value)
            return i;
    return -1;
}
</PRE>

<h3>intrinsic::join&nbsp;(&nbsp;separator=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>join</code> method concatenates the string
representations of the vector elements of <code>this</code> in increasing index
order, separating the individual strings by occurrences of
<i>separator</i>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>join</code> method returns the concatenated string.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function join(separator: string=","): string {
    let limit = length;
    let s = "";
    let i = 0;

    while (true) {
        let x = this[i];
        if (x !== undefined && x !== null)
            s += string(x);
        if (++i == limit)
            break;
        s += separator;
    }
    return s;
}
</PRE>

<h3>intrinsic::lastIndexOf&nbsp;(&nbsp;value,&nbsp;from=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>lastIndexOf</code> method compares <i>value</i> with every
vector element of <code>this</code> in decreasing numerical index order,
starting at the index <i>from</i>, stopping when a vector element is
equal to <i>value</i> by the <code>===</code> operator.

<P><span class="pcounter"></span> If <i>from</i> is negative, it is treated as
<code>this.length+<i>from</i></code>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>lastIndexOf</code> method returns the vector index the first
time <i>value</i> is equal to an element, or -1 if no such element is
found.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function lastIndexOf(value: T, from: AnyNumber=Infinity): AnyNumber {
    let start = helper::clamp( from, length );
    for ( let i=start ; i >= 0 ; i-- )
        if (this[i] === value)
            return i;
    return -1;
}
</PRE>

<h3>intrinsic::map&nbsp;(&nbsp;mapper,&nbsp;thisObj=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>map</code> method calls <i>mapper</i> on each vector
element of <code>this</code> in increasing numerical index order, collecting
the return values from <i>mapper</i> in a new <code>Vector</code> object with the
same base type as <code>this</code>.

<P><span class="pcounter"></span><i>Mapper</i> is called with three arguments: the vector element
value, the vector element index, and <code>this</code>.  <i>ThisObj</i> is used as
the <code>this</code> object in the call.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>map</code> method returns a new <code>Vector</code> object where the
vector element at index <i>i</i> is the value returned from the call to
<i>mapper</i> on <code>this</code><i>[i]</i>.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function map(mapper:Mapper, thisObj:Object=null) {
    var result = new Vector.&#60;T>(length);
    for ( let i=0, limit=length ; i &#60; limit ; i++ )
        result[i] = mapper.call(thisObj, this[i], i, this);
    return result;
}
</PRE>

<h3>intrinsic::pop&nbsp;()</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>pop</code> method extracts the last vector element
from <code>this</code> and removes it by decreasing the value of the <code>length</code>
property of <code>this</code> by 1.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>pop</code> method returns the removed element, or
<b>undefined</b> cast to the base type of <code>this</code> if there are no
elements.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function pop(): T {
    if (length == 0)
        return undefined;

    let v = this[length];
    length--;
    return v;
}
</PRE>

<h3>intrinsic::push&nbsp;(&nbsp;...items&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>push</code> method appends the values in <i>items</i> to
the end of the vector elements of <code>this</code>, in the order in which
they appear, in the process updating the <code>length</code> property of <code>this</code>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>push</code> method returns the new value of the <code>length</code>
property of <code>this</code>.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function push(...items): uint
    helper::push(items);

helper function push(items) {
    for ( let i=0, limit=items.length ; i &#60; limit ; i++ )
        this[length] = items[i];
    return length;
}
</PRE>


<h3>intrinsic::reverse&nbsp;()</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>reverse</code> method rearranges the vector elements of
<code>this</code> so as to reverse their order.  The <code>length</code> property of
<code>this</code> remains unchanged.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>reverse</code> method returns <code>this</code>.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function reverse(): Vector.&#60;T> {
    for ( let i=0, j=length-1 ; i &#60; j ; i++, j-- )
        [this[i], this[j]] = [this[j], this[i]];
    return this;
}
</PRE>

<h3>intrinsic::shift&nbsp;()</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>shift</code> method removes the element called <code>0</code> in
<code>this</code>, moves the element at index <i>i+1</i> to index <i>i</i>, and
decrements the <code>length</code> property of <code>this</code> by 1.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>shift</code> method returns the element that was removed.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function shift(): T {
    if (length == 0)
        return undefined;
    let v = this[0];
    for ( let i=1, limit=length ; i &#60; limit ; i++ )
        this[i-1] = this[i];
    length--;
    return v;
}
</PRE>

<h3>intrinsic::slice&nbsp;(&nbsp;start=&#x0085;,&nbsp;end=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>slice</code> method extracts the subrange of array elements
from <code>this</code> between <i>start</i> (inclusive) and <i>end</i> (exclusive)
into a new Array.

<P><span class="pcounter"></span> If <i>start</i> is negative, it is treated as
<code><i>object</i>.length+<i>start</i></code>.  If <i>end</i> is negative, it is
treated as <code><i>object</i>.length+<i>end</i></code>. 

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>slice</code> method returns a new <code>Vector</code> object with the
same base type as <code>this</code>, containing the extracted vector elements.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function slice(start: AnyNumber=0, end: AnyNumber=Infinity): Vector.&#60;T> {
    let first = helper::clamp( start, length );
    let limit = helper::clamp( end, length );
    let result = new Vector.&#60;T>;
    for ( let i=first ; i &#60; limit ; i++ )
        result.push(this[i]);
    return result;
}
</PRE>

<h3>intrinsic::some&nbsp;(&nbsp;checker,&nbsp;thisObj=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>some</code> method calls <i>checker</i> on every vector
element in <code>this</code> in increasing index order, stopping as soon as
<i>checker</i> returns a true value.

<P><span class="pcounter"></span><i>Checker</i> is called with three arguments: the vector element
value, the vector element index, and <code>this</code>.  <i>ThisObj</i> is used as
the <code>this</code> object in the call.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>some</code> method returns <b>true</b> when <i>checker</i> returns a
true value, otherwise returns <b>false</b> if all the calls to
<i>checker</i> return false values.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function some(checker: Checker, thisObj: Object=null): boolean {
    for ( let i=0, limit=length ; i &#60; limit ; i++ )
        if (checker.call(thisObj, this[i], i, this))
            return true;
    return false;
}
</PRE>

<h3>intrinsic::sort&nbsp;(&nbsp;comparefn&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic::<code>sort</code> method sorts the vector elements of
<code>this</code> according to the ordering defined by <code>comparefn</code>.

<P><span class="pcounter"></span> The sort is not necessarily stable (that is, elements that compare
equal do not necessarily remain in their original order).
<i>Comparefn</i> must be a consistent (see <span class="xref">sorting-logic</span>)
function that accepts two arguments <i>x</i> and <i>y</i> of the base type
of <code>this</code> and returns a negative value if <i>x < y</i>, zero if <i>x
= y</i>, or a positive value if <i>x > y</i>.

<p class="note"><b>COMPATIBILITY NOTE</b>&nbsp;&nbsp;  Unlike the case for <code>Array</code>, the <i>comparefn</i> is a required argument.

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #197.) Should we provide a default comparator?

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>sort</code> method returns <code>this</code>.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span>
The <code>sort</code> method calls on the generic sorting engine, passing a
function to compare elements of <i>this</i>.

<PRE>
intrinsic function sort(comparefn: function(T, T): AnyNumber): Vector.&#60;T> {
    if (length > 0) {
        let object = this;
        informative::sortEngine(this,
                                0,
                                length-1,
                                (function (j, k)
                                     comparefn(object[j], object[k])));
    return this;
}
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  For a description of the informative <code>sortEngine</code> method, see
<span class="xref">sorting-logic</span>.

<h3>intrinsic::splice&nbsp;(&nbsp;start,&nbsp;deleteCount,&nbsp;...items&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>splice</code> method replaces the <i>deleteCount</i> vector
elements of <code>this</code> starting at index <i>start</i> with values
from the <i>items</i>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>splice</code> method returns a new <code>Vector</code> object of the
same base type as <code>this</code>, containing the vector elements that were
removed from <code>this</code>, in order.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function splice(start: AnyNumber, deleteCount: AnyNumber, ...items): Vector.&#60;T>
    helper::splice(start, deleteCount, items);

helper function splice(start, deleteCount, items) {
    let first  = helper::clamp( start, length );
    let delcnt = helper::clamp( deleteCount, length-first );

    let result = new Vector.&#60;T>;
    for ( let n=0, i=first ; n &#60; delcnt ; n++, i++ )
        result.push(this[i]);

    if (items.length &#60; delcnt) {
        let shift = delcnt - items.length;
        for ( let n=0, i=first; n &#60; shift ; n++, i++ )
            this[i] = this[i+shift];
        length -= shift;
    }
    else {
        let shift = items.length - delcnt;
        for ( let n=shift-1, i=first+shift; n >= 0 ; n--, i-- )
            this[i] = this[i-shift];
    }
    for ( let n=0, i=first ; n &#60; items.length ; n++, i++ )
        this[i] = items[n];

    return result;
}
</PRE>

<h3>intrinsic::unshift&nbsp;(&nbsp;...items&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The instrinsic <code>unshift</code> method inserts the values in
<i>items</i> as new vector elements at the start of <code>this</code>, such that
their order within the vector elements of <code>this</code> is the same as the
order in which they appear in <i>items</i>.  Existing vector elements in
<code>this</code> are shifted upward in the index range, and the <code>length</code>
property of <code>this</code> is updated.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>unshift</code> method returns the new value of the
<code>length</code> property of <code>this</code>.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function unshift(...items): uint
    helper::unshift(items);

helper function unshift(items) {
    let numitems = items.length;
    let oldlimit = length;
    let newlimit = oldlimit + numitems;

    for ( let i=0 ; i &#60; numitems ; i++ )
        this[newlimit-i] = this[oldlimit-i];
    for ( let i=0 ; i &#60; numitems ; i++ )
        this[i] = items[i];
    return newlength;
}
</PRE>


<h2>Iteration protocol on <code>Vector</code> instances</h2>

<P><span class="pcounter"></span> Iterators are defined on the <code>Vector</code> such that <code>for</code>-<code>in</code>
and <code>for each</code>-<code>in</code> loops always iterate across the vector from
low indices toward high indices.  Only indexed properties defined on
directly on the vector object are visited.

<P class="implsection"><b>Implementation</b>
<PRE>
iterator function get(deep: boolean = false) : iterator::IteratorType.&#60;uint>
    getKeys(deep);

iterator function getKeys(deep: boolean = false) : iterator::IteratorType.&#60;uint> {
    let i = 0;
    let a = this;
    return {
        next:
        function () : uint {
            if (i === a.length)
                throw iterator::StopIteration;
            return i++;
        }
    }
}

iterator function getValues(deep: boolean = false) : iterator::IteratorType.&#60;T> {
    let i = 0;
    let a = this;
    return {
        next:
        function () : T {
            if (i === a.length)
                throw iterator::StopIteration;
            return a[i++];
        }
    }
}

iterator function getItems(deep: boolean = false) : iterator::IteratorType.&#60;[uint,V]> {
    let i = 0;
    let a = this;
    return {
        next:
        function () : T {
            if (i === a.length)
                throw iterator::StopIteration;
            return [i,a[i++]];
        }
    }
}
</PRE>


<h2>Value properties of <code>Vector</code> instances</h2>

<h3>length</h3>

<P><span class="pcounter"></span> The property <code>length</code> determines the range of valid indices into
the <code>Vector</code>.  Indices up to but not including <code>length</code> are always
defined.

<P><span class="pcounter"></span> When <code>length</code> is given a new value that is smaller than its old
value then the elements in the vector at the new length and beyond are
removed from the vector.

<P><span class="pcounter"></span> When <code>length</code> is given a new value that is greater than its old
value then the elements in the vector at the old length and beyond are
given the value <b>undefined</b> cast to the base type <code>T</code>.

<P><span class="pcounter"></span> If an attempt is made to set <code>length</code> when the <code>fixed</code> property
is <b>true</b> then a <b>RangeError</b> is thrown.

<P><span class="pcounter"></span> If an attempt is made to set <code>length</code> to any value that is not a
nonnegative integer less than 2<SUP>32</SUP> then a <b>RangeError</b> is
thrown.


<h3>fixed</h3>

<P><span class="pcounter"></span> The boolean property <code>fixed</code> determines whether the <code>Vector</code>
has a fixed length.

<P><span class="pcounter"></span> If <code>fixed</code> has the value <b>true</b> then any attempt to change
<code>length</code> will result in in a <b>RangeError</b> being thrown.

<P><span class="pcounter"></span> The value of <code>fixed</code> is not constant, so vectors can be of fixed
length and variable length at different times.


<h3>Numerically named properties</h3>

<P><span class="pcounter"></span> A <code>Vector</code> contains all properties whose names are nonnegative
integers below the value of <code>length</code>.

<P><span class="pcounter"></span> If an attempt is made to read a property whose name is a number that
is not a nonnegative integer below <code>length</code> then a <b>RangeError</b> is thrown.

<P><span class="pcounter"></span> If an attempt is made to write a property whose name is a number that is not
a nonnegative integer below <code>length</code> then one of two things happen:
<UL>
  <LI> If the <code>fixed</code> property has the value <code>true</code>, or if the
  number is not a nonnegative integer, or if it is a nonnegative number but
  not the value <code>length</code>, or if <code>length</code> is already 2<SUP>32</SUP>-1,
  then a <b>RangeError</b> is thrown.
  <LI> Otherwise, the property is defined on the vector and the <code>length</code> property
  is incremented by 1.
</UL>

<h2>Methods on the <code>Vector</code> prototype object</h2>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The methods on the <code>Vector</code> prototype object perform a small
amount of type conversion and delegate to the corresponding intrinsic
methods.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The methods on the <code>Vector</code> prototype object return what their
corresponding intrinsic methods return.

<P class="implsection"><b>Implementation</b>
<PRE>
prototype function toString(this:Vector.&#60;*>)
    this.intrinsic::toString();

prototype function toLocaleString(this:Vector.&#60;*>)
    this.intrinsic::toLocaleString();

prototype function concat(this:Vector.&#60;*>, ...items)
    this.helper::concat(items);

prototype function every(this:Vector.&#60;*>, checker, thisObj=undefined)
    this.intrinsic::every(checker, thisObj is Object ? thisObj : null);

prototype function filter(this:Vector.&#60;*>, checker, thisObj=undefined)
    this.intrinsic::filter(checker, thisObj is Object ? thisObj : null);

prototype function forEach(this:Vector.&#60;*>, eacher, thisObj=undefined)
    this.intrinsic::forEach(checker, thisObj is Object ? thisObj : null);

prototype function indexOf(this:Vector.&#60;*>, value, from=undefined)
    this.intrinsic::indexOf(value, Number(from));

prototype function join(this:Vector.&#60;*>, separator=undefined)
    this.intrinsic::indexOf(separator == undefined ? "," : string(separator));

prototype function lastIndexOf(this:Vector.&#60;*>, value, from=undefined)
    this.intrinsic::indexOf(value, from == undefined ? Infinity : Number(from));

prototype function map(this:Vector.&#60;*>, mapper, thisObj=undefined)
    this.intrinsic::map(mapper, thisObj is Object ? thisObj : null);

prototype function pop(this:Vector.&#60;*>)
    this.intrinsic::pop();

prototype function push(this:Vector.&#60;*>, ...items)
    this.helper::push(items);

prototype function reverse(this:Vector.&#60;*>)
    this.intrinsic::reverse();

prototype function shift(this:Vector.&#60;*>)
    this.intrinsic::shift();

prototype function slice(this:Vector.&#60;*>, start=undefined, end=undefined)
    this.intrinsic::slice(start == undefined ? 0 : Number(start),
                          end == undefined ? Infinity : Number(end));

prototype function some(this:Vector.&#60;*>, checker, thisObj=undefined)
    this.intrinsic::some(checker, thisObj is Object ? thisObj : null);

prototype function sort(this:Vector.&#60;*>, comparefn)
    this.intrinsic::sort(comparefn);

prototype function splice(this:Vector.&#60;*>, start, deleteCount, ...items)
    this.helper::splice(Number(start), Number(deleteCount), items);

prototype function unshift(this:Vector.&#60;*>, ...items)
    this.helper::unshift(items);
</PRE>





<h1 id="class Map"> The class <code>Map</code> </h1>

<pre>
FILE:                       spec/library/Map.html
DRAFT STATUS:               DRAFT 1 - ROUGH - 2007-09-18
REVIEWED AGAINST ES3:       N/A
REVIEWED AGAINST ERRATA:    N/A
REVIEWED AGAINST BASE DOC:  N/A
REVIEWED AGAINST PROPOSALS: NO
REVIEWED AGAINST CODE:      NO
</pre>

<P><span class="pcounter"></span> The class <code>Map</code> is a parameterized, dynamic, non-final, direct
subclass of <code>Object</code> that provides a reliable and efficient map from
keys to values.  Keys and values may be of arbitrary types.

<P><span class="pcounter"></span> A <code>Map</code> is realized as a hash table.  When the <code>Map</code> is
constructed the client program may provide functions that compare keys
and compute hash values for keys.


<h2>Synopsis</h2>

<P><span class="pcounter"></span> The class <code>Map</code> provides the following interface:

<PRE>
class Map.&#60;K,V>
{
    function Map(equals=intrinsic::===, hashcode=intrinsic::hashcode) &#x0085

    static const length = 2;

    intrinsic function size() : uint &#x0085
    intrinsic function get(key: K) : V? &#x0085
    intrinsic function put(key:K, value:V) : void &#x0085
    intrinsic function has(key:K) : boolean &#x0085
    intrinsic function remove(key:K) : boolean &#x0085

    iterator function get(deep: boolean = false) : iterator::IteratorType.&#60;K> &#x0085
    iterator function getKeys(deep: boolean = false) : iterator::IteratorType.&#60;K> &#x0085
    iterator function getValues(deep: boolean = false) : iterator::IteratorType.&#60;V> &#x0085
    iterator function getItems(deep: boolean = false) : iterator:
        :IteratorType.&#60;[K,V]> &#x0085

    private const equals = &#x0085;
    private const hashcode = &#x0085;
    private var population = &#x0085;
}
</PRE>

<P><span class="pcounter"></span> The <code>Map</code> prototype object provides these direct properties:

<PRE>
    size:   function () &#x0085;
    get:    function (key) &#x0085;
    put:    function (key, value) &#x0085;
    has:    function (key) &#x0085;
    remove: function (key) &#x0085;
</PRE>


<h2>Methods on the <code>Map</code> class object</h2>

<h3>new&nbsp;Map.&lt;K,V&gt;(&nbsp;equals=&#x0085;,&nbsp;hashcode=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The <code>Map</code> constructor creates a new map for key type <i>K</i>
and value type <i>V</i>.

<P><span class="pcounter"></span> The optional <i>equals</i> argument is a function that compares two
keys and returns <b>true</b> if they are equal and <b>false</b> if they are
not.  This function must implement a reflexive, transitive, and
symmetric relation, and <i>equals(k1,k2)</i> must be constant.  The
default value for <i>equals</i> is a function that compares the two keys
using the <code>===</code> operator.

<P><span class="pcounter"></span> The optional <i>hashcode</i> argument is a function that takes a key
and returns a hash code for it.  This code may be used to find
associations more quickly in the map.  Two calls to the <i>hashcode</i>
function on the same key value must return the same hash value, and
the <i>hashcode</i> function must always return the same value for two
objects that compare equal by the <i>equals</i> function.  The default
value for <i>hashcode</i> is the intrinsic global function <code>hashcode</code>.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The constraints that <i>equals</i> and <i>hashcode</i> return
constant values do not apply to key values that are not in a <code>Map</code>
nor referenced from an activation of any method on <code>Map</code>.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span> The <code>Map</code> constructor initializes the <code>Map</code> object by
saving its parameters in private storage and initializing the element
count to zero.

<PRE>
function Map(equals=intrinsic::===, hashcode=intrinsic::hashcode)
    : equals = equals
    , hashcode = hashcode
    , element_count = 0
{
}
</PRE>


<h2>Methods on <code>Map</code> instances</h2>

<h3>size&nbsp;(&nbsp;)</h3>

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic method <code>size</code> returns the number of associations in the map.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function size() : uint
    element_count;
</PRE>

<h3>get&nbsp;(&nbsp;key&nbsp;)</h3>

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic method <code>get</code> returns the value associated with <i>key</i>, or <b>null</b> if
there's no such association.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function get(key: K) : V? {
    let probe = informative::find(key);
    return probe ? probe.value : null;
}
</PRE>

<P><span class="pcounter"></span> The informative function <code>find</code> searches for <i>key</i> in the
<code>Map</code> and returns an object containing at least the properties
<code>key</code> and <code>value</code> if the association was found, or otherwise
<b>null</b>.

<PRE>
informative function find(key: K): like { key: K, value: V } &#x0085;
</PRE>

<h3>put&nbsp;(&nbsp;key,&nbsp;value&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic method <code>put</code> creates an association between
<i>key</i> and <i>value</i>, or overwrites an existing association if there
is one.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>put</code> method returns nothing.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function put(key:K, value:V) : void {
    let probe = informative::find(key);
    if (probe)
        probe.value = value;
    else {
        ++element_count;
        informative::insert( key, value );
    }
}
</PRE>

<P><span class="pcounter"></span> The informative function <code>insert</code> adds a new association between
<i>key</i> and <i>value</i> to the <code>Map</code>.

<PRE>
informative function insert(key: K, value: V): void &#x0085;
</PRE>

<h3>has&nbsp;(&nbsp;key&nbsp;)</h3>

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic method <code>has</code> returns <b>true</b> if there exists an association for <i>key</i>,
or <b>false</b> otherwise.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function has(key:K) : boolean {
    let probe = informative::find(key);
    return probe ? true : false;
}
</PRE>

<h3>remove&nbsp;(&nbsp;key&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic method <code>remove</code> removes any association for <i>key</i>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>remove</code> method returns <b>true</b> if there was an association for <i>key</i>,
or <b>false</b> otherwise.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function remove(key:K) : boolean {
    let probe = informative::find(key);
    if (probe) {
        --element_count;
        informative::eject(probe);
        return true;
    }
    return false;
}
</PRE>

<P><span class="pcounter"></span> The informative function <code>eject</code> removes the association for
<i>key</i> from the <code>Map</code>.

<PRE>
informative function eject(box: like { key: K, value: V }): void &#x0085;
</PRE>

<h2>Iteration protocol on <code>Map</code> instances</h2>

<P><span class="pcounter"></span> The iterator protocol makes use of a helper method <code>iterate</code>
which first collects the values that will be returned by the iterator
methods and then returns an object that provides the correct <code>next</code>
method:

<PRE>
helper function iterate.&#60;T>(f: function(*,*,*):*) {
    let a = [] : [T];
    informative::allElements( tbl, limit, function (k,v) { f(a,k,v) } );
    let i = 0;
    return {
        next: function () : T {
            if (i === a.length)
                throw iterator::StopIteration;
            return a[i++];
        }
    };
}
</PRE>

<P><span class="pcounter"></span> The informative function <code>allElements</code> calls the function passed
as its third argument on every key/value pair in the table:

<PRE>
informative function allElements(&#x0085;, function (K,V):*): void &#x0085;
</PRE>

<P><span class="pcounter"></span> As per normal, the iterator methods <code>getKeys</code>, <code>getValues</code>, and <code>getItems</code>
return iterator objects that iterate over keys, values, and key/value pairs, respectively.

<P class="implsection"><b>Implementation</b>
<PRE>
iterator function getKeys(deep: boolean = false) : iterator::IteratorType.&#60;K>
    helper::iterate.&#60;K>(function (a,k,v) { a.push(k) });

iterator function getValues(deep: boolean = false) : iterator::IteratorType.&#60;V>
    helper::iterate.&#60;V>(function (a,k,v) { a.push(v) });

iterator function getItems(deep: boolean = false) : iterator::IteratorType.&#60;[K,V]>
    helper::iterate.&#60;[K,V]>(function (a,k,v) { a.push([k,v]) });
</PRE>

<P><span class="pcounter"></span> The iterator method <code>get</code> iterates over keys (like <code>getKeys</code>).

<P class="implsection"><b>Implementation</b>
<PRE>
iterator function get(deep: boolean = false) : iterator::IteratorType.&#60;K>
    getKeys(deep);
</PRE>

<h2>Methods on the <code>Map</code> prototype object</h2>

<P><span class="pcounter"></span> The methods on the <code>Map</code> prototype object are constrained to
being called on instances of <code>Map</code>.  They all delegate to the
corresponding intrinsic method on their <code>this</code> object.

<PRE>
prototype function size(this: Map.&#60;*,*>)
    this.intrinsic::size();

prototype function get(this: Map.&#60;*,*>, key)
    this.intrinsic::get(key);

prototype function put(this: Map.&#60;*,*>, key, value)
    this.intrinsic::put(key, value);

prototype function has(this: Map.&#60;*,*>, key)
    this.intrinsic::has(key);

prototype function remove(this: Map.&#60;*,*>, key)
    this.intrinsic::remove(key);
</PRE>



<h1 id="meta-objects"> The meta-object classes </h1>

<pre>
FILE:                       spec/library/meta.html
DRAFT STATUS:               DRAFT 1 - ROUGH - 2007-09-20
REVIEWED AGAINST ES3:       N/A
REVIEWED AGAINST ERRATA:    N/A
REVIEWED AGAINST BASE DOC:  N/A
REVIEWED AGAINST PROPOSALS: NO
REVIEWED AGAINST CODE:      NO
</pre>

<P><span class="pcounter"></span> The intrinsic meta-object interfaces <code>Type</code>, <code>NominalType</code>,
<code>ClassType</code>, <code>InterfaceType</code>, <code>AnyType</code>, <code>UndefinedType</code>,
<code>NullType</code>, <code>UnionType</code>, <code>RecordType</code>, <code>ArrayType</code>,
<code>FunctionType</code>, <code>Field</code>, and <code>FieldValue</code>, along with the
intrinsic helper types <code>FieldIterator</code>, <code>NominalTypeIterator</code>,
<code>TypeIterator</code>, <code>ValueIterator</code>, and <code>FieldValueIterator</code>,
provide a simple reflection capability.

<P><span class="pcounter"></span> The standard meta-objects described by the interface types may be
immutable.

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #199.) Right now the class <code>Class</code> is not defined in
ES4.  (Nor is there an <code>Interface</code>, nor are there described classes
for other type objects.)  If these are defined, then we must decide
whether they implement the meta-object interfaces or not.  Otherwise
we have problems of nonportability due to name shadowing in some
systems but not in others, or subclassability in some systems but not
in others.

<P><span class="pcounter"></span> ECMAScript implementations may choose to provide extensions to
these interfaces, in order to provide richer reflective capabilities.
Clients wishing to use extended meta-object interfaces can perform
runtime downcasts on the meta-objects described by this Standard.

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #200.)  The meta-objects system does not currently deal with
parameterized types.  It will almost certainly need to.  First,
classes can contain type definitions and those definitions can be
public, and it would be strange if they could not be iterated by the
<code>publicMembers</code> and <code>publicStaticMembes</code> methods of
<code>NominalType</code>.  But type definitions can bind type parameters, so
there would need to be a representation of that.  Second, method
definitions can bind type parameters (this facility is used in eg the
<code>Map</code> class for internal helper methods), so even if type
definitions were not iterated we'd have to deal with the problem for
methods.

<P class="fixme"> There is also the question of what the meaning of
<code>typeOf(Map)</code> means, when <code>Map</code> is a paremeterized type.
Presumably that too needs to reveal parameterization in some way.

<P class="fixme"> The original meta-objects proposal had some
facilities for parameterization in the context of instantiation: the
<code>construct</code> methods would take a type iterator that would provide
values for type parameters.  But that's not good enough, and the
following spec does not provide for these.  Something like that will
come back in, though.

<P class="fixme"> There will probably be a new interface
<code>ParemeterizedType</code> that acts as a binder for type parameters:

<PRE class="fixme">
interface ParameterizedType
{
    function numberOfParameters()
    function construct(typeVals: TypeIterator): Type
}
</PRE>

<P class="fixme"> We must decide whether only instantiated types can
be manipulated or not.  If so, then we could then arrange for a "dummy
type" factory to allow easy instantiation for inspection purposes:

<PRE class="fixme">
intrinsic function dummyTypes(t: Type): TypeIterator
</PRE>

<P class="fixme"> That may or may not run afoul of type checking, if
any type checking happens at instantiation time.  The alternative
would be to provide an interface for <code>TypeParameter</code>, and for
<code>ParameterizedType</code> to allow inspection of its contained type
without instantiation, with the proviso that <code>TypeParameter</code> values
will pop up during inspection and will have to be handled.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  In the following sections all interfaces, types, and methods
are implicitly defined in the <code>intrinsic</code> namespace.  The methods
defined on the interfaces are not defined on the prototypes of the
classes that implement those interfaces.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  Type annotations that denote nullable types are revealed as a
union of <code>NullType</code> and another type.

<h2>Retrieving the type of an object</h2>

<h3>typeOf&nbsp;(&nbsp;v&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The global intrinsic function <code>typeOf</code> delivers the run-time
type of its argument <i>v</i>, which may be a value of any type.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The function <code>typeOf</code> returns an object that implements
<code>Type</code> and possibly one of the interfaces extending <code>Type</code>.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span> The function <code>typeOf</code> is implementation-dependent.


<h2>The interface <code>Type</code></h2>

<P><span class="pcounter"></span> The intrinsic interface <code>Type</code> describes a type in the system in
basic terms.

<h3>Synopsis</h3>

<PRE>
interface Type 
{
    function canConvertTo(t: Type): boolean
    function isSubtypeOf(t: Type): boolean
}
</PRE>

<h3>Methods</h3>

<h4>canConvertTo&nbsp;(&nbsp;t&nbsp;)</h4>

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>canConvertTo</code> method returns <b>true</b> if this type can
be converted to the type <i>t</i>, otherwise it returns <b>false</b>.

<h4>isSubtypeOf&nbsp;(&nbsp;t&nbsp;)</h4>

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>isSubtypeOf</code> method returns <b>true</b> if this type is a
subtype of the type <i>t</i>, otherwise it returns <b>false</b>.


<h2>The interface <code>Field</code></h2>

<P><span class="pcounter"></span> The intrinsic interface <code>Field</code> describes a field (property) of
a class, record, or array type by the field name and field type.

<h3>Synopsis</h3>

<PRE>
interface Field
{
    function name(): Name
    function type(): Type
}
</PRE>

<h3>Methods</h3>

<h4>name&nbsp;(&nbsp;)</h4>

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>name</code> method returns the field name as a <code>Name</code> object.

<h4>type&nbsp;(&nbsp;)</h4>

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>type</code> method returns the field type as an object that
implements <code>Type</code> or one of the interfaces extending <code>Type</code>.


<h2>The interface <code>FieldValue</code></h2>

<P><span class="pcounter"></span> The intrinsic interface <code>FieldValue</code> describes a field
(property) of a record or array by the field name and field value.  It
is used for constructing new record and array instances.

<h3>Synopsis</h3>

<PRE>
interface FieldValue
{
    function name(): Name
    function value(): *
}
</PRE>


<h3>Methods</h3>

<h4>name&nbsp;(&nbsp;)</h4>

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>name</code> method returns the field name as a <code>Name</code>
object.

<h4>value&nbsp;(&nbsp;)</h4>

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>value</code> method returns the actual field value as an
ECMAScript value.


<h2>The interface <code>NominalType</code></h2>

<P><span class="pcounter"></span> The intrinsic interface <code>NominalType</code> is a base interface for
<code>InterfaceType</code> and <code>ClassType</code>.  It provides accessors for
aspects common to those two types.

<h3>Synopsis</h3>

<PRE>
interface NominalType extends Type
{
    function name(): Name
    function superTypes(): NominalTypeIterator
    function publicMembers(): FieldIterator
    function publicStaticMembers(): FieldIterator
}
</PRE>

<h3>Methods</h3>

<h4>name&nbsp;(&nbsp;)</h4>

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>name</code> method returns the name of the nominal type as a
<code>Name</code> object.

<h4>superTypes&nbsp;(&nbsp;)</h4>

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>superTypes</code> method returns an iterator that iterates
over the superclasses and implemented interfaces of this nominal type.

<h4>publicMembers&nbsp;(&nbsp;)</h4>

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>publicMembers</code> method returns an iterator that iterates
over the field definitions of all public instance fields (both method
properties and value properties).

<h4>publicStaticMembers&nbsp;(&nbsp;)</h4>

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>publicMembers</code> method returns an iterator that iterates
over the field definitions of all public class fields (both method
properties and value properties).

<P><span class="pcounter"></span> The constructor method is included in the set of static members,
provided that it is public.

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #200.) Likely, this will also iterate type definitions (see comment
at the start of this chapter).


<h2>The interface <code>InterfaceType</code></h2>

<P><span class="pcounter"></span> The intrinsic interface <code>InterfaceType</code> describes an interface.

<h3>Synopsis</h3>

<PRE>
interface InterfaceType extends NominalType
{
    function implementedBy(): ClassTypeIterator
}
</PRE>

<h3>Methods</h3>

<h4>implementedBy&nbsp;(&nbsp;)</h4>

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>implementedBy</code> method returns an interator that iterates
over all the class types that implement this interface.


<h2>The interface <code>ClassType</code></h2>

<P><span class="pcounter"></span> The intrinsic interface <code>ClassType</code> describes a class and
provides a means of creating new instances of the class.

<h3>Synopsis</h3>

<PRE>
interface ClassType extends NominalType
{
    function construct(valArgs: ValueIterator): Object
}
</PRE>

<h3>Methods</h3>

<h4>construct&nbsp;(&nbsp;valArgs&nbsp;)</h4>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The <code>construct</code> method creates a new instance of the class
represented by this <code>ClassType</code>, provided the class's constructor is
public.

<P><span class="pcounter"></span> The iterator <i>valArgs</i> provides any value arguments required by
the constructor.  Only as many values as necessary for calling the
constructor will be consumed from the iterator.  If the constructor
takes no arguments then <i>valArgs</i> may be null.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>construct</code> method returns a new object of the type
represented by this <code>ClassType</code>.

<h2>The interface <code>AnyType</code></h2>

<P><span class="pcounter"></span> The intrinsic interface <code>AnyType</code> describes the type <code>*</code>.

<h3>Synopsis</h3>

<PRE>
interface AnyType extends Type
{
}
</PRE>

<h2>The interface <code>NullType</code></h2>

<P><span class="pcounter"></span> The intrinsic interface <code>NullType</code> describes the type <code>null</code>.

<h3>Synopsis</h3>

<PRE>
interface NullType extends Type
{
}
</PRE>


<h2>The interface <code>UndefinedType</code></h2>

<P><span class="pcounter"></span> The intrinsic interface <code>UndefinedType</code> describes the type <code>undefined</code>.

<h3>Synopsis</h3>

<PRE>
interface UndefinedType extends Type
{
}
</PRE>

<h2>The interface <code>UnionType</code></h2>

<P><span class="pcounter"></span> The intrinsic interface <code>UnionType</code> describes a union of other
types.  No object has a union type for its manifest type.  Union types
are only used for annotating parameters or fields, and cannot be instantiated.

<h3>Synopsis</h3>

<PRE>
interface UnionType extends Type
{
    function members(): TypeIterator
}
</PRE>

<h3>Methods</h3>

<h4>members&nbsp;(&nbsp;)</h4>

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>members</code> method returns an iterator that iterates over the
member types of the union.


<h2>The interface <code>RecordType</code></h2>

<P><span class="pcounter"></span> The intrinsic interface <code>RecordType</code> describes a structural
object type.

<h3>Synopsis</h3>

<PRE>
interface RecordType extends Type
{
    function fields(): FieldIterator
    function construct(valArgs: FieldValueIterator): Object
}
</PRE>

<h3>Methods</h3>

<h4>fields&nbsp;(&nbsp;)</h4>

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>fields</code> method returns an iterator that iterates over
the fields of the record type.

<h4>construct&nbsp;(&nbsp;valArgs&nbsp;)</h4>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The <code>construct</code> method creates a new instance of the
structural object type represented by this <code>RecordType</code>.

<P><span class="pcounter"></span> The iterator <i>valArgs</i> provides any field names and values
required to initialize the object.  All values will be consumed from
the iterator; the iterator may provide more field names and values
than are required by the type.  If the iterator does not provide a
value for a field required by the type, the field will be initialized
to <b>undefined</b> cast to the type of the field; this may cause a
<b>TypeError</b> exception to be thrown at run-time.

<P><span class="pcounter"></span> <i>ValArgs</i> may not be null.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>construct</code> method returns a new object of the type
represented by this <code>RecordType</code>.

<h2>The interface <code>ArrayType</code></h2>

<P><span class="pcounter"></span> The intrinsic interface <code>ArrayType</code> describes a structural array
type.

<h3>Synopsis</h3>

<PRE>
interface ArrayType extends Type
{
    function fields(): FieldIterator
    function construct(length: uint, valArgs: FieldValueIterator): Object
}
</PRE>

<h3>Methods</h3>

<h4>fields&nbsp;(&nbsp;)</h4>

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>fields</code> method returns an iterator that iterates over
the fields of the array type.  The fields are iterated from low to
high indices, and only fields that are present are iterated.  The name
of the field provides the field index as the <code>identifier</code>.

<h4>construct&nbsp;(&nbsp;length,&nbsp;valArgs&nbsp;)</h4>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The <code>construct</code> method creates a new instance of the
structural array type represented by this <code>ArrayType</code>.

<P><span class="pcounter"></span> The value <i>length</i> provides the value for the length of the
array; it is set after all fields have been initialized.

<P><span class="pcounter"></span> The iterator <i>valArgs</i> provides any field names and values
required to initialize the object.  All values will be consumed from
the iterator; the iterator may provide more field names and values
than are required by the type.  The field name must encode the correct
array index of the field in the <code>identifier</code>.  If the iterator does
not provide a value for a field required by the type, the field will
be initialized to <b>undefined</b> cast to the type of the field; this
may cause a <b>TypeError</b> exception to be thrown at run-time.

<P><span class="pcounter"></span> <i>ValArgs</i> may not be null.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>construct</code> method returns a new object of the type
represented by this <code>ArrayType</code>.

<h2>The interface <code>FunctionType</code></h2>

<P><span class="pcounter"></span> The intrinsic interface <code>FunctionType</code> describes a structural
function type.  Function types cannot be instantiated.

<h3>Synopsis</h3>

<PRE>
interface FunctionType extends Type
{
    function boundThis(): Type
    function argTypes(): TypeIterator
    function defaultValues(): ValueIterator
    function hasRestType(): boolean
    function returnType(): Type
}
</PRE>

<h3>Methods</h3>

<h4>boundThis&nbsp;(&nbsp;)</h4>

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>boundThis</code> method returns a type if the function has a
bound <code>this</code> value, otherwise it returns an <code>AnyType</code> object.

<h4>argTypes&nbsp;(&nbsp;)</h4>

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>argTypes</code> method returns an iterator that iterates over
the types of the formal parameters of the function, starting with the
first argument and iterating in order, including all optional and rest
arguments.

<P><span class="pcounter"></span> Arguments that do not have annotations will be revealed as type
<code>AnyType</code>.

<h4>defaultValues&nbsp;(&nbsp;)</h4>

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>defaultValues</code> method returns an iterator that iterates
over the default values of the optional arguments, starting with the
first default value and iterating in order.

<h4>hasRestTypes()</h4>

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>hasRestTypes</code> method returns <b>true</b> if the function
has a rest argument, <b>false</b> otherwise.

<h4>returnType&nbsp;(&nbsp;)</h4>

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>returnType</code> method returns the return type annotation
for this function, or an <code>AnyType</code> object if there was no type
annotation.


<h2>Iterator types</h2>

<P><span class="pcounter"></span> The following iterator type definitions are used as annotations on
parameters and methods in the interface hierarchy described
previously.

<PRE>
type FieldIterator = iterator::IteratorType.&#60;Field>
type ClassTypeIterator = iterator::IteratorType.&#60;ClassType>
type NominalTypeIterator = iterator::IteratorType.&#60;NominalType>
type TypeIterator = iterator::IteratorType.&#60;Type>
type FieldValueIterator = iterator::IteratorType.&#60;FieldValue>
type ValueIterator = iterator::IteratorType.&#60;*>
</PRE>



<H1 id="class ControlInspector"> The optional class <code>ControlInspector</code> </H1>

<PRE>
FILE:                       spec/library/ControlInspector.html
DRAFT STATUS:               DRAFT 1 - ROUGH - 2007-09-19
REVIEWED AGAINST ES3:       N/A
REVIEWED AGAINST ERRATA:    N/A
REVIEWED AGAINST BASE DOC:  N/A
REVIEWED AGAINST PROPOSALS: NO
REVIEWED AGAINST CODE:      NO
</PRE>


<P><span class="pcounter"></span> The class <code>ControlInspector</code> is a parameterized, non-dynamic,
non-final, nullable, direct subclass of <code>Object</code>.

<P><span class="pcounter"></span> <code>ControlInspector</code> is an optional facility: ECMAScript
implementations may choose not to provide it.

<P><span class="pcounter"></span> Instances of <code>ControlInspector</code> are used to annotate points in
the continuation ("the control stack") with arbitrary data, and to
retrieve those data.  When a function <i>f</i> is entered, there is a
continuation in effect for the call to <i>f</i>.  Calls from <i>f</i> to a
control inspector's <code>annotate</code> method create annotations on that
continuation (not on the activation record for <i>f</i> or on any other
control data associated with the internal state of <i>f</i>).  Once <i>f</i>
returns, any annotations it created are effectively erased.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  In the following, all classes and methods are defined in the
<code>intrinsic</code> namespace.

<h2>Synopsis</h2>

<P><span class="pcounter"></span> The class <code>ControlInspector</code> provides the following interface:

<PRE>
class ControlInspector.&#60;T>
{
    static const length = 0;

    final function annotate(val: T): void &#x0085;
    final function getCurrentAnnotation(): T? &#x0085;
    final function getAnnotations(): iterator::IteratorType.&#60;T> &#x0085;
}
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The methods on <code>ControlInspector</code> are <code>final</code> to give the
ECMAScript implementations some flexibility in how to implement them.

<P><span class="pcounter"></span> The <code>ControlInspector</code> prototype object provides no new direct
properties.


<h2>Methods on the <code>ControlInspector</code> class object</h2>

<h3>new&nbsp;ControlInspector.&lt;T>()</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The <code>ControlInspector</code> constructor initializes a new
<code>ControlInspector</code> instance for the base type <i>T</i>.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span> The <code>ControlInspector</code> constructor is
implementation-dependent.


<h2>Methods on <code>ControlInspector</code> instances</h2>

<h3>annotate&nbsp;(&nbsp;<i>value</i>&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The <code>annotate</code> method annotates the continuation of the
current function with a <i>value</i> of the base type <i>T</i>.  The value
is associated with this <code>ControlInspector</code> instance.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  Two <code>ControlInspectors</code> with the same base type <i>T</i> can
place independent annotations on the same continuation, and these
annotations do not interfere with each other in any way.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span> The <code>annotate</code> method is implementation-dependent.


<h3>getCurrentAnnotation&nbsp;(&nbsp;)</h3>

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>getCurrentAnnotation</code> method returns the annotation
associated with this annotator instance for the continuation of the
current function, or <b>null</b> if there is no such annotation.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span> The <code>getCurrentAnnotation</code> method is implementation-dependent.


<h3>getAnnotations&nbsp;(&nbsp;)</h3>

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>getAnnotations</code> method returns an iterator that iterates
over all annotations associated with this <code>ControlInspector</code>
instance for the entire continuation of the current function, arranged
from most recent (top of the continuation) to least recent (bottom of
the continuation).

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span> The <code>getAnnotations</code> method is implementation-dependent.





<h1>Error classes</h1>

<pre>
FILE:                       spec/library/Error.html
DRAFT STATUS:               DRAFT 1 - ROUGH - 2007-09-20
REVIEWED AGAINST ES3:       NO
REVIEWED AGAINST ERRATA:    NO
REVIEWED AGAINST BASE DOC:  NO
REVIEWED AGAINST PROPOSALS: NO
REVIEWED AGAINST CODE:      NO
</pre>

<P><span class="pcounter"></span> ECMAScript provides a hierarchy of standard native error classes
rooted at the class <code>Error</code> (see <span class="xref">class Error</span>).

<P><span class="pcounter"></span> The ECMAScript implementation throws a new instance of one of
the native error classes when it detects certain run-time errors.  The
conditions under which run-time errors are detected are explained
throughout this Standard.  The description of each of the native error
objects contains a summary of the conditions under which an instance
of that particular error class is thrown.

<P><span class="pcounter"></span> The class <code>Error</code> serves as the base class for all the classes
describing standard errors thrown by the ECMAScript implementation:
<code>EncodingError</code>, <code>EvalError</code>, <code>RangeError</code>, <code>ReferenceError</code>, <code>SyntaxError</code>,
<code>TypeError</code>, and <code>URIError</code>.
(See <span class="xref">class EncodingError</span>, <span class="xref">class EvalError</span>, <span class="xref">class RangeError</span>,
<span class="xref">class ReferenceError</span>, <span class="xref">class SyntaxError</span>,
<span class="xref">class TypeError</span>, <span class="xref">class URIError</span>.)

<P><span class="pcounter"></span> The class <code>Error</code> as well as all its native subclasses are
non-final and dynamic and may be subclassed by user-defined exception
classes.

<P><span class="pcounter"></span> All the built-in subclasses of <code>Error</code> share the same structure.


<H1 id="class Error"> The class <code>Error</code> </h1>

<P><span class="pcounter"></span> The class <code>Error</code> is a dynamic non-final subclass of <code>Object</code>.
Instances of <code>Error</code> are not thrown by the implementation; rather,
<code>Error</code> is intended to serve as a base class for other error classes
whose instances represent specific classes of run-time errors.

<h2>Synopsis</h2>

<P><span class="pcounter"></span> The class <code>Error</code> provides the following interface:

<PRE>
dynamic class Error extends Object 
{
    function Error(message) &#x0085
    meta static function invoke(message) &#x0085
    
    static const length = 1
    
    override intrinsic function toString() &#x0085
}
</PRE>

<P><span class="pcounter"></span> The <code>Error</code> prototype object provides these direct properties:

<PRE>
    toString: function () &#x0085; ,
    name:     "Error" ,
    message:  &#x0085; ,
</PRE>

<h2>Methods on the <code>Error</code> class</h2>

<h3>new&nbsp;Error&nbsp;(message)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> When the <code>Error</code> constructor is called as part of a
<code>new&nbsp;Error</code> expression it initialises the newly created object:
If <i>message</i> is not <b>undefined</b>, the dynamic <code>message</code> property
of the newly constructed <code>Error</code> object is set to <code>string(<i>message</i>)</code>.

<P class="implsection"><b>Implementation</b>
<PRE>
function Error(message) {
    if (message !== undefined)
        this.public::message = string(message);
}
</PRE>

<h3>Error&nbsp;(message)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> When the <code>Error</code> class object is called as a function, it
creates and initialises a new <code>Error</code> object by invoking the
<code>Error</code> constructor.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>Error</code> class object called as a function returns a new
<code>Error</code> object.

<P class="implsection"><b>Implementation</b>
<PRE>
meta static function invoke(message)
    new Error(message);
</PRE>


<h2>Methods on <code>Error</code> instances</h2>

<h3>intrinsic::toString(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toString</code> method converts the <code>Error</code> object
to an implementation-defined string.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> A <code>string</code> object.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span> The intrinsic <code>toString</code> method is implementation-dependent.


<h2>Methods on the <code>Error</code> prototype object</h2>

<h3>toString&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The prototype <code>toString</code> method calls the intrinsic <code>toString</code> method.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The prototype <code>toString</code> method returns a <code>string</code> object.

<P class="implsection"><b>Implementation</b>
<PRE>
prototype function toString(this:Error)
    this.intrinsic::toString();
</PRE>

<h2>Value properties on the <code>Error</code> prototype object</h2>

<h3>message</h3>

<P><span class="pcounter"></span> The initial value of the <code>message</code> prototype property is an
implementation-defined string.




<H1 id="class EncodingError"> The class <code>EncodingError</code> </H1>

<P><span class="pcounter"></span> The implementation throws a new <code>EncodingError</code> instance when an
attempt was made to encode or decode data that are self-referential
with an encoder or decoder that does not allow such data.

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  Clean up the section references when we reach final draft.

<h2>Synopsis</h2>

<P><span class="pcounter"></span> The <code>EncodingError</code> class provides this interface:

<PRE>
dynamic class EvalError extends Error
{
    function EncodingError(message) &#x0085
    meta static function invoke(message) &#x0085
    
    static const length = 1
}
</PRE>

<P><span class="pcounter"></span> The <code>EncodingError</code> prototype object provides these direct properties:
<PRE>
    name:    "EncodingError" ,
    message: &#x0085; ,
</PRE>

<h2>Methods on the <code>EncodingError</code> class</h2>

<h3>new&nbsp;EncodingError&nbsp;(message)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> When the <code>EncodingError</code> constructor is called as part of a
<code>new&nbsp;EncodingError</code> expression it initialises the newly created
object by delegating to the <code>Error</code> constructor.

<P class="implsection"><b>Implementation</b>
<PRE>
function EncodingError(message)
    : super(message)
{
}
</PRE>


<h3>EvalError&nbsp;(message)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> When the <code>EncodingError</code> class object is called as a function, it
creates and initialises a new <code>EncodingError</code> object by invoking the
<code>EncodingError</code> constructor.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>EncodingError</code> class object called as a function returns a
new <code>EncodingError</code> object.

<P class="implsection"><b>Implementation</b>
<PRE>
meta static function invoke(message)
    new EncodingError(message);
</PRE>


<h2>Value properties on the <code>EncodingError</code> prototype object</h2>

<h3>message</h3>

<P><span class="pcounter"></span> The initial value of <code>message</code> prototype property is an implementation-defined string.





<H1 id="class EvalError"> The class <code>EvalError</code> </H1>

<P><span class="pcounter"></span> The implementation throws a new <code>EvalError</code> instance when it
detects that the global function <code>eval</code> was used in a way that is
incompatible with its definition.  See XX.XX.

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  Clean up the section references when we reach final draft.

<h2>Synopsis</h2>

<P><span class="pcounter"></span> The <code>EvalError</code> class provides this interface:

<PRE>
dynamic class EvalError extends Error
{
    function EvalError(message) &#x0085
    meta static function invoke(message) &#x0085
    
    static const length = 1
}
</PRE>

<P><span class="pcounter"></span> The <code>EvalError</code> prototype object provides these direct properties:
<PRE>
    name:    "EvalError" ,
    message: &#x0085; ,
</PRE>

<h2>Methods on the <code>EvalError</code> class</h2>

<h3>new&nbsp;EvalError&nbsp;(message)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> When the <code>EvalError</code> constructor is called as part of a
<code>new&nbsp;EvalError</code> expression it initialises the newly created
object by delegating to the <code>Error</code> constructor.

<P class="implsection"><b>Implementation</b>
<PRE>
function EvalError(message)
    : super(message)
{
}
</PRE>


<h3>EvalError&nbsp;(message)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> When the <code>EvalError</code> class object is called as a function, it
creates and initialises a new <code>EvalError</code> object by invoking the
<code>EvalError</code> constructor.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>EvalError</code> class object called as a function returns a
new <code>EvalError</code> object.

<P class="implsection"><b>Implementation</b>
<PRE>
meta static function invoke(message)
    new EvalError(message);
</PRE>


<h2>Value properties on the <code>EvalError</code> prototype object</h2>

<h3>message</h3>

<P><span class="pcounter"></span> The initial value of <code>message</code> prototype property is an implementation-defined string.




<H1 id="class RangeError"> The class <code>RangeError</code> </H1>

<P><span class="pcounter"></span> The implementation throws a new <code>RangeError</code> instance when it
detects that a numeric value has exceeded the allowable range. See
15.4.2.2, 15.4.5.1, 15.7.4.5, 15.7.4.6, and 15.7.4.7.

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  Clean up the section references when we reach final draft.

<h2>Synopsis</h2>

<P><span class="pcounter"></span> The <code>RangeError</code> class provides this interface:

<PRE>
dynamic class RangeError extends Error
{
    function RangeError(message) &#x0085
    meta static function invoke(message) &#x0085
    
    static const length = 1
}
</PRE>

<P><span class="pcounter"></span> The <code>RangeError</code> prototype object provides these direct properties:
<PRE>
    name:    "RangeError" ,
    message: &#x0085; ,
</PRE>

<h2>Methods on the <code>RangeError</code> class</h2>

<h3>new&nbsp;RangeError&nbsp;(message)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> When the <code>RangeError</code> constructor is called as part of a
<code>new&nbsp;RangeError</code> expression it initialises the newly created
object by delegating to the <code>Error</code> constructor.

<P class="implsection"><b>Implementation</b>
<PRE>
function RangeError(message)
    : super(message)
{
}
</PRE>


<h3>RangeError&nbsp;(message)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> When the <code>RangeError</code> class object is called as a function, it
creates and initialises a new <code>RangeError</code> object by invoking the
<code>RangeError</code> constructor.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>RangeError</code> class object called as a function returns a
new <code>RangeError</code> object.

<P class="implsection"><b>Implementation</b>
<PRE>
meta static function invoke(message)
    new RangeError(message);
</PRE>


<h2>Value properties on the <code>RangeError</code> prototype object</h2>

<h3>message</h3>

<P><span class="pcounter"></span> The initial value of <code>message</code> prototype property is an implementation-defined string.




<H1 id="class ReferenceError"> The class <code>ReferenceError</code> </H1>

<P><span class="pcounter"></span> The implementation throws a new <code>ReferenceError</code> instance when it
detects an invalid reference value. See 8.7.1, and 8.7.2.

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  Clean up the section references when we reach final draft.

<h2>Synopsis</h2>

<PRE>
dynamic class ReferenceError extends Error
{
    function ReferenceError(message) &#x0085
    meta static function invoke(message) &#x0085
    
    static const length = 1
}
</PRE>

<P><span class="pcounter"></span> The <code>ReferenceError</code> prototype object provides these direct properties:
<PRE>
    name:    "ReferenceError" ,
    message: &#x0085; ,
</PRE>

<h2>Methods on the <code>ReferenceError</code> class</h2>

<h3>new&nbsp;ReferenceError&nbsp;(message)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> When the <code>ReferenceError</code> constructor is called as part of a
<code>new&nbsp;ReferenceError</code> expression it initialises the newly created
object by delegating to the <code>Error</code> constructor.

<P class="implsection"><b>Implementation</b>
<PRE>
function ReferenceError(message)
    : super(message)
{
}
</PRE>


<h3>ReferenceError&nbsp;(message)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> When the <code>ReferenceError</code> class object is called as a function, it
creates and initialises a new <code>ReferenceError</code> object by invoking the
<code>ReferenceError</code> constructor.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>ReferenceError</code> class object called as a function returns a
new <code>ReferenceError</code> object.

<P class="implsection"><b>Implementation</b>
<PRE>
meta static function invoke(message)
    new ReferenceError(message);
</PRE>


<h2>Value properties on the <code>ReferenceError</code> prototype object</h2>

<h3>message</h3>

<P><span class="pcounter"></span> The initial value of <code>message</code> prototype property is an implementation-defined string.




<H1 id="class SyntaxError"> The class <code>SyntaxError</code> </H1>

<P><span class="pcounter"></span> The implementation throws a new <code>SyntaxError</code> instance when a
parsing error has occurred. See 15.1.2.1, 15.3.2.1, 15.10.2.5,
15.10.2.9, 15.10.2.15, 15.10.2.19, and 15.10.4.1.

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  Clean up the section references when we reach final draft.

<h2>Synopsis</h2>

<PRE>
dynamic class SyntaxError extends Error
{
    function SyntaxError(message) &#x0085
    meta static function invoke(message) &#x0085
    
    static const length = 1
}
</PRE>

<P><span class="pcounter"></span> The <code>SyntaxError</code> prototype object provides these direct properties:
<PRE>
    name:    "SyntaxError" ,
    message: &#x0085; ,
</PRE>

<h2>Methods on the <code>SyntaxError</code> class</h2>

<h3>new&nbsp;SyntaxError&nbsp;(message)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> When the <code>SyntaxError</code> constructor is called as part of a
<code>new&nbsp;SyntaxError</code> expression it initialises the newly created
object by delegating to the <code>Error</code> constructor.

<P class="implsection"><b>Implementation</b>
<PRE>
function SyntaxError(message)
    : super(message)
{
}
</PRE>


<h3>SyntaxError&nbsp;(message)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> When the <code>SyntaxError</code> class object is called as a function, it
creates and initialises a new <code>SyntaxError</code> object by invoking the
<code>SyntaxError</code> constructor.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>SyntaxError</code> class object called as a function returns a
new <code>SyntaxError</code> object.

<P class="implsection"><b>Implementation</b>
<PRE>
meta static function invoke(message)
    new SyntaxError(message);
</PRE>


<h2>Value properties on the <code>SyntaxError</code> prototype object</h2>

<h3>message</h3>

<P><span class="pcounter"></span> The initial value of <code>message</code> prototype property is an implementation-defined string.




<h1 id="class TypeError"> The class <code>TypeError</code> </H1>

<P><span class="pcounter"></span> The implementation throws a new <code>TypeError</code> instance when it has
detected that the actual type of an operand is different than the
expected type. See 8.6.2, 8.6.2.6, 9.9, 11.2.2, 11.2.3, 11.8.6,
11.8.7, 15.3.4.2, 15.3.4.3, 15.3.4.4, 15.3.5.3, 15.4.4.2, 15.4.4.3,
15.5.4.2, 15.5.4.3, 15.6.4, 15.6.4.2, 15.6.4.3, 15.7.4, 15.7.4.2,
15.7.4.4, 15.9.5, 15.9.5.9, 15.9.5.27, 15.10.4.1, and 15.10.6.

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  Clean up the section references when we reach final draft.

<h2>Synopsis</h2>

<PRE>
dynamic class TypeError extends Error
{
    function TypeError(message) &#x0085
    meta static function invoke(message) &#x0085
    
    static const length = 1
}
</PRE>

<P><span class="pcounter"></span> The <code>TypeError</code> prototype object provides these direct properties:
<PRE>
    name:    "TypeError" ,
    message: &#x0085; ,
</PRE>

<h2>Methods on the <code>TypeError</code> class</h2>

<h3>new&nbsp;TypeError&nbsp;(message)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> When the <code>TypeError</code> constructor is called as part of a
<code>new&nbsp;TypeError</code> expression it initialises the newly created
object by delegating to the <code>Error</code> constructor.

<P class="implsection"><b>Implementation</b>
<PRE>
function TypeError(message)
    : super(message)
{
}
</PRE>


<h3>TypeError&nbsp;(message)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> When the <code>TypeError</code> class object is called as a function, it
creates and initialises a new <code>TypeError</code> object by invoking the
<code>TypeError</code> constructor.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>TypeError</code> class object called as a function returns a
new <code>TypeError</code> object.

<P class="implsection"><b>Implementation</b>
<PRE>
meta static function invoke(message)
    new TypeError(message);
</PRE>


<h2>Value properties on the <code>TypeError</code> prototype object</h2>

<h3>message</h3>

<P><span class="pcounter"></span> The initial value of <code>message</code> prototype property is an implementation-defined string.




<H1 id="class URIError"> The class <code>URIError</code> </H1>

<P><span class="pcounter"></span> The implementation throws a new <code>URIError</code> when one of the global
URI handling functions was used in a way that is incompatible with its
definition. See 15.1.3.

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  Clean up the section references when we reach final draft.

<h2>Synopsis</h2>

<PRE>
dynamic class URIError extends Error
{
    function URIError(message) &#x0085
    meta static function invoke(message) &#x0085
    
    static const length = 1
}
</PRE>

<P><span class="pcounter"></span> The <code>URIError</code> prototype object provides these direct properties:
<PRE>
    name:    "URIError" ,
    message: &#x0085; ,
</PRE>

<h2>Methods on the <code>URIError</code> class</h2>

<h3>new&nbsp;URIError&nbsp;(message)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> When the <code>URIError</code> constructor is called as part of a
<code>new&nbsp;URIError</code> expression it initialises the newly created
object by delegating to the <code>Error</code> constructor.

<P class="implsection"><b>Implementation</b>
<PRE>
function URIError(message)
    : super(message)
{
}
</PRE>


<h3>URIError&nbsp;(message)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> When the <code>URIError</code> class object is called as a function, it
creates and initialises a new <code>URIError</code> object by invoking the
<code>URIError</code> constructor.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>URIError</code> class object called as a function returns a
new <code>URIError</code> object.

<P class="implsection"><b>Implementation</b>
<PRE>
meta static function invoke(message)
    new URIError(message);
</PRE>


<h2>Value properties on the <code>URIError</code> prototype object</h2>

<h3>message</h3>

<P><span class="pcounter"></span> The initial value of <code>message</code> prototype property is an implementation-defined string.





</body>
</html>
