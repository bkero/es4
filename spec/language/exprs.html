= Expressions =

<pre>
FILE:                       spec/language/expr.html
DRAFT STATUS:               DRAFT 1 - ROUGH - 2008-02-14
REVIEWED AGAINST ES3:       NO
REVIEWED AGAINST ERRATA:    NO
REVIEWED AGAINST BASE DOC:  NO
REVIEWED AGAINST PROPOSALS: NO
REVIEWED AGAINST CODE:      NO
</pre>

<p>

There are four kinds of expressions: name, literal, general, and type.
Literal expressions have a known type after parsing. Identifier expressions
evaluate to a Name objects that are a part of a reference general expression. Type expressions compute
values of type Type. General expressions include all other expressions.

</p>

== Identifier Expressions ==

Identifier expressions evaluate to a singleton name. They occur as a part of
a reference in a type or value expression, and in a field name of an object literal.

<IMPL>
<pre>
fun evalIdentExpr (regs:Mach.REGS)
                  (identExpr:Ast.IDENT_EXPR)
    : NAME =
    case identExpr of
        Ast.Identifier { ident } =>
        { ns = NONE, id = evalExprToString regs ident }
      | Ast.QualifiedIdentifier { qual, ident } =>
        { ns = evalExprToNamespace regs qual, id = evalExprToString regs ident }
</pre>

== Literals ==

<p>Null, number, boolean and string literals evaluate to the corresponding
machine values. Array, Object, Function, and RegExp literals are evaluated as 
described in the following sections.

<pre>
fun evalLiteralExpr (regs:Mach.REGS)
                    (lit:Ast.LITERAL)
    : Mach.VAL =
    case lit of
        Ast.LiteralNull => Mach.Null
      | Ast.LiteralDouble r => newDouble regs r
      | Ast.LiteralBoolean b => newBoolean regs b
      | Ast.LiteralString s => newString regs s
      | Ast.LiteralArray {exprs=Ast.ListExpr exprs, ty} => evalLiteralArrayExpr regs exprs ty (* FIXME handle comprehensions *)
      | Ast.LiteralObject {expr, ty} => evalLiteralObjectExpr regs expr ty
      | Ast.LiteralFunction f => newFunctionFromFunc regs (#scope regs) f
      | Ast.LiteralRegExp re => evalLiteralRegExp regs (#str re)
</pre>

=== Object literals ===

<pre>

fun evalLiteralObjectExpr (regs:Mach.REGS)
                          (fields:Ast.FIELD list)
                          (ty:Ast.TY option)
    : Mach.VAL =
    let
        fun searchFieldTypes n [] = Ast.SpecialType Ast.Any
          | searchFieldTypes n ({name,ty}::ts) =
            if n = name
            then ty
            else searchFieldTypes n ts
        val tyExprs = case Option.map (evalTy regs) ty of
                          NONE => []
                        | SOME (Ast.ObjectType tys) => tys
                        (* FIXME: hoist this to parsing or defn; don't use
                         * a full TYPE_EXPR in LiteralObject. *)
                        | SOME _ => error regs ["non-object type on object literal"]
        val tag = Mach.ObjectTag tyExprs
        val objectClass = needObj regs (getValue regs (#global regs) Name.nons_Object)
        val Mach.Obj { magic, ... } = objectClass
        val obj = case (!magic) of
                      SOME (Mach.Class objectClassClosure) =>
                      constructStandardWithTag regs objectClass objectClassClosure [] tag
                    | _ => error regs ["Error in constructing array literal"]
        val (Mach.Obj {props, ...}) = obj
        fun processField {kind, name, init} =
            let
                val const = case kind of
                                Ast.Const => true
                              | Ast.LetConst => true
                              | _ => false
                val n = case evalIdentExpr regs name of
                            Name n => n
                          | Multiname n => Name.nons (#id n)
                val v = evalExpr regs init
                val ty = makeTy (searchFieldTypes (#id n) tyExprs)
                val prop = { ty = ty,
                             (* FIXME: handle virtuals *)
                             state = Mach.ValProp v,
                             attrs = { dontDelete = false,
                                       dontEnum = false,
                                       readOnly = const,
                                       isFixed = false } }
            in
                Mach.addProp props n prop
            end
    in
        List.app processField fields;
        Mach.Object obj
    end
</pre>

=== Array literals ===

<pre>

fun evalLiteralArrayExpr (regs:Mach.REGS)
                         (exprs:Ast.EXPR list)
                         (ty:Ast.TY option)
    : Mach.VAL =
    let
        val vals = map (evalExpr regs) exprs
        val tyExprs = case Option.map (evalTy regs) ty of
                          NONE => [Ast.SpecialType Ast.Any]
                        | SOME (Ast.ArrayType tys) => tys
                        (* FIXME: hoist this to parsing or defn; don't use
                         * a full TYPE_EXPR in LiteralArray. *)
                        | SOME _ => error regs ["non-array type on array literal"]
        val tag = Mach.ArrayTag tyExprs
        val arrayClass = needObj regs (getValue regs (#global regs) Name.nons_Array)
        val Mach.Obj { magic, ... } = arrayClass
        val obj = case (!magic) of
                      SOME (Mach.Class arrayClassClosure) =>
                      constructStandardWithTag regs arrayClass arrayClassClosure [] tag
                    | _ => error regs ["Error in constructing array literal"]
        val (Mach.Obj {props, ...}) = obj
        fun putVal n [] = n
          | putVal n (v::vs) =
            let
                val name = Name.nons (Ustring.fromInt n)
                (* FIXME: this is probably incorrect wrt. Array typing rules. *)
                val ty = makeTy (if n < (length tyExprs)
                                 then List.nth (tyExprs, n)
                                 else (if (length tyExprs) > 0
                                       then List.last tyExprs
                                       else Ast.SpecialType Ast.Any))
                val prop = { ty = ty,
                             state = Mach.ValProp v,
                             attrs = { dontDelete = false,
                                       dontEnum = false,
                                       readOnly = false,
                                       isFixed = false } }
            in
                Mach.addProp props name prop;
                putVal (n+1) vs
            end
        val numProps = putVal 0 vals
    in
        setValue regs obj Name.nons_length (newUInt regs (Real64.fromInt numProps));
        Mach.Object obj
    end

</pre>

=== RegExp literals ===

<pre>
fun evalLiteralRegExp (regs:Mach.REGS)
                      (re:Ustring.STRING)
    : Mach.VAL =
    let fun findSplit 0 = 0
          | findSplit n =
            if Ustring.charCodeAt re n = Char.ord #"/" then
                n
            else
                findSplit (n-1)
        val len = Ustring.stringLength re
        val split = findSplit (len - 1)
    in
        newRegExp regs 
                  (Ustring.substring re      1             (split - 1) )
                  (Ustring.substring re (split + 1) (len - (split + 1)))
    end
</pre>

== Value Expressions ==

A value expression has the concrete syntax of //ThisExpression//, //LetExpression//, ..., 
and the abstract form of //LiteralExpr//, //ListExpr//, //LexicalRef//, //ObjectRef//,
//LetExpr//, //TerneryExpr//, .... It is evaluated by the function //evalExpr// as 
invoked by the function //evalStmt// and numerous other functions.

<IMPL>
<pre>
fun evalExpr (regs:Mach.REGS)
             (expr:Ast.EXPR)
    : Mach.VAL =
    case expr of
        Ast.LiteralExpr lit =>
        evalLiteralExpr regs lit

      | Ast.ListExpr es =>
        evalListExpr regs es

      | Ast.LexicalRef { ident, loc } =>
        evalLexicalRef regs ident loc

      | Ast.ObjectRef { base, ident, loc } =>
        evalObjectRef regs base ident loc

      | Ast.LetExpr {defs, body, head} =>
        evalLetExpr regs (valOf head) body

      | Ast.TernaryExpr (aexpr, bexpr, cexpr) =>
        evalCondExpr regs aexpr bexpr cexpr

      | Ast.BinaryExpr (bop, aexpr, bexpr) =>
        evalBinaryOp regs bop aexpr bexpr

      | Ast.UnaryExpr (unop, expr) =>
        evalUnaryOp regs unop expr

      | Ast.TypeExpr ty =>
        evalTypeExpr regs (evalTy regs ty)

      | Ast.ThisExpr kind =>
        evalThisExpr regs kind

          (* 
           * Naked super-exprs on their own are not permitted. Super is only 
           * permitted in a few contexts, which we explicitly handle elsewhere
           * (CallExprs and constructor settings).
           *)
      | Ast.SuperExpr _ => 
           error regs ["super expression in illegal context"]

      | Ast.SetExpr (aop, pat, expr) =>
        evalSetExpr regs aop pat expr

      | Ast.CallExpr { func, actuals } =>
        evalCallExpr regs func actuals

      | Ast.NewExpr { obj, actuals } =>
        evalNewExpr regs obj actuals

      | Ast.GetTemp n =>
        evalGetTemp regs n

      | Ast.InitExpr (target,tempHead,inits) =>
        evalInitExpr regs target tempHead inits

      | Ast.BinaryTypeExpr (typeOp, expr, tyExpr) =>
        evalBinaryTypeOp regs typeOp expr tyExpr

      | Ast.GetParam n =>
        LogErr.unimplError ["unhandled GetParam expression"]

      | Ast.ApplyTypeExpr { expr, actuals } =>
        evalApplyTypeExpr regs expr (map (evalTy regs) actuals)

      | _ => LogErr.unimplError ["unhandled expression type"]    

</pre>

=== This expressions ===

This expressions can be modified by an optional keyword: ''generator'' or ''function''. 
The modifier indicates whether the expression refers to the current this object, 
generator or function.

<pre>
fun evalThisExpr (regs:Mach.REGS)
                 (kind:Ast.THIS_KIND option)
    : Mach.VAL = 
    let
        (* FIXME function and generator this *)
        val { this, ... } = regs
    in
        Mach.Object this
    end
</pre>

=== Lexical References ===

<pre>
fun evalLexicalRefExpr (regs:Mach.REGS)
                  (ident:Ast.IDENT_EXPR)
                  (loc:Ast.LOC option) 
    : Mach.VAL =
    let
        val _ = LogErr.setLoc loc;
        val expr = Ast.LexicalRef { ident = ident, loc = loc }
        val (obj, name) = evalLexicalRef regs expr true
        val _ = LogErr.setLoc loc;
    in
        getValue regs obj name
    end

fun evalLexicalRef (regs:Mach.REGS)
                   (expr:Ast.EXPR)
                   (errIfNotFound:bool)
    : REF =
    let
        fun defaultRef obj nomn =
            case nomn of
                Multiname mname => (obj, Name.nons (#id mname))
              | Name name => (obj, name)
    in
        case expr of
            Ast.LexicalRef { ident, loc } =>
            let
                val _ = LogErr.setLoc loc
                val nomn = evalIdentExpr regs ident
                val _ = LogErr.setLoc loc
                val refOpt = resolveOnScopeChain (#scope regs) nomn
                val _ = LogErr.setLoc loc
                val r = case refOpt of
                            SOME r => r
                          | NONE => if errIfNotFound
                                    then (throwRefErr regs ["unresolved lexical reference ", nomnToStr nomn]; dummyRef)
                                    else defaultRef (#global regs) nomn
            in
                r
            end

          | _ => error regs ["need lexical reference expression"]
    end
</pre>

=== ObjectRef ===

<pre>
fun evalObjectRefExpr (regs:Mach.REGS)
                     (base:Ast.EXPR)
                     (ident:Ast.IDENT_EXPR)
                     (loc:Ast.LOC option)
    : Mach.VAL =
    let
        val _ = LogErr.setLoc loc
        val expr = Ast.ObjectRef { base = base, ident = ident, loc = loc }
        val (_, (obj, name)) = evalObjectRef regs expr false
        val _ = LogErr.setLoc loc
    in
        getValue regs obj name
    end

fun evalObjectRef (regs:Mach.REGS)
                  (expr:Ast.EXPR)
                  (errIfNotFound:bool)
    : (Mach.OBJ option * REF) =
    let
        fun defaultRef obj nomn =
            case nomn of
                Multiname mname => (obj, Name.nons (#id mname))
              | Name name => (obj, name)
    in
        case expr of
            Ast.ObjectRef { base, ident, loc } =>
            let
                val _ = LogErr.setLoc loc
                val v = evalExpr regs base
                val _ = LogErr.setLoc loc
                val nomn = evalIdentExpr regs ident
                val _ = LogErr.setLoc loc
                val ob = let
                    fun extractFrom v = 
                        case v of
                            Mach.Object ob => ob
                          | Mach.Wrapped (v',t) => extractFrom v'
                          | Mach.Null => (throwRefErr regs ["object reference on null value"]; dummyObj)
                          | Mach.Undef => (throwRefErr regs ["object reference on undefined value"]; dummyObj)
                in
                    extractFrom v
                end
                val _ = LogErr.setLoc loc
                val refOpt = resolveName ob nomn
                val _ = LogErr.setLoc loc
                val r = case refOpt of
                            SOME ro => ro
                          | NONE => if errIfNotFound
                                    then (throwRefErr regs ["unresolved object reference ", nomnToStr nomn]; dummyRef)
                                    else defaultRef ob nomn
                val _ = LogErr.setLoc loc
                val (holder, n) = r
                val _ = trace ["resolved object ref to ", fmtName n,
                               " on object #", Int.toString (getObjId holder),
                               " with this=#", Int.toString (getObjId ob)]
            in
                (SOME ob, r)
            end

          | _ => error regs ["need object reference expression"]
    end
</pre>

=== CallExpr ===

<pre>
and evalCallExpr (regs:Mach.REGS)
                 (func:Ast.EXPR)
                 (actuals:Ast.EXPR list)
    : Mach.VAL = 
    let
        fun evalArgs _ = map (evalExpr regs) actuals
    in
        case func of
            Ast.LexicalRef _ => evalCallMethodByExpr regs func (evalArgs ())
                                
          | Ast.ObjectRef { base = Ast.SuperExpr NONE, ident, loc } => 
            evalSuperCall regs (#this regs) ident (evalArgs())

          | Ast.ObjectRef { base = Ast.SuperExpr (SOME b), ident, loc } => 
            evalSuperCall regs (needObj regs (evalExpr regs b)) ident (evalArgs())
            
          | Ast.ObjectRef _ => evalCallMethodByExpr regs func (evalArgs ())
                               
          | _ =>
            let
                val funcVal = evalExpr regs func
                val funcObj = needObj regs funcVal
                val args = evalArgs ()
            in
                evalCallByObj regs funcObj args
            end
    end
</pre>

=== NewExpr ===

<pre>
fun evalNewExpr (regs:Mach.REGS)
                (obj:Ast.EXPR)
                (actuals:Ast.EXPR list)
    : Mach.VAL = 
    let
        fun args _ = map (evalExpr regs) actuals
        val rhs = evalExpr regs obj
    in
        case rhs of
            Mach.Object ob => evalNewObj regs ob (args())
          | _ => (throwTypeErr regs ["not a constructor"]; dummyVal)
    end
</pre>

=== ApplyTypeExpr ===
=== UnaryExpr ===
=== BinaryExpr ===
=== BinaryTypeExpr ===
=== TypeExpr ===
=== YieldExpr ===
=== LetExpr ===
=== Conditional expressions ===

<p>A conditional expression has the concrete syntax of //ConditionalExpression// 
or //NonAssignmentExpression//, and the abstract form of //TernaryExpr//. It is evaluated by the function //evalCondExpr// as 
invoked by the function //evalExpr//.

<IMPL>
{{{
fun evalCondExpr (regs:Mach.REGS)
                 (cnd:Ast.EXPR)
                 (thn:Ast.EXPR)
                 (els:Ast.EXPR)
    : Mach.VAL =
    let
        val v = evalExpr regs cnd
        val b = toBoolean v
    in
        if b
        then evalExpr regs thn
        else evalExpr regs els
    end
}}}

=== SetExpr ===

<p>A //set expression// has the concrete syntax of //AssignmentExpression// such as
the simple form:

{{{
    x = y
}}}

and the compound form:

{{{
    x += y
}}}

<p>The current value of the property being assigned is modified by the value on the
right side and the binary operation specified. In the case of the simple assignment
operation, the value of the left side property is replaced with the value on the 
right side.

<IMPL>
{{{
fun evalSetExpr (regs:Mach.REGS)
                (aop:Ast.ASSIGNOP)
                (lhs:Ast.EXPR)
                (rhs:Ast.EXPR)
    : Mach.VAL =
    let
        val (thisOpt, (obj, name)) = evalRefExpr regs lhs false
        val v =
            let
                fun modifyWith bop =
                    let val v = evalExpr regs rhs
                    in 
                        performBinop regs bop (getValue regs obj name) v
                    end
            in
                case aop of
                    Ast.Assign => evalExpr regs rhs
                  | Ast.AssignPlus => modifyWith Ast.Plus
                  | Ast.AssignMinus => modifyWith Ast.Minus
                  | Ast.AssignTimes => modifyWith Ast.Times
                  | Ast.AssignDivide => modifyWith Ast.Divide
                  | Ast.AssignRemainder => modifyWith Ast.Remainder
                  | Ast.AssignLeftShift => modifyWith Ast.LeftShift
                  | Ast.AssignRightShift => modifyWith Ast.RightShift
                  | Ast.AssignRightShiftUnsigned => modifyWith Ast.RightShiftUnsigned
                  | Ast.AssignBitwiseAnd => modifyWith Ast.BitwiseAnd
                  | Ast.AssignBitwiseOr => modifyWith Ast.BitwiseOr
                  | Ast.AssignBitwiseXor => modifyWith Ast.BitwiseXor
                  | Ast.AssignLogicalAnd =>
                    let
                        val a = getValue regs obj name
                    in
                        if toBoolean a
                        then evalExpr regs rhs
                        else a
                    end
                  | Ast.AssignLogicalOr =>
                    let
                        val a = getValue regs obj name
                    in
                        if toBoolean a
                        then a
                        else evalExpr regs rhs
                    end
            end
    in 
        case thisOpt of 
            NONE => setValue regs obj name v
          | SOME this => setValue regs this name v);
        v
    end
}}}


=== ListExpr ===

<p>A //list expression// is evaluated by evaluating each of its elements, from first to last,
and returning the value of the last expression.

<IMPL>
{{{
fun evalListExpr (regs:Mach.REGS)
                 (exprList:Ast.EXPR list)
    : Mach.VAL =
    case exprList of
        [] => malformed_list ()
      | [expr] => evalExpr regs expr
      | (expr::exprRest) => ((evalExpr regs expr); (evalListExpr regs exprRest))
}}}

=== InitExpr ===

== Type Expressions ==

<p>A type expression evaluates to a normalized type value.

<IMPL>
{{{
fun evalTypeExpr (regs:Mach.REGS)
                 (typeExpr:Ast.TYPE_EXPR)
    : Mach.VAL = (* FIXME should be a type value *)
    case typeExpr of
        Ast.SpecialType st => Mach.Null (* FIXME *)
      | Ast.UnionType ut => Mach.Null (* FIXME *)
      | Ast.ArrayType a => Mach.Null (* FIXME *)
      | Ast.TypeName tn => evalExpr regs (Ast.LexicalRef { ident=tn, loc=NONE })
      | Ast.FunctionType ft => Mach.Null (* FIXME *)
      | Ast.ObjectType ot => Mach.Null (* FIXME *)
      | Ast.LikeType lt => Mach.Null (* FIXME *)
      | Ast.NullableType { expr, nullable } => Mach.Null (* FIXME *)
      | Ast.InstanceType { ty, ... } => Mach.Null (* FIXME *)
      | _ => Mach.Null (* FIXME *)
}}}
