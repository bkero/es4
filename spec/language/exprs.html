= Expressions =

<pre>
FILE:                       spec/language/expr.html
DRAFT STATUS:               DRAFT 1 - ROUGH - 2008-02-14
REVIEWED AGAINST ES3:       NO
REVIEWED AGAINST ERRATA:    NO
REVIEWED AGAINST BASE DOC:  NO
REVIEWED AGAINST PROPOSALS: NO
REVIEWED AGAINST CODE:      NO
</pre>

== Identifier Expressions ==

<p>An ''IDENTIFIER_EXPRESSION'' evaluates to a ''NAME''.

<IMPL>
<INCLUDE file="eval.sml" name="and evalIdentExpr">

== Literals ==

<p>Null, number, boolean and string literals evaluate to the corresponding
machine values. Array, Object, Function, and RegExp literals are evaluated as 
described in the following sections.

<pre>

fun evalLiteralExpr (regs:Mach.REGS)
                    (lit:Ast.LITERAL)
    : Mach.VAL =
    case lit of
        Ast.LiteralNull => Mach.Null
      | Ast.LiteralDouble r => newDouble regs r
      | Ast.LiteralBoolean b => newBoolean regs b
      | Ast.LiteralString s => newString regs s
      | Ast.LiteralArray {exprs=Ast.ListExpr exprs, ty} => 
        evalLiteralArrayExpr regs exprs ty
      | Ast.LiteralObject {expr, ty} => evalLiteralObjectExpr regs expr ty
      | Ast.LiteralFunction f => newFunctionFromFunc regs (#scope regs) f
      | Ast.LiteralRegExp re => evalLiteralRegExp regs (#str re)
</pre>

=== Object literals ===

<IMPL>
<INCLUDE file="eval.sml" name="and evalLiteralObjectExpr">

=== Array literals ===

<IMPL>
<INCLUDE file="eval.sml" name="and evalLiteralArrayExpr">

=== RegExp literals ===

<IMPL>
<INCLUDE file="eval.sml" name="and evalLiteralRegExp">

== Value Expressions ==

A value expression has the concrete syntax of //ThisExpression//, //LetExpression//, ..., 
and the abstract form of //LiteralExpr//, //ListExpr//, //LexicalRef//, //ObjectRef//,
//LetExpr//, //TerneryExpr//, .... It is evaluated by the function //evalExpr// as 
invoked by the function //evalStmt// and numerous other functions.

<IMPL>
<INCLUDE file="eval.sml" name="and evalExpr">

=== This expressions ===

This expressions can be modified by an optional keyword: ''generator'' or ''function''. 
The modifier indicates whether the expression refers to the current this object, 
generator or function.

<IMPL>
<INCLUDE file="eval.sml" name="fun evalThisExpression">

=== Lexical References ===

<IMPL>
<INCLUDE file="eval.sml" name="fun evalLexicalRef">
<INCLUDE file="eval.sml" name="fun getDefaultName">


=== ObjectRef ===

<IMPL>
<INCLUDE file="eval.sml" name="fun evalObjectRef">

=== CallExpr ===

=== NewExpr ===

=== ApplyTypeExpr ===
=== UnaryExpr ===
=== BinaryExpr ===
=== BinaryTypeExpr ===
=== TypeExpr ===
=== YieldExpr ===
=== LetExpr ===
=== Conditional expressions ===

<p>A conditional expression has the concrete syntax of //ConditionalExpression// 
or //NonAssignmentExpression//, and the abstract form of //TernaryExpr//. 
 It is evaluated by the function //evalCondExpr// as 
invoked by the function //evalExpr//.

<IMPL>
<INCLUDE file="eval.sml" name="and evalCondExpr">

=== SetExpr ===

<p>A //set expression// has the concrete syntax of //AssignmentExpression// such as
the simple form:

{{{
    x = y
}}}

and the compound form:

{{{
    x += y
}}}

<p>The current value of the property being assigned is modified by the value on the
right side and the binary operation specified. In the case of the simple assignment
operation, the value of the left side property is replaced with the value on the 
right side.

<IMPL>

=== CommaExpression ===

<p>A //comma expression// is evaluated by evaluating each of its elements, from first to last,
and returning the value of the last expression.

=== InitExpr ===

== Type Expressions ==

<p>A type expression evaluates to a normalized type value.

<IMPL>
{{{
fun evalTypeExpr (regs:Mach.REGS)
                 (typeExpr:Ast.TYPE_EXPR)
    : Mach.VAL = (* FIXME should be a type value *)
    case typeExpr of
        Ast.SpecialType st => Mach.Null (* FIXME *)
      | Ast.UnionType ut => Mach.Null (* FIXME *)
      | Ast.ArrayType a => Mach.Null (* FIXME *)
      | Ast.TypeName tn => evalExpr regs (Ast.LexicalRef { ident=tn, loc=NONE })
      | Ast.FunctionType ft => Mach.Null (* FIXME *)
      | Ast.ObjectType ot => Mach.Null (* FIXME *)
      | Ast.LikeType lt => Mach.Null (* FIXME *)
      | Ast.NullableType { expr, nullable } => Mach.Null (* FIXME *)
      | Ast.InstanceType { ty, ... } => Mach.Null (* FIXME *)
      | _ => Mach.Null (* FIXME *)
}}}
