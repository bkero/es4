= Notation =

<hr>
<pre>
FILE:                       spec/language/notation.html
DRAFT STATUS:               DRAFT 1 - INCOMPLETE - 2008-03-13
REVIEWED AGAINST ES3:       NO
REVIEWED AGAINST ERRATA:    NO
REVIEWED AGAINST BASE DOC:  NO
REVIEWED AGAINST PROPOSALS: NO
REVIEWED AGAINST CODE:      NO
</pre>
<hr>

== Grammar Notation ==
=== Lexical Syntax ===
=== RegExp Syntax ===
=== Numeric Syntax ===
=== Program Syntax ===

<p>The notation used to define the program syntax and its translation to the
abstract syntax mixes the use of a context free grammar with Standard ML to
describe a syntax directed translation.

<p>The notation has the form illustrated in the following example:

<pre>
rul Term (ctx) : TERM =
    **0** => Ast.Zero ctx
  | **1** => Ast.One ctx

rul Expr (ctx) : EXPR =
    **-** Term => Ast.Expr (Ast.Minus, Term ())
  | Term => Ast.Expr (NONE, Term (ctx))
</pre>

<p>Each production starts with the meta keyword ''rul'' and is followed by the nonterminal name,
a parameter list and a result type.

<p>After the ''='' symbol is a list of definitions of possible syntaxes for the non-terminal
being defined. Each rule consists of a pattern and an action separated by the ''=>'' punctuation.

<p>The pattern on the left of the ''=>'' symbol describes the syntax to be matched by the rule.
The expression on the right of the ''=>'' symbol defines the action to be taken if the rule is
matched. The action might include invoking other parser rules, constructing AST nodes, or calling
helper functions. Helper functions may be used to perform non-trivial
desugaring of surface syntax, hoisting of definitions, or otherwise interacting with the
environment to implement context-sensitive behaviors of the parser.

<p>A pattern is matched if the first k tokens in the input stream match the first k terminals
in the language generated by that pattern, where k is the minimum number of tokens needed to 
disambiguate the alternatives.

== Core Semantics ==

<p>The formal semantics are specified using a definitional interpreter written
in a small subset of Standard ML.

<p>The subset of SML used is describe here.

=== Type constructors ===

{{{
type NAME = { id: IDENT, ns: NAMESPACE }
}}}

=== Value constructors ===

{{{
datatype NAMESPACE = Public of IDENT
}}}

=== Pattern Matching ===

{{{
case n of
    0 => "first"
  | _ => "second"
}}}

=== Variables ===

{{{
val x = 10
}}}

=== Destructuring ===

{{{
var (x, y) = (10, 20)
var {a, b} = {a=10, b=20}
}}}

=== Functions ===

{{{
fun recurse n = 
    case n of 
        0 => () 
      | _ => recurse n-1
}}}

=== Local Scope ===

{{{
let
    var x = 10
    fun recurse n = ...
in
    recurse x
end
}}}

== Built-in Semantics ==

<p>The built-in objects are defined using ECMAScript as defined in this specification. To aid the reader
the most important language features used to describe the builtins are summarized here.

=== Feature 1 ===


=== Feature 2 ===


== Code Style Guidelines ==

<p>In this section we define some common coding guidelines used in the formal
semantics. Some guidelines are common to both languages, others specific to one
or the other.

=== Common ===

<p>Don't rebind names

<p>Avoid generic names like "x" and "xs" when destructuring

<p>Use nested functions to factor out invariant arguments

<p>Use descriptive names, even if they are wordy

=== Standard ML ===

<p>Type names are all upper case

<p>Value constructors are leading upper case

<p>Function and variable  names are "camel" case

<p>Parenthesize the expression in the case head if it is anything
   but a variable

=== ECMAScript ===

