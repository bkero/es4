= Names =

<hr>
<pre>
FILE:                       spec/language/names.html
DRAFT STATUS:               DRAFT 6 - UNREVIEWED - 2008-05-08
AUTHORS:                    Jeff, Graydon
REVIEWED AGAINST ES3:       NO
REVIEWED AGAINST ERRATA:    NO
REVIEWED AGAINST BASE DOC:  NO
REVIEWED AGAINST PROPOSALS: NO
REVIEWED AGAINST CODE:      YES, code is basis of RI
SCOPE:                      The structure and resolution of names
</pre>

<hr>

<p>A property name consists of an identifier and a namespace qualifier.

<p>The accessibility of a binding is determined by the accessibility of its namespace. In
other words if you can name a property, you can read it.

===== Semantics =====
<INCLUDE file="ast.sml" name="type NAME">

<p>Identfiers are sequences of characters.

===== Semantics =====
<INCLUDE file="ast.sml" name="type IDENTIFIER">

== Namespaces ==

<p>A namespace is an immutable object that serves as a distinct tag with which programmers can
organize and manage groups of identifiers. In this sense, a namespace is a kind of name
//parameter// that can be used to control the meaning of a name.

<p>Namespaces may be transparent or opaque. Transparent namespaces are represented by strings and
their equality is defined by the equality of the underlying strings. Opaque namespaces do not have
an underlying string value. In the implementation code, each opaque namespace is given a unique,
system-assigned identifier.

===== Semantics =====
<INCLUDE file="ast.sml" name="datatype NAMESPACE">
<INCLUDE file="ast.sml" name="type OPAQUE_NAMESPACE_IDENTIFIER">

<p>Any two transparent namespaces with the same identifier string are considered equal.  An opaque
namespace is specified to be equal only to itself. This is also true in the SML implementation as no
two opaque namespaces are ever given the same system-assigned identifier.

===== Semantics =====
<INCLUDE file="fixture.sml" name="fun compareNamespaces">

=== The Public Namespace ===

<p>The public namespace is defined as the trasparent namespace containing only the empty string.
It is only member of the initial open namespace set, and is the initial default binding namespace 
for new unqualified bindings. 

<p>Namespace attributes are not allowed on local definitions. The names of local definitions are
always qualified by the public namespace.

<p>Code written for the 3rd edition or earlier -- by definition, ignorant of any means for namespace 
qualification -- sees and creates only bindings qualified by the public namespace.

===== Semantics =====
<INCLUDE file="name.sml" name="val publicNS">

<!-- 
<p>The 4th edition namespace is an opaque namespace. It is also a member of the initial open
namespace set when running in 4th edition mode. All new bindings introduced by the 4th edition
built-in library are qualified by the 4th edition namespace (or a namespace that is itself qualified
by the 4th edition namespace).

<p>The 4th edition namespace is bound to a name formed from the identifier ''__ES4__'' and the 
public namespace.

<p>The public namespace is bound to a name formed from the identifier ''public'' and the 4th 
edition namespace.

<p>Therefore in practice, code running in 3rd edition mode will see the 4th edition namespace only
through the unqualified reference ''__ES4__'', and will not see a binding for the public
namespace. In contrast, code running in 4th edition mode will see the public namespace as the
unqualified reference ''public'', and also -- since 4th edition code can by definition contain 
qualified references -- as the qualified name ''__ES4__::public''.
--> 

== Prototype Chains ==

<p>A prototype chain contains a list of objects that are searched when resolving a name on the
first object in the list.

== Scope Chains and Scope Objects ==

<p>A scope chain contains a list of scope objects that are searched when resolving a lexical 
reference.

<p>A scope chain may include a class object (with class ''static'' properties), an instance
object and one or more local scope objects in addition to the global, activation and with objects of
edition 3.

=== Scope Objects ===

<P> The following are the kinds of scope objects and the forms that introduce
names in those scopes:

<UL>
  <LI> The //global scope// is shared between multiple //Programs//.
  It contains pre-defined bindings (the language-defined libraries and
  any host-defined extensions) and is extended when definitions have
  an effect on it.  A possibly unbounded sequence of //Programs// is
  evaluted in the global scope in a linear order.  A definition
  introduced by a later //Program// is visible to every earlier
  //Program//.

  <P > The forms that introduce names into the global environment are
  //VariableDefinition//, //ClassDefinition//,
  //InterfaceDefinition//, //TypeDefinition//,
  //NamespaceDefinition//, //FunctionDefinition//,
  //AssignmentStatement//, and //EvalExpression//.


  <LI> The //file scope// is specific to one "file", that is to say,
  one chunk of program text that matches the the //Program//
  nonterminal and which is processed independently from other files.

  <P > The only form that operates on the file scope is the //Pragma//.


  <LI> The //class static scope// extends from the left curly brace
  that starts the class body to the right curly brace that ends the
  class body.  The class static scope is nested within the global
  scope.

  <P > The forms that introduce names into the class static scope are
  the ''static'' annotated forms of //VariableDefinition//,
  //TypeDefinition//, //NamespaceDefinition//, and
  //FunctionDefinition//.  In addition, an //AssignmentExpression// can
  introduce names into a class static scope dynamically.

  <P > The surrounding scope of a function defined in the class static
  scope is that class static scope.


  <LI> The //class instance scope// is defined by multiple disjoint
  pieces of text.  It extends from the left curly brace that starts
  the class body to the right curly brace that ends the class body.
  It also incorporates the class instance scope of its direct
  superclass.  In addition, an //AssignmentExpression// can introduce
  names into a class instance scope dynamically, provided that the
  class has been declared ''dynamic''.

  <P > The class instance scope for a class definition is nested within
  the class static scope for that definition.

  <P > The forms that introduce names into the class instance scope are
  //VariableDefinition// and //FunctionDefinition//.

  <P > The surrounding scope of a function defined in the class
  instance scope is that instance scope; however, the surrounding
  scope of a function inherited from a superclass is the instance
  scope of the class from which it is inherited.


  <LI> The //function scope// covers the body of a function, either
  from the opening left brace of the body to the closing right brace,
  or the expression that makes up the function body in an expression
  closure.

  <P > (That is, types in the signature are resolved in the enclosing
  scope.)

  <P > Since a static initializer block for a class is treated as an
  anonymous function, the function scope extends also from the left
  curly brace of the initializer block through the closing right curly
  brace.

  <P > The forms that introduce names into a function scope are the
  function form itself -- the parameter names are bound in the
  function scope -- as well as instances of //VariableDefinition// and
  //FunctionDefinition// that occur in the body.

  <LI> The //block scope// is introduced by the left curly brace of
  certain source phrases (//Block//, //SwitchStatement//,
  //CatchClause//, //TypeCaseElement//, and //LetBlockStatement//) and
  extends to the matching right curly brace.

  <P > A block scope is also introduced by a binding //ForStatement//
  and extends through the end of that statement's //SubStatement//.

  <P > **Note:** Among these statements, only the //Block// and a
  primitive form of //CatchClause// are fundamental, all the other
  statements can be expressed in terms of these two.

  <P > The forms that introduce names into a block scope are
  //VariableDefinition// and //FunctionDefinition//.
  //LetBlockStatement//, //CatchClause//, and //TypeCaseElement//.
  (However, these forms are not allowed as the direct
  //SubStatements// of a binding //ForStatement//, and the only form
  to introduce a binding into the block scope of a //ForStatement// is
  the statement itself.)


  <LI> The //with scope// is introduced by a //WithStatement// and
  extends through the end of the statement's //SubStatement//.

  <P > New names can be introduced into a with scope dynamically by
  means of //AssignmentExpression//: an assignment that creates a new
  property on the object that the //WithStatement// operates upon
  introduces the name of the property into the with scope.


  <LI> The //expression scope// is introduced by the left parenthesis
  of a //LetExpression//, the name of a named //FunctionExpression//,
  or the left square bracket of an //ArrayComprehension//.  The scope
  extends to the end of the //LetExpression//, the end of the
  //FunctionExpression//, or to the matching right square bracket of
  the array comprehension.

  <P > There are no forms to introduce new names into expression scopes
  except the names introduced by those expression forms themselves:
  the names introduced in the //LetExpression// head, the name of the
  //FunctionExpression//, and the names introduced by ''for'' and
  ''let'' clauses in the //ArrayComprehension//.
  
</UL>

<P> As a rule it is not legal to introduce a particular name in a
particular scope more than once.  (Note that top-level bindings in a
function are bound in the same scope as the function's parameters and
its implicit ''arguments'' parameter.)

<P> However, in "strict" code more than one ''var'' (or ''let'')
binding can introduce a particular name in a particular global,
function, or block scope, provided the two bindings have the same type
annotation (or no annotation at all).  The binding keyword used to
bind the name must be the same in all the binding forms that introduce
the name.  (Parameters and the ''arguments'' object are assumed to be
bound by some system-internal binding form, not ''var'', and duplicate
parameter names are not allowed.)

<P> Additionally, in "standard" mode the following are allowed (in
order to preserve compatibility with the 3rd Edition):

<UL>

  <LI> Parameter bindings and the ''arguments'' binding are assumed to
  be bound as if by ''var'', so duplicate parameter names are allowed,
  as are ''var'' bindings in a function body that bind names that are
  also bound as parameters.  Again, annotations must be the same in
  all bindings of a particular name.

  <LI> Multiple ''var'' and ''function'' forms may bind the same name,
  provided the bindings are all unannotated.
  
</UL>

=== Visibility ===

<FIXME> More here.

<P> Bound, created, and introduced names are visible in the entire
scope of the binding.  However, the scope of a binding is "static" (it
is determined by the source text) and bindings in inner scopes can
//shadow// bindings in outer scopes.

<P> "use namespace" controls the shadowing, to an extent.  

<P> A shadowed identifier in a base class may sometimes be made
visible in a subclass by means of a //SuperExpression//.

<!--

== Name Bindings ==

=== Forms that introduce names ===

<P> //Names// are //bound// in //scopes// by //defining forms// and
//binding forms//.

==== Defined and bound names ====

<P> The defining forms are //VariableDefinition//,
//FunctionDefinition//, //ClassDefinition//, //InterfaceDefinition//,
//TypeDefinition//, and //NamespaceDefinition//.  Except in block
scopes (see below) a defining form permits the name to be qualified by
a namespace.  The current default namespace is used if no qualifier is
present.

<P> (The initial default namespace in any block scope is ''public'', and it is
not legal to set a different default namespace in a block scope.
Therefore all names bound in block scopes are in the ''public''
namespace.)

<P> The binding forms are //FunctionExpression//, //LetExpression//,
//CatchClause//, //TypeCaseElement//, //LetStatement//,
//LetBlockStatement//, //ForStatement//, and //ArrayComprehension//.
The binding forms do not permit names to be qualified by namespaces;
all names bound by these forms are in the ''public'' namespace.

<P> Names that are introduced by defining forms and binding forms are
//fixtures//: they are guaranteed always to be present at run-time.


==== Created and introduced names ====

<P> Names can be //created// dynamically (at run-time) in the global
scope by means of assignment and by the pre-defined global ''eval''
function.  Names can also be created dynamically in the global scope
and in any function scope by the ''eval'' operator evaluating a
program text that contains a top-level ''var'' or ''function''
definition,

<P> Names can be created dynamically in class static and class
instance scopes by creating a new property on the class object or the
instance object.  (Dynamic name creation is only possible on instances
of classes that are declared ''dynamic''.)

<P> Dynamic creation of names is not possible in strict code.
Top-level created names can have non-''public'' namespace
qualifiers.

<P> Names that are created dynamically can be removed by means of the
''delete'' operator.

<P> Names are also //introduced// in scopes by the //WithStatement//.
(The //WithStatement// is disallowed in strict code.)

<P> Names that created dynamically are never fixtures.  Names that are
introduced by a //WithStatement// are as a rule not fixtures.  Created
and introduced names can as a rule appear and disappear at
unpredictable times during program evaluation.

-->

== Name Expressions ==

<p>A name expression describes a name that is computed from either a namespace //qualified name// or
an //unqualified name//.

===== Semantics =====
<INCLUDE file="ast.sml" name="and NAME_EXPRESSION">

<p>Name expressions occur in several contexts, to qualify declarations, identify types, and also in
three special expression forms called //reference expressions//, defined in a section that follows.

=== Qualified Name ===

<p>A //qualified name// expression consists of a namespace expression and an identifier. A name
expression evaluates to a name value.

<NOTE>Every qualified name expression terminates with a ''NAMESPACE_EXPRESSION'' that is either a literal
namespace (''Namespace'') value or an unqualfied name (''UnqualifiedName'').

==== Namespace Expressions ====

<p>A //namespace expression// consists of either a namespace value or a name expression that must
itself resolve to a namespace value.

===== Semantics =====
<INCLUDE file="ast.sml" name="and NAMESPACE_EXPRESSION">

=== Unqualified Name ===

<p>An //unqualified name// expression consists of an single identifier and some contextual
information -- an open namespaces list -- that describes the name's static
environment. A name value is constructed using the contextual information to search
for a property name that has an identifier that matches that string value and a namespace drawn from
the open namespaces. The algorithm for resolving an unqualified name to a name is presented in
sections that follow.

==== Open Namespaces List ====

<p>An //open namespaces list// is a list of sets of namespace values.  Each execution context
extends this list of sets with a new set of namespace values representing namespaces that are opened
in that execution context. We represent the innermost set in the SML implementation using a
''NAMESPACE list'', but refer to it throughout the accompanying description as a "set" to emphasize
its unordered meaning.

<p>Each namespace set contains the namespaces opened in the same scope which are given the same 
priority during disambiguation. The lowest priority set consists of only the public namespace.

===== Semantics =====
<INCLUDE file="mach.sml" name="type NAMESPACE_SET">
<INCLUDE file="mach.sml" name="type OPEN_NAMESPACES">

<p>The ordering of the outer list is used to to prioritize the search for a matching name. The inner
set is effectively unordered; all namespaces opened in the same execution context are given the same
priority, and all operations on it are order-independent set operations.

<p>An open namespaces list is captured in every unqualified name expression.

== Reference Expressions ==

<p>A //reference expression// is one of three forms of expression that simulatneously describe a name
//and an object//. Reference expressions are used to locate property bindings.

===== Semantics =====
{{{
datatype EXPRESSION =
         LexicalReference of { name: NAME_EXPRESSION }
       | ObjectNameReference of { object: EXPRESSION,
                                  name: NAME_EXPRESSION }
       | ObjectIndexReference of { object: EXPRESSION,
                                   index: EXPRESSION }
       <LDOTS>
}}}

<p>Of these three forms, ''LexicalReference'' expressions evaluate their name expression using the
scope chain, described in the following section, whereas ''ObjectNameReference'' and
''ObjectIndexReference'' expressions evaluate their name expressions using their ''object'' operand.

<NOTE>The third form, ''ObjectIndexReference'', is evaluated by evaluating its ''index'' operand 
to a string value, and then behaving as if it were an ''ObjectNameReference'' on a qualified name 
expression formed from the evaluated string and qualified by the public namespace.

== Name Resolution ==

<p>Name resolution evaluates the various combinations of reference expressions and name expressions
to a pair of object and name values. 

=== Lexical References ===

<p>Here we describe how a target object and a name are computed from a lexical reference. There
are two kinds of lexical references, unqualified and qualified.

<p>Scope objects contain fixed and dynamic bindings. Fixed names in outer scopes may shadow
dynamic names in inner scopes. For example, a fixed class static name might shadow a dynamic 
instance name. This is necessary to allow early resolution of names. 

==== Qualified Lexical References ====

<p>Given a scope chain, an identifier, and a namespace expression, this algorithm searches for
an object in the scope chain and a name on that object that matches the identifier and the 
namespace:

<li>Evaluate the namespace expression to a namespace
<li>Invoke ''searchScope'' with the scope chain, identifier and the namespace resulting from the previous step
<li>If no object results, throw ...
<li>Return the object and name constructed from the computed namespace and the given identifier

==== Unqualified Lexical References ====

<p>If a static name (in a namespace or type expression) resolves to a global name, we reserve
the set of names that consist of the open namespaces with priority equal or higher than the
matched name and the matched names identifier.

<p>Given a scope chain, an identifier, and a list of sets of open namespaces, this algorithm searches for
an object in the scope chain and a name on that object that matches the identifier and one of the
open namespaces:

<li>Invoke the abstract procedure ''searchScope'' with the scope chain, identifier and the
set of all unique open namespaces
<li>If no scope object results, throw ...
<li>If more than one namespace results, invoke ''selectNamespace'' with the scope object, 
    identifier, matching namespaces
<li>If more than one namespace results, throw ...
<li>If the found object is the global object, then invoke the abstract procedure 
''reservedNames'' with the identifier, selected namespace, and the open namespaces
<li>Return the scope object, a name constructed from the identifier and selected namespace, and
the set of reserved names.

==== Searching a Scope Chain ====

<p>Given a scope chain, an identifier, and a list of namespaces, this algorithm searches
for an object in the scope chain and a name on that object that matches the identifier and the
open namespaces.

<p>Initially, consider all currently open namespaces at once -- the union
of all open namespaces -- regardless of the nesting structure of the open namespaces. Search
each scope object

<p>Perform object list search either once or twice with the flattened namespace set, as follows.

<NOTE>Maintaining the integrity of objects requires that name resolution perform two-pass object
list search, and that fixed property bindings cannot be shadowed or otherwise made ambiguous by
expando property bindings.

<p>At first, perform object list search with its search restricted to considering only fixed
property bindings. If the first object list search returns no object or no namespaces, repeat the
object list search with its search relaxed to include all properties, fixed and dynamic.

<NOTE>With scopes and function scopes that might be mutated by 'eval' must be searched fully
during the first pass and ignored during the second pass, to allow shadowing of outer bindings
as is required for backward compatibility.

<p>If no namespaces, or no object, are returned by object list search, return no value. An
object and a matching namepace set can therefore be assumed and are returned.

{{{

fun searchScopeChain (scopeChain, identifier, namespaces)
    : (OBJECT * NAME) option =
    <LDOTS>
}}}

<!-- this is done elsewhere
<p>If one namepace matches, complete resolution with the located object and a name formed from the
identifier and that namespace. If multiple namespaces match, select a further subset using class based namespace
selection, considering the classes inherited by the object. 

<p>Again, if the selection causes no namespaces to match, signal an error. 

<p>If one namespace matches, complete resolution with the located object and a name formed from the
identifier and that namespace. If multiple names match, select a matching subset using open
namespaces based namespace selection. This is the final attempt: exactly one
namespace must match. If any other number of namespaces match, signal an error.
-->

=== Object References ===

<p>Here we describe how a name is computed from a object reference. There
are two kinds of object references, qualified and unqualified.

==== Qualified Object References ====

<p>Given an expression, an identifier, and a namespace expression, this algorithm computes
the object and the name.

<li>Evaluate the expression
<li>If the result is not an object, throw
<li>Evaluate the namespace expression
<li>Return the object and name constructed from the resulting namespace and the given identifier

==== Unqualified Object References ====

<p>Given an expression, an identifier, and a list of open namespace sets, this algorithm searches 
for a name on the object that matches the identifier and the open namespaces.

<li>Evaluate the expression
<li>If the result is not an object, throw ...
<li>Search the resulting object for the set of namespaces corresponding to the names
that match the identifier
<li>If the resulting set of namespaces is empty, then use the set containing only the public namespace
<li>If more than one namespace results, invoke ''selectNamespace'' with the scope object, identifier, matching namespaces
<li>If more than one namespace results, throw ...
<li>Return the object and a name constructed with the identifier and the matching namespace

=== Common Algorithms ===

==== Search an Object  ====

<p>Given an object, an identifier and a set of namespaces, this algorithm searches for a matching
property name.

<p>Informal description: search the provided object for property name bindings that are
named by the provided identifier and any of the namespaces in the provided set. Collect the set of
matching namespaces used in all such bindings. If the set of matching namespaces is nonempty, return
it. Otherwise repeat the process on the prototype of the object, and its prototype, and so forth
along the prototype chain. If the end of the prototype chain is reached without producing a matching
name, return no value.

<INCLUDE file="mach.sml" name="fun objectSearch">

==== Namespace Selection ====

<p>Given an identifier, a list of namespaces, a list of classes, a list of open namespaces, this algorithm
filters the set of namespaces accoring to the order that the namespaces appear in bindings in the given
classes, first, and then the order of priority given by the list of open namespaces.

<FIXME> need more
<li>Invoke ''selectNamespaceByClass with the list of classes, list of namespaces, and identifier.
<li>If the result set contains more than one namespace, invoke ''selectNamespacesByOpenNamespaces
with the resulting set of namespaces and the list of open namespaces.
<li>If the result set does not contain just one namespace, throw ...
<li>Return the selected namespace

==== Class Based Namespace Selection ====

<p>Given a list of classes, an identifier and a set of namespaces, this algorithm selects the
namespaces used on the most generic class of that list. This step is necessary to avoid object
integrity issues that arise when a derived class introduces a binding with the same identifier and a
different namespace in the open namespaces.

<p>**Informal description**: given the list of classes inherited by an object, ordered from most
generic to most derived, consider the class that is the head of this list. 

Search this class for any
instance fixture name bindings that are named by the provided identifier and any of the namespaces
in the provided set. Collect the set of matching namespaces used in all such bindings. If the set of
matching namespaces is nonempty, return it. Otherwise repeat the process on the tail of the list,
and its tail, and so forth down the list. If all the classes in the list are searched and no
matching namespaces are found, return the empty set.

===== Semantics =====
<INCLUDE file="fixture.sml" name="fun selectNamespacesByClass">

==== Open Namespace Based Namespace Selection ====

<p>Given a list of sets of open namespaces (ordered from most recently opened to least recently
opened) and a set of matching namespaces, this algorithm returns a subset of the matching set that
occurs entirely within a single open namespace set.

<p>**Informal description**: intersect the head of the provided open namespace list with the
provided set of namespaces. If that intersection is nonempty, return it. Otherwise repeat the
process with the tail of the open namespace list, and its tail, and so forth up through the list of
open namespace sets. If the end of the list of open namespace sets is reached without producing a
nonempty intersection, return an empty set.

===== Semantics =====
<INCLUDE file="fixture.sml" name="fun selectNamespacesByOpenNamespaces">

==== Reserving Names ====

<p>Given an identifier, a namespace, and a list of sets of open namespaces, this algorithm
computes a set of names consisting of the identifier and each of the open namespaces with
an equal or higher priority than the given namespace.

{{{
fun reservedNames (identifier, namespace, openNamespaces)
    : NAME list =
    <LDOTS>
}}}

<!--
==== Helper functions ====

===== Semantics =====
{{{
fun head x = hd x (* return the first element of a list *)
fun tail x = tl x (* return all but the first element of a list *)

fun matchNamespaces (ns1: NAMESPACE list, ns2: NAMESPACE list)
    : NAMESPACE list =
    (* compute the intersection of two NAMESPACE lists *)
    <LDOTS>

fun getNamespaces (bindings : (NAME * 'a) list, identifier: IDENTIFIER)
    : NAMESPACE list =
    (* get the namespaces of binding names that have a certain identifier *)
    <LDOTS>

fun getInstanceBindingNamespaces (class: CLASS, 
                                  identifier: IDENTIFIER,
                                  namespaces: NAMESPACE_SET)
    : NAMESPACE_SET =
    (* 
     * get the namespaces of names that have a certain identifier
     * and any of a certain set of namespaces, and are bound in 
     * instances of a certain class. 
     *)
    <LDOTS>

fun getBindingNamespaces (object: OBJECT, 
                          identifier: IDENTIFIER,
                          namespaces: NAMESPACE_SET,
                          fixedOnly: bool)
    : NAMESPACE_SET =
    (* 
     * get the namespaces of names (optionally, only the names of
     * fixed properties) that have a certain identifier
     * and any of a certain set of namespaces, and are bound in a
     * certain object. 
     *)
    <LDOTS>

fun getPrototypeObject (object: OBJECT option)
    : OBJECT option =
    (* get the prototype (as in '[[proto]]') object of an object *)
    <LDOTS>

fun getScopeObject (scope: SCOPE option)
    : OBJECT option =
    (* get the first scope object of a scope chain *)
    <LDOTS>

fun getOuterScope (scope: SCOPE option)
    : SCOPE option =
    (* get the next outer scope (as in '[[parent]]') in a scope chain *)
    <LDOTS>

fun getScope ({scope,...}: ENV)
    : SCOPE = 
    (* get the scope chain of an execution environment *)
    scope

fun getOpenNamespaces (env: ENV, identifier: IDENTIFIER)
    : NAMESPACE list list =
    (* get the list of list of namespaces that are open for an identifier *)
    <LDOTS>
}}}
-->
<!--
<INCLUDE file="mach.sml" name="fun matchNamespaces">
<INCLUDE file="mach.sml" name="fun getScope">
<INCLUDE file="mach.sml" name="fun inheritedClassesOf">
<INCLUDE file="mach.sml" name="fun getScopeObject">
<INCLUDE file="mach.sml" name="fun getNamespaces">
<INCLUDE file="mach.sml" name="fun head">
<INCLUDE file="mach.sml" name="fun tail">
-->
