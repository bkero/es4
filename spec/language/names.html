= Names =

<hr>
<pre>
FILE:                       spec/language/names.html
DRAFT STATUS:               DRAFT 2 - REVIEWED - 2008-03-21
AUTHORS:                    Jeff, Graydon
REVIEWED AGAINST ES3:       NO
REVIEWED AGAINST ERRATA:    NO
REVIEWED AGAINST BASE DOC:  NO
REVIEWED AGAINST PROPOSALS: NO
REVIEWED AGAINST CODE:      NO
SCOPE:                      The structure and resolution of names
</pre>
<hr>

<p>A property name consists of an identifier and a namespace qualifier.

<p>The accessibility of a binding is determined by the accessibility of its namespace. In
other words if you can name a property, you can read it.

<IMPL>
<pre>
type NAME = { namespace: NAMESPACE, identifier: IDENTIFIER }
</pre>

<p>Identfiers are Unicode strings.

<IMPL>
<pre>
type IDENTIFIER = Ustring.STRING
</pre>

== Namespaces ==

<p>In order to assist programmers in managing property visibility and avoiding potential 
collisions of property identifiers, the space of identifier strings is partitioned into 
user defined and system defined namespaces. A namespace is an immutable object that 
serves as a distinct tag with which programmers can organize and manage groups of 
identifiers. In this sense, a namespace is a kind of name parameter that can be used
to control the meaning of a name.

<p>Namespaces can be forgeable or unforgeable. A forgeable namespace can be replicated
by creating another forgeable namespace with the same identifier string. An 
unforgeable namespace is given a system defined unique ID that is hidden from program code.

<p>Any two forgeable namespaces with the same identifier string are considered equal.
Every unforgeable namespace is considered non-equal to every other namespace.

<IMPL>
{{{
datatype NAMESPACE =
         UnforgeableNamespace of NAMESPACE_ID
       | ForgeableNamespace of IDENTIFIER
}}}
{{{
datatype NAMESPACE_ID = <LDOTS>
}}}

=== Compatibility Namespace ===

<p>To preserve backward compatibility with the 3rd edition, all unqualified property names
are upgraded to names that use a compatibility namespace (also referred to as "no namespace").
The compatibility namespace is an unforgeable namespace that is always open, and is the 
default namespace for definitions in the initial lexical scope of each ES program. Thus we 
say that every property name in ES has a namespace, even if only the compatibility namespace.

<IMPL>
<pre>
val noNS = Ast.UnforgeableNamespace <LDOTS>
</pre>

== References ==

<p>A reference is an expression that refers to a property binding. A reference contains a name
that is computed from either an //unqualified identifier// or a namespace //qualified identifier//.
In this section we describe how the identifier part (''IDENTIFIER_EXPRESSION'' in the semantics) of a reference is resolved to a name.

<IMPL>
<pre>
datatype IDENTIFIER_EXPRESSION =
         Identifier of EXPRESSION
       | QualifiedIdentifier of EXPRESSION * EXPRESSION
</pre>

=== Qualified Identifiers ===

<p>A qualified identifier consists of an expression that computes a namespace value and an 
expression that computes a string value. A name value is constructed at runtime using the
values of these expressions.

=== Unqualified Identifiers ===

<p>An unqualified identifier consists of a single expression that computes a string value.
A name value is constructed at runtime by searching for a property name that has an identifier 
that matches that string value and one of the open namespaces. 

==== Scope Chain ====

<p>A scope chain contains a list of objects that are searched when evaluating a lexical
reference. The exact specification of how scope chains are constructed is described in
//section ..: Execution//. For the purpose of specifying how names are resolved, it is
sufficient to know that a scope chain yields a sequence of objects to be searched.

<FIXME>Scope is the region of program text. In ES there are regions of text that correspond to
the instantiation of objects that hold variables associated with that region of text. We 
refer to those objects as scopes. I wonder
if we can use more precise language that distinguishes between the lexical meaning of scope
and the activation frames created when a scope is entered.

==== Open Namespaces ====

<p>The open namespaces is a list of lists of namespace values. Each execution context extends 
this list of lists with a new list of namespace values representing namespaces that are
opened in that execution context.

<p>The ordering of the outer list is used to to priorize the search for
a matching name. The order of the inner lists is not signficant as all
namespaces opened in the same block are given the same priority. 

<IMPL>
{{{
type OPEN_NAMESPACES = NAMESPACE list list
}}}

{{{
fun extendOpenNamespaces (openNamespaces: OPEN_NAMESPACES) (namespaceList: NAMESPACE list)
    : OPEN_NAMESPACES = 
    namespaceList::openNamespaces
}}}

==== Unqualified Identifier Resolution ====

<p>Unqualified identifiers are resolved to a name using the following informal algorithms.

<p>**Identifier resolution** - given a list of scope objects, a set of all open namespaces and an
identifier, search for a property name that matches the identifier.

{{{
* search the scope chain (Scope search) for a name that matches the identifier and one of the open namespaces.
* if more than one name is matched, 
  * select the name(s) with a more recently opened namespace (Scope selection).
* if more than one name is still matched and the owning object is a class instance, 
  * select the name(s) introduced in the least derived class (Inheritance selection).
* if more than one name still matched, then report an error.
* if one name is matched, then return that name.
* return nil
}}}

<IMPL>
{{{
fun resolveIdentifier (scopes: OBJECT list, namespaces: NAMESPACE list list, identifier: IDENTIFIER)
    : NAME option =
    let
        val {scopes, ...} = env
        val (object, names) = findNamesInScopes (scopes, List.concat namespaces, identifier)
    in
        case names of
            [] => NONE
          | name :: [] => SOME name
          | _ =>
            let
                val names = selectNameByScope (names, namespaces)
            in
                case names of
                    name :: [] => SOME name
                  | [] => NONE
                  | _ => SOME (selectNameByInheritance (names, inheritedClassesOf (valOf object)))
            end
    end
}}}

<p>**Scope chain search** - given a scope chain, open namespaces and an identifier, search for a
matching property name.

{{{
* for each scope in the scope chain
  * search for a matching name in the current scope object (Object search)
  * if a match is found, return that name
  * continue with next scope
* return nil
}}}

<IMPL>
{{{
fun findNamesInScopes ([], ...) = (NONE, [])
  | findNamesInScopes (scopes: OBJECT list, namespaces: NAMESPACE list list, identifier: IDENTIFIER)
    : (OBJECT option, NAME list) =
    let
        val object = hd scopes
        val names = findNamesInObject (object, namespaces, identifier)
    in
        case names of
            [] => findNamesInScopes (tl scopes, identifier, namespaces)
          | _ => (SOME object, names)
    end
}}}

<p>**Object search** - given an object, a set of namespaces and an identifier,
search for a matching property name.

{{{
* for each object in the prototype chain
  * for each namespace in the namespace set
    * search for a matching name in the current object
    * if a match is found, add name to set of matches
    * continue with next namespace
  * if at least one match is found, return that matches
  * continue with next object in prototype chain
* return nil
}}}

<IMPL>
{{{
fun findNamesInObject (NONE, ...) = []
  | findNamesInObject (object: SOME OBJECT, namespaces: NAMESPACE list, identifier: IDENTIFIER)
    : NAME list =
    let
        val names = hasNames (object, namespaces, identifier)
    in
        case names of
            [] => findNamesInObject (prototype object, identifier, openNamespaces)
          | _ => names
    end
}}}

<p>**Scope selection of a name** - given a list of lists of open
namespaces (most recently opened to least recently opened) and a set of names, 
select the name(s) that is in the most recently opened namespace(s)

{{{
* for each set of namespaces in the open namespaces
  * for each namespace in the set of namespaces
    * for each name in the set of names
      * if the namespace and the name's namespace are equal,
        * add that name to the set of matches
      * continue with the next name
  * if matches is not empty, return matches
  * continue with next set of namespaces
* return nil
}}}

<IMPL>
{{{
fun selectNamesByScope ([], ...) = []
 |  selectNamesByScope (namespaces: NAMESPACE list list, names: NAME list)
    : NAME list =
    let
         val names = selectNamesByNamespaces (hd namespaces, names)
    in
        case names of
            [] => selectNameByScope (names, tl namespaces)
          | _ => names
    end
}}}

<p>**Inheritance selection of a name** - given an object and a set of names,
select the name that matches the most generic binding in that object. This
step is necessary to avoid object integrity issues that arise when a derived
class introduces a binding with the same identifier and a different namespace 
in the open namespaces.

{{{
* for each class inherited from object, ordered from most generic to most derived
  * for each names in the given set of names
    * search for a matching name in the current class
    * if a match is found, add name to set of matches
    * continue with next name
  * if matches is of length 1, then return match
  * if matches is of length > 1, report an ambiguity error
  * continue with next class
* return nil
}}}

<IMPL>
{{{
fun selectNameByInheritance (classes: CLASS list, ...) = throw "unresolved name error"
 |  selectNameByInheritance (classes: CLASS list, names: NAME list)
    : NAME =
    let
        val {instanceBindings, ...} = hd classes
        val selection = hasNames (instanceBindings, names)
    in
        case selection of
            [] => selectNameByInheritance (tl classes, names)
          | name :: [] => name
          | _ => throw "ambiguous name error"
    end
}}}

== Phased Identifier Resolution ==

<p>To avoid the problem of dynamic properties shadowing fixed properties, it is necessary to
resolve names in such as way that gives priority to fixed properties. The relevant principle
is that if an identifier may be resolved in an earlier phase (e.g. the name of a type during
program initialization), then its meaning shall remain fixed over the life of the program.
Conceptually, this means that we need to model in the lookup mechanism the phases of execution 
that involve name resolution.

<p>While this two-phase algorithm might appear to double the amount
of work to do, in practical implementations it does the opposite,
greatly reducing the cost of identifier resolution. The reason is that
the set of fixed properties visible in many contexts can be calculated
statically during parsing and compilation, and identifier references
can be resolved to names once during this stage, and never again at
runtime.

<p>Even if identifier resolution is delayed until runtime, a successful
resolution to a fixed property can frequently be cached -- for
example in cases of unqualified lexical references, or unqualified
object references on typed objects -- because no new fixed property may be
introduced at runtime that would make a successful match
ambiguous.


