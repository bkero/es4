= Names =

<hr>
<pre>
FILE:                       spec/language/names.html
DRAFT STATUS:               DRAFT 5 - UNREVIEWED - 2008-05-02
AUTHORS:                    Jeff, Graydon
REVIEWED AGAINST ES3:       NO
REVIEWED AGAINST ERRATA:    NO
REVIEWED AGAINST BASE DOC:  NO
REVIEWED AGAINST PROPOSALS: NO
REVIEWED AGAINST CODE:      YES, code is basis of RI
SCOPE:                      The structure and resolution of names
</pre>

<hr>

<p>A property name consists of an identifier and a namespace qualifier.

<p>The accessibility of a binding is determined by the accessibility of its namespace. In
other words if you can name a property, you can read it.

<IMPL>
<pre>
datatype NAME = Name of (NAMESPACE * IDENTIFIER)
</pre>

<p>Identfiers are sequences of characters.

<IMPL>
<pre>
type IDENTIFIER = Ustring.STRING
</pre>

== Namespaces ==

<p>A namespace is an immutable object that serves as a distinct tag with which programmers can
organize and manage groups of identifiers. In this sense, a namespace is a kind of name
//parameter// that can be used to control the meaning of a name.

<p>Namespaces may be transparent or opaque. Transparent namespaces are represented by strings and
their equality is defined by the equality of the underlying strings. Opaque namespaces do not have
an underlying string value. In the implementation code, each opaque namespace is given a unique,
system-assigned identifier.

<IMPL>
<INCLUDE file="ast.sml" name="datatype NAMESPACE">
<INCLUDE file="ast.sml" name="type OPAQUE_NAMESPACE_IDENTIFIER">

<p>Any two transparent namespaces with the same identifier string are considered equal.  An opaque
namespace is specified to be equal only to itself. This is also true in the SML implementation as no
two opaque namespaces are ever given the same system-assigned identifier.

<IMPL>
<INCLUDE file="fixture.sml" name="fun compareNamespaces">

=== The Public and 4th Edition Namespaces ===

<p>Two important namespaces serve as roots for binding further names in this spec: the public
namespace and the 4th edition namespace.

<p>The public namespace is defined as the transparent namespace containing only the empty string. It
is a member of the initial open namespace set when running in either 3rd edition or 4th edition
mode, and is the initial default binding namespace for new unqualified bindings.

<p>Therefore in practice, code written for the 3rd edition or earlier -- by definition, ignorant of
any means for namespace qualification -- sees and creates only bindings qualified by the public
namespace.

<p>The 4th edition namespace is an opaque namespace. It is also a member of the initial open
namespace set when running in 4th edition mode. All new bindings introduced by the 4th edition
built-in library are qualified by the 4th edition namespace (or a namespace that is itself qualified
by the 4th edition namespace).

<p>The 4th edition namespace is bound to a name formed from the identifier ''__ES4__'' and the 
public namespace.

<p>The public namespace is bound to a name formed from the identifier ''public'' and the 4th 
edition namespace.

<p>Therefore in practice, code running in 3rd edition mode will see the 4th edition namespace only
through the unqualified reference ''__ES4__'', and will not see a binding for the public
namespace. In contrast, code running in 4th edition mode will see the public namespace as the
unqualified reference ''public'', and also -- since 4th edition code can by definition contain 
qualified references -- as the qualified name ''__ES4__::public''.

<NOTE>Namespace attributes are not allowed on local definitions. The names of local definitions are
always qualified by the public namespace.

<IMPL>
<INCLUDE file="name.sml" name="val ES4NS">
<INCLUDE file="name.sml" name="val publicNS">


== Name Expressions ==

<p>A name expression describes a name that is computed from either a namespace //qualified name// or
an //unqualified name//.

<IMPL>
<INCLUDE file="ast.sml" name="and NAME_EXPRESSION">

<p>Name expressions occur in several contexts, to qualify declarations, identify types, and also in
three special expression forms called //reference expressions//, defined in a section that follows.

=== Qualified Name ===

<p>A //qualified name// expression consists of a namespace expression and an identifier. A name
value is constructed at runtime using the values of these components.

=== Unqualified Name ===

<p>An //unqualified name// expression consists of an single identifier and some contextual
information -- an open namespaces list and a global name set -- that describes the name's static
environment. A name value is constructed at runtime by using the contextual information to search
for a property name that has an identifier that matches that string value and a namespace drawn from
the open namespaces. The algorithm for resolving an unqualified name to a name is presented in
sections that follow.

==== Open Namespaces List ====

<p>An //open namespaces list// is a list of sets of namespace values.  Each execution context
extends this list of sets with a new set of namespace values representing namespaces that are opened
in that execution context. We represent the innermost set in the SML implementation using a
''NAMESPACE list'', but refer to it throughout the accompanying description as a "set" to emphasize
its unordered meaning.

<IMPL>
<INCLUDE file="mach.sml" name="type NAMESPACE_SET">
<INCLUDE file="mach.sml" name="type OPEN_NAMESPACES">

<p>The ordering of the outer list is used to to prioritize the search for a matching name. The inner
set is effectively unordered; all namespaces opened in the same execution context are given the same
priority, and all operations on it are order-independent set operations.

<p>An open namespaces list is captured in every unqualified name expression.

==== Global Name Set ====

<p>The //global name set// is a set of all the names of declared top-level (global) fixtures that
occur or have occurred in all compilations units before and including the current compilation unit.

<p>A global name set is captured in every unqualified name expression.

=== Namespace Expressions ===

<p>A //namespace expression// consists of either a namespace value or a name expression that must
itself resolve to a namespace value.

<IMPL>
<INCLUDE file="ast.sml" name="and NAMESPACE_EXPRESSION">

== Reference Expressions ==

<p>A //reference expression// is one of three forms of expression that simulatneously describe a name
//and an object//. Reference expressions are used to locate property bindings.

<IMPL>
{{{
       | LexicalReference of { name: NAME_EXPRESSION }
       | ObjectNameReference of { object: EXPRESSION,
                                  name: NAME_EXPRESSION }
       | ObjectIndexReference of { object: EXPRESSION,
                                   index: EXPRESSION }
}}}

<p>Of these three forms, ''LexicalReference'' expressions evaluate their name expression using the
scope chain, described in the following section, whereas ''ObjectNameReference'' and
''ObjectIndexReference'' expressions evaluate their name expressions using their ''object'' operand.

<NOTE>The third form, ''ObjectIndexReference'', is a degenerate form of ''ObjectNameReference''. It
is evaluated by evaluating its ''index'' operand to a string value, and then behaving as if it were
an ''ObjectNameReference'' on a qualified name expression formed from the evaluated string and
qualified by the public namespace.

=== Scope Chain ===

<p>A scope chain contains a list of objects that are searched when resolving an identifier.  The
exact specification of how scope chains are constructed is described in //section ..:
Execution//. For the purpose of specifying how names are resolved, it is sufficient to know that a
scope chain yields a sequence of objects to be searched.

<NOTE>A scope chain may include a class object (with class ''static'' properties), an instance
object and one or more local scope objects in addition to the global, activation and with objects of
edition 3.

=== Reference Expression Resolution ===

<p>Reference expressions are resolved to an object and a property name using the following algorithms.

<NOTE>Reference expressions in which the target object is provided (''ObjectNameReference'' and
''ObjectIndexReference'') are degenerate cases of a search over a //list// of objects, where the
list has only a single object. Reference expressions to lexical bindings (''LexicalReference'')
imply that the list of objects searched is the list of scope objects that constitute the scope
chain. Likewise, reference expressions using a qualified name expression (''QualifiedName'') are
degenerate forms of reference expressions to unqualified names (''UnqualifiedName'') where the open
namespaces list is contains a single set, itself containing the single namespace of the
''QualifiedName'', and the global name list is the empty list. The algorithms here are used to
specify the meaning of both kinds of reference expression and name expression.

==== Name Resolution ====

<p>Given an object list, an identifier, a list of open namespace sets and a global name set, this
algorithm searches for an object in the list and a property name on the object that matches
identifier and namespaces.

<p>**Informal description** Initially, consider all currently open namespaces at once -- the union
of all open namespaces -- regardless of the nesting structure of the open namespaces. Perform object
list search either once or twice with the flattened namespace set, as follows.

<p>At first, perform object list search with its search restricted to considering only fixed
property bindings. If the first object list search returns no object or no namespaces, repeat the
object list search with its search relaxed to include all properties, fixed and expando.

<NOTE>Maintaining the integrity of objects requires that name resolution perform two-pass object
list search, and that fixed property bindings cannot be shadowed or otherwise made ambiguous by
expando property bindings.

<p>If no namespaces, or no object, are returned by object list search, signal an error. An
object and a matching namepace set can therefore be assumed for the remainder of resolution.

<p>If one namespace matches, complete resolution with the located object and a name formed from the
identifier and that namespace. If multiple names match, select a matching subset using open
namespaces based namespace selection.

<p>Again, if the selection causes no namespaces to match, signal an error. 

<p>If one namepace matches, complete resolution with the located object and a name formed from the
identifier and that namespace.

<p>If multiple namespaces still match, select a further subset using class based namespace
selection, considering the classes inherited by the object. 

<p>If multiple namespaces still match, select a further subset using global name set based namespace
selection, considering the global name set intially provided. This is the final attempt: exactly one
namespace must match. If any other number of namespaces match, signal an error.

<IMPL>
<INCLUDE file="mach.sml" name="fun findName">

==== Object list search ====

<p>Given an object list, a set of namespaces and an identifier, this algorithm searches for a
nonempty matching namespace set in the objects of the list.

<p>**Informal description**: perform object search on the object in the head of the list. If the
set of matching namespaces returned by object search is not empty, return the object and the
nonempty matching namespace set. Otherwise repeat the process with the tail of the list, and its
tail, and so forth along the list. If all objects in the list are searched and no matching
namespaces are found, return no value.

<IMPL>
<INCLUDE file="mach.sml" name="fun objectListSearch">

==== Object Search ====

<p>Given an object, a set of namespaces and an identifier, this algorithm searches for a matching
property name.

<p>**Informal description**: search the provided object for property name bindings that are
named by the provided identifier and any of the namespaces in the provided set. Collect the set of
matching namespaces used in all such bindings. If the set of matching namespaces is nonempty, return
it. Otherwise repeat the process on the prototype of the object, and its prototype, and so forth
along the prototype chain. If the end of the prototype chain is reached without producing a matching
name, return no value.

<IMPL>
<INCLUDE file="mach.sml" name="fun objectSearch">

==== Open Namespace Based Namespace Selection ====

<p>Given a list of sets of open namespaces (ordered from most recently opened to least recently
opened) and a set of matching namespaces, this algorithm returns a subset of the matching set that
occurs entirely within a single open namespace set.

<p>**Informal description**: intersect the head of the provided open namespace list with the
provided set of namespaces. If that intersection is nonempty, return it. Otherwise repeat the
process with the tail of the open namespace list, and its tail, and so forth up through the list of
open namespace sets. If the end of the list of open namespace sets is reached without producing a
nonempty intersection, return an empty set.

<IMPL>
<INCLUDE file="fixture.sml" name="fun selectNamespacesByOpenNamespaces">

==== Class Based Namespace Selection ====

<p>Given a list of classes, an identifier and a set of namespaces, this algorithm selects the
namespaces used on the most generic class of that list. This step is necessary to avoid object
integrity issues that arise when a derived class introduces a binding with the same identifier and a
different namespace in the open namespaces.

<p>**Informal description**: given the list of classes inherited by an object, ordered from most
generic to most derived, consider the class that is the head of this list. Search this class for any
instance fixture name bindings that are named by the provided identifier and any of the namespaces
in the provided set. Collect the set of matching namespaces used in all such bindings. If the set of
matching namespaces is nonempty, return it. Otherwise repeat the process on the tail of the list,
and its tail, and so forth down the list. If all the classes in the list are searched and no
matching namespaces are found, return the empty set.

<IMPL>
<INCLUDE file="fixture.sml" name="fun selectNamespacesByClass">

==== Global Name Based Namespace Selection ====

<p>Given a set of global names, an identifier and a set of namespaces, this algorithm selects any
namespace in the namespace set for which a name formed from the namespace and the identifier is 
present in the global name set.

<IMPL>
<INCLUDE file="fixture.sml" name="fun selectNamespacesByGlobalNames">

<p>**Helper functions**

<IMPL>
{{{
fun head x = hd x (* return the first element of a list *)
fun tail x = tl x (* return all but the first element of a list *)

fun matchNamespaces (ns1: NAMESPACE list, ns2: NAMESPACE list)
    : NAMESPACE list =
    (* compute the intersection of two NAMESPACE lists *)
    <LDOTS>

fun getNamespaces (bindings : (NAME * 'a) list, identifier: IDENTIFIER)
    : NAMESPACE list =
    (* get the namespaces of binding names that have a certain identifier *)
    <LDOTS>

fun getInstanceBindingNamespaces (class: CLASS, 
                                  identifier: IDENTIFIER,
                                  namespaces: NAMESPACE_SET)
    : NAMESPACE_SET =
    (* 
     * get the namespaces of names that have a certain identifier
     * and any of a certain set of namespaces, and are bound in 
     * instances of a certain class. 
     *)
    <LDOTS>

fun getBindingNamespaces (object: OBJECT, 
                          identifier: IDENTIFIER,
                          namespaces: NAMESPACE_SET,
                          fixedOnly: bool)
    : NAMESPACE_SET =
    (* 
     * get the namespaces of names (optionally, only the names of
     * fixed properties) that have a certain identifier
     * and any of a certain set of namespaces, and are bound in a
     * certain object. 
     *)
    <LDOTS>

fun getPrototypeObject (object: OBJECT option)
    : OBJECT option =
    (* get the prototype (as in '[[proto]]') object of an object *)
    <LDOTS>

fun getScopeObject (scope: SCOPE option)
    : OBJECT option =
    (* get the first scope object of a scope chain *)
    <LDOTS>

fun getOuterScope (scope: SCOPE option)
    : SCOPE option =
    (* get the next outer scope (as in '[[parent]]') in a scope chain *)
    <LDOTS>

fun getScope ({scope,...}: ENV)
    : SCOPE = 
    (* get the scope chain of an execution environment *)
    scope

fun getOpenNamespaces (env: ENV, identifier: IDENTIFIER)
    : NAMESPACE list list =
    (* get the list of list of namespaces that are open for an identifier *)
    <LDOTS>
}}}
<!--
<INCLUDE file="mach.sml" name="fun matchNamespaces">
<INCLUDE file="mach.sml" name="fun getScope">
<INCLUDE file="mach.sml" name="fun inheritedClassesOf">
<INCLUDE file="mach.sml" name="fun getScopeObject">
<INCLUDE file="mach.sml" name="fun getNamespaces">
<INCLUDE file="mach.sml" name="fun head">
<INCLUDE file="mach.sml" name="fun tail">
-->
