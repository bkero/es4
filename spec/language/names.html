= Names =

<hr>
<pre>
FILE:                       spec/language/names.html
DRAFT STATUS:               DRAFT 4 - UNREVIEWED - 2008-04-24
AUTHORS:                    Jeff, Graydon
REVIEWED AGAINST ES3:       NO
REVIEWED AGAINST ERRATA:    NO
REVIEWED AGAINST BASE DOC:  NO
REVIEWED AGAINST PROPOSALS: NO
REVIEWED AGAINST CODE:      YES, code is basis of RI
SCOPE:                      The structure and resolution of names
</pre>

<NOTE>Some people have expressed concern over the readability of the SML code used in this specification. 
This problem will be solved in a subsequent revision by a combination of re-writing and automated 
"lowering" of the notation. The early drafts of the core language spec are concerned primarily with 
capturing the precise semantics of ECMAScript, and testibility. We trust that early reviewers will 
be patient enough and read carefully enough to understand the meaning we are trying to express here. 
That said, if anything is unclear, in the code or the prose, please feel free to say so.

<hr>

<p>A property name consists of an identifier and a namespace qualifier.

<p>The accessibility of a binding is determined by the accessibility of its namespace. In
other words if you can name a property, you can read it.

<IMPL>
<pre>
datatype NAME = Name of (NAMESPACE * IDENTIFIER)
</pre>

<p>Identfiers are sequences of characters.

<IMPL>
<pre>
type IDENTIFIER = Ustring.STRING
</pre>

== Namespaces ==

<p>A namespace is an immutable object that serves as a distinct tag
with which programmers can organize and manage groups of
identifiers. In this sense, a namespace is a kind of name //parameter//
that can be used to control the meaning of a name.

<p>Namespaces may be transparent or opaque. Transparent namespaces are represented by strings and
their equality is defined by the equality of the underlying strings. Opaque namespaces do not have
an underlying string value. In the implementation code, each opaque namespace is given a unique,
system-assigned identifier.

<IMPL>
<INCLUDE file="ast.sml" name="datatype NAMESPACE">
<INCLUDE file="ast.sml" name="type NAMESPACE_ID">

<p>Any two transparent namespaces with the same identifier string are considered equal.  An opaque
namespace is specified to be equal only to itself. This is also true in the SML implementation as no
two opaque namespaces are ever given the same system-assigned identifier.

<IMPL>
<INCLUDE file="fixture.sml" name="fun compareNamespaces">

=== The Public and 4th Edition Namespaces ===

<p>Two important opaque namespaces serve as roots for binding further names in this spec: the 
public namespace and the 4th edition namespace.

<p>The public namespace is a member of the initial open namespace set when running in either 3rd
edition or 4th edition mode, and is the initial default binding namespace for new unqualified
bindings.

<p>Therefore in practice, code written for the 3rd edition or earlier -- by definition, ignorant of
any means for namespace qualification -- sees and creates only bindings qualified by the public
namespace.

<p>The 4th edition namespace is also a member of the initial open namespace set when running in 
4th edition mode. All new bindings introduced by the 4th edition built-in library are qualified by
the 4th edition namespace (or a namespace that is itself qualified by the 4th edition namespace).

<p>The 4th edition namespace is bound to a name formed from the identifier ''__ES4__'' and the 
public namespace.

<p>The public namespace is bound to a name formed from the identifier ''public'' and the 4th 
edition namespace.

<p>Therefore in practice, code running in 3rd edition mode will see the 4th edition namespace only
through the unqualified reference ''__ES4__'', and will not see a binding for the public
namespace. In contrast, code running in 4th edition mode will see the public namespace as the
unqualified reference ''public'', and also -- since 4th edition code can by definition contain 
qualified references -- as the qualified name ''__ES4__::public''.

<NOTE>Namespace attributes are not allowed on local definitions. The names of local definitions are
always qualified by the public namespace.

<IMPL>
<pre>
val ES4NS = newOpaqueNS ()
val publicNS = newOpaqueNS ()
</pre>


== Reference Expressions ==

<p>A reference expression is an expression that refers to a property binding. A reference expression
describes a name that is computed from either an //unqualified identifier// or a namespace
//qualified identifier//.  In this section we describe how the identifier part
(''IDENTIFIER_EXPRESSION'') of a reference is resolved to a property name and base object.

<IMPL>
<INCLUDE file="ast.sml" name="datatype IDENTIFIER_EXPRESSION">
<INCLUDE file="ast.sml" name="datatype NAMESPACE_REF">

=== Unqualified Identifiers ===

<p>An unqualified identifier consists of a single expression that computes a string value.
A name value is constructed at runtime by searching for a property name that has an identifier 
that matches that string value and one of the open namespaces. The algorithm for resolving 
an unqualified identifier to a name is presented below.

=== Qualified Identifiers ===

<p>A qualified identifier consists of an expression that computes a namespace value and an 
expression that computes a string value. A name value is constructed at runtime using the
values of these expressions.

=== Scope Chain ===

<p>A scope chain contains a list of objects that are searched when resolving an identifier. 
The exact specification of how scope chains are constructed is described in
//section ..: Execution//. For the purpose of specifying how names are resolved, it is
sufficient to know that a scope chain yields a sequence of objects to be searched.

<NOTE>A scope chain may include a class object (with class ''static'' properties), an
instance object and one or more local scope objects in addition to the global, activation 
and with objects of edition 3.

=== Open Namespaces ===

<p>The open namespaces are a list of sets of open namespace (''OPEN_NAMESPACE'') values.  Each
execution context extends this list of sets with a new set of namespace values representing
namespaces that are opened in that execution context. We represent the innermost set in the SML
implementation using a ''NAMESPACE list'', but refer to it throughout the accompanying description as a
"set" to emphasize its unordered meaning.

<IMPL>
<INCLUDE file="mach.sml" name="type NAMESPACE_SET">
<INCLUDE file="mach.sml" name="type OPEN_NAMESPACES">

<p>The ordering of the outer list is used to to prioritize the search for a matching name. The inner
set is effectively unordered; all namespaces opened in the same execution context are given the same
priority, and all operations on it are order-independent set operations.

=== Identifier Resolution ===

<p>Identifiers are resolved to an object and a property name using the following algorithms.

<NOTE>References where the target object is provided (''ObjectRef'') are a degenerate case of a
search over a list of objects, where the list has only a single object. References to lexical
bindings (''LexicalRef'') imply that the list of objects searched is the list of scope objects that
constitute the scope chain. Likewise, a qualified identifier (''QualifiedIdentifier'') is a
degenerate form of unqualified identifier (''Identifier'') where the set of possible qualifiers is
provided by the open namespaces in the current scope. The algorithms here are used to specify the
meaning of both kinds of reference and both kinds of identifier.

==== Identifier Resolution ====

<p>Given an object list, an identifier and a list of open namespace sets, this algorithm searches
for an object in the list and a property name on the object that matches identifier and namespaces.

<p>Informally, references are resolved to a name and an object containing a property binding with that
name. Initially, resolution considers all currently open namespaces at once -- the union of all open
namespaces -- regardless of the nesting structure of the open namespaces. Object list search is then
performed either once or twice with the flattened namespace set.

<p>At first, object list search is performed with its search restricted to considering only 
fixed property bindings. If the first object list search returns no object or no namespaces, 
object list search is repeated with its search relaxed to include all properties, fixed and expando.

<NOTE>Maintaining the integrity of objects requires that identifier resolution perform two-pass
object list search, and that fixed property bindings cannot be shadowed or otherwise made ambiguous
by expando property bindings.

<p>If no namespaces, or no object, are returned by object list search, an error is signaled. An
object and a matching namepace set can therefore be assumed for the remainder of resolution.

<p>If one namespace matches, resolution completes with a name formed from the identifier and that
namespace. If multiple names match, a matching subset is selected using open namespaces based
namespace selection.

<p>Again, if the selection causes no namespaces to match, an error is signaled. 

<p>If one namepace matches, resolution completes with a name formed from the identifier and that namespace. 

<p>If multiple namespaces still match, a further subset is selected using the class based namespace
selection, considering the classes inherited by the object. This is the final attempt: exactly one
namespace must match, or else an error will be signaled.

<IMPL>
<INCLUDE file="mach.sml" name="fun findName">

==== Object list search ====

<p>Given an object list, a set of namespaces and an identifier, this algorithm searches for a
nonempty matching namespace set in the objects of the list.

<p>**Informal description**: perform object search on the object in the head of the list. If the
set of matching namespaces returned by object search is not empty, return the object and the
nonempty matching namespace set. Otherwise repeat the process with the tail of the list, and its
tail, and so forth along the list. If all objects in the list are searched and no matching
namespaces are found, return no value.

<IMPL>
<INCLUDE file="mach.sml" name="fun objectListSearch">

==== Object Search ====

<p>Given an object, a set of namespaces and an identifier, this algorithm searches for a matching
property name.

<p>**Informal description**: search the provided object for property name bindings that are
named by the provided identifier and any of the namespaces in the provided set. Collect the set of
matching namespaces used in all such bindings. If the set of matching namespaces is nonempty, return
it. Otherwise repeat the process on the prototype of the object, and its prototype, and so forth
along the prototype chain. If the end of the prototype chain is reached without producing a matching
name, return no value.

<IMPL>
<INCLUDE file="mach.sml" name="fun objectSearch">

==== Open Namespace Based Namespace Selection ====

<p>Given a list of sets of open namespaces (ordered from most recently opened to least recently
opened) and a set of matching namespaces, this algorithm returns a subset of the matching set that
occurs entirely within a single open namespace set.

<p>**Informal description**: intersect the head of the provided open namespace list with the provided set of
namespaces. If that intersection is nonempty, return it. Otherwise repeat the process with the tail
of the open namespace list, and its tail, and so forth up through the list of open namespace
sets. If the end of the list of open namespace sets is reached without producing a nonempty
intersection, return an empty set.

<IMPL>
<INCLUDE file="fixture.sml" name="fun selectNamespacesByOpenNamespaces">

==== Class Based Namespace Selection ====

<p>Given a list of classes, an identifier and a set of namespaces, this algorithm selects the
namespaces used on the most generic class of that list. This step is necessary to avoid object
integrity issues that arise when a derived class introduces a binding with the same identifier and a
different namespace in the open namespaces.

<p>**Informal description**: given the list of classes inherited by an object, ordered from most
generic to most derived, consider the class that is the head of this list. Search this class for any
instance fixture name bindings that are named by the provided identifier and any of the namespaces
in the provided set. Collect the set of matching namespaces used in all such bindings. If the set of
matching namespaces is nonempty, return it. Otherwise repeat the process on the tail of the list,
and its tail, and so forth down the list. If all the classes in the list are searched and no
matching namespaces are found, return the empty set.

<IMPL>
<INCLUDE file="fixture.sml" name="fun selectNamespacesByClass">

<p>**Helper functions**

<IMPL>
{{{
fun head x = hd x (* return the first element of a list *)
fun tail x = tl x (* return all but the first element of a list *)

fun matchNamespaces (ns1: NAMESPACE list, ns2: NAMESPACE list)
    : NAMESPACE list =
    (* compute the intersection of two NAMESPACE lists *)
    <LDOTS>

fun getNamespaces (bindings : (NAME * 'a) list, identifier: IDENTIFIER)
    : NAMESPACE list =
    (* get the namespaces of binding names that have a certain identifier *)
    <LDOTS>

fun getInstanceBindingNamespaces (class: CLASS, 
                                  identifier: IDENTIFIER,
                                  namespaces: NAMESPACE_SET)
    : NAMESPACE_SET =
    (* 
     * get the namespaces of names that have a certain identifier
     * and any of a certain set of namespaces, and are bound in 
     * instances of a certain class. 
     *)
    <LDOTS>

fun getBindingNamespaces (object: OBJECT, 
                          identifier: IDENTIFIER,
                          namespaces: NAMESPACE_SET,
                          fixedOnly: bool)
    : NAMESPACE_SET =
    (* 
     * get the namespaces of names (optionally, only the names of
     * fixed properties) that have a certain identifier
     * and any of a certain set of namespaces, and are bound in a
     * certain object. 
     *)
    <LDOTS>

fun getPrototypeObject (object: OBJECT option)
    : OBJECT option =
    (* get the prototype (as in '[[proto]]') object of an object *)
    <LDOTS>

fun getScopeObject (scope: SCOPE option)
    : OBJECT option =
    (* get the first scope object of a scope chain *)
    <LDOTS>

fun getOuterScope (scope: SCOPE option)
    : SCOPE option =
    (* get the next outer scope (as in '[[parent]]') in a scope chain *)
    <LDOTS>

fun getScope ({scope,...}: ENV)
    : SCOPE = 
    (* get the scope chain of an execution environment *)
    scope

fun getOpenNamespaces (env: ENV, identifier: IDENTIFIER)
    : NAMESPACE list list =
    (* get the list of list of namespaces that are open for an identifier *)
    <LDOTS>
}}}
<!--
<INCLUDE file="mach.sml" name="fun matchNamespaces">
<INCLUDE file="mach.sml" name="fun getScope">
<INCLUDE file="mach.sml" name="fun inheritedClassesOf">
<INCLUDE file="mach.sml" name="fun getScopeObject">
<INCLUDE file="mach.sml" name="fun getNamespaces">
<INCLUDE file="mach.sml" name="fun head">
<INCLUDE file="mach.sml" name="fun tail">
-->
