= Names =

<hr>
<pre>
FILE:                       spec/language/names.html
DRAFT STATUS:               DRAFT 3 - REVIEWED - 2008-04-06
AUTHORS:                    Jeff, Graydon
REVIEWED AGAINST ES3:       NO
REVIEWED AGAINST ERRATA:    NO
REVIEWED AGAINST BASE DOC:  NO
REVIEWED AGAINST PROPOSALS: NO
REVIEWED AGAINST CODE:      Compiled, not used
SCOPE:                      The structure and resolution of names
</pre>

<NOTE>Some people have expressed concern over the readability of the SML code used in this specification. 
This problem will be solved in a subsequent revision by a combination of re-writing and automated 
"lowering" of the notation. The early drafts of the core language spec are concerned primarily with 
capturing the precise semantics of ECMAScript, and testibility. We trust that early reviewers will 
be patient enough and read carefully enough to understand the meaning we are trying to express here. 
That said, if anything is unclear, in the code or the prose, please feel free to say so.

<hr>

<p>A property name consists of an identifier and a namespace qualifier.

<p>The accessibility of a binding is determined by the accessibility of its namespace. In
other words if you can name a property, you can read it.

<IMPL>
<pre>
datatype NAME = Name of (NAMESPACE * IDENTIFIER)
</pre>

<p>Identfiers are Unicode strings.

<IMPL>
<pre>
type IDENTIFIER = Ustring.STRING
</pre>

== Namespaces ==

<p>In order to assist programmers in managing property visibility and avoiding potential 
collisions of property identifiers, the space of identifier strings is partitioned into 
user defined and system defined namespaces. A namespace is an immutable object that 
serves as a distinct tag with which programmers can organize and manage groups of 
identifiers. In this sense, a namespace is a kind of name parameter that can be used
to control the meaning of a name.

<p>Namespaces can be forgeable or unforgeable. A forgeable namespace can be replicated
by creating another forgeable namespace with the same identifier string. Every
unforgeable namespace is unique.

<IMPL>
{{{
datatype NAMESPACE =
         UnforgeableNamespace
       | ForgeableNamespace of IDENTIFIER
}}}

<p>Any two forgeable namespaces with the same identifier string are considered equal.
Every unforgeable namespace is considered non-equal to every other namespace.

<IMPL>
<INCLUDE file="mach.sml" name="fun compareNamespaces">

=== Compatibility Namespace ===

<p>To preserve backward compatibility with the 3rd edition, all unqualified property names
are upgraded to names that use a compatibility namespace (also referred to as "no namespace").
The compatibility namespace is an unforgeable namespace that is always open, and is the 
default namespace for definitions in the initial lexical scope of each ES program. Thus we 
say that every property name in ES has a namespace, even if only the compatibility namespace.

<NOTE>Namespace attributes are not allowed on local definitions. By default these
names are qualified by the compatibility namespace. 

<FIXME>There is currently no way to explictly qualify a reference with ''noNS''. 
However, there is an important use case for this. Code inside of a //WithStatement// might
want to refer to a local variable in an outer scope without the possibility of being
shadowed by a property on the //with// object. It has been suggested that
the keyword ''null'' could serve this purpose. The keyword ''public'' is unsuitable since
the //with// object may contain properties in the public namespace. e.g.

{{{
    function f (o) {
        var count = 10
        with (o) {
            for (var i = null::count; i > 0; --i) {
                ...
            }
        }
    }
}}}

<FIXME>The need to distinguish local names from ''public'' names also argues that the ''public'' namespace be
different than the compatibility namespace, and that the public namespace be the default
namespace for ES3 bindings on the global object and object literals. This provides a way to avoid
shadowing by //with// bindings and still allows references to be explicitly qualified to explictly resolve
conflicts. e.g.

{{{
    namespace N
    var o = {x: 10, N::x: 20}
    print (o.x)  // prints 10

    {
        use namespace N
        print (o.x)   // ambiguous
        print (o.public::x)  // prints 10
        print (o.N::x)  // prints 20
    }

}}}

<IMPL>
<pre>
val noNS = Ast.UnforgeableNamespace
</pre>


== References ==

<p>A reference is an expression that refers to a property binding. A reference contains a name
that is computed from either an //unqualified identifier// or a namespace //qualified identifier//.
In this section we describe how the identifier part (''IDENTIFIER_EXPRESSION'') of a reference 
is resolved to a property name and base object.

<IMPL>
<pre>
datatype IDENTIFIER_EXPRESSION =
         Identifier of EXPRESSION
       | QualifiedIdentifier of EXPRESSION * EXPRESSION
</pre>

=== Unqualified Identifiers ===

<p>An unqualified identifier consists of a single expression that computes a string value.
A name value is constructed at runtime by searching for a property name that has an identifier 
that matches that string value and one of the open namespaces.

=== Qualified Identifiers ===

<p>A qualified identifier consists of an expression that computes a namespace value and an 
expression that computes a string value. A name value is constructed at runtime using the
values of these expressions.

==== Scope Chain ====

<p>A scope chain contains a list of objects that are searched when resolving an identifier. 
The exact specification of how scope chains are constructed is described in
//section ..: Execution//. For the purpose of specifying how names are resolved, it is
sufficient to know that a scope chain yields a sequence of objects to be searched.

<NOTE>A scope chain may include a class object (with class ''static'' properties), an
instance object and one or more local scope objects in addition to the global, activation 
and with objects of edition 3.

==== Open Namespaces ====

<p>The open namespaces are a list of lists of open namespace (''OPEN_NAMESPACE'') values. 
Each execution context extends this list of lists with a new list of namespace values 
representing namespaces that are opened in that execution context.

<IMPL>
{{{
type OPEN_NAMESPACES = OPEN_NAMESPACE list list

datatype OPEN_NAMESPACE =
         OpenAll of NAMESPACE
       | OpenFor of NAMESPACE * IDENTIFIER
}}}

<p>The ordering of the outer list is used to to priorize the search for
a matching name. The order of the inner lists is not signficant as all
namespaces opened in the same execution context are given the same priority. 

<IMPL>
{{{
fun extendOpenNamespaces (env: ENV, openNamespaceList: OPEN_NAMESPACE list)
    : OPEN_NAMESPACES =
    let
        val {openNamespaces, ...} = env
    in
        setOpenNamespaces (env, openNamespaceList::openNamespaces)
    end
}}}

==== Identifier Resolution ====

<p>Identifier expressions are resolved to an object and a property name using the following algorithms.

<NOTE>References where the target object is provided (''ObjectRef'') are a degenerate case of a search 
over a list of scope objects as with a ''LexicalRef''. Likewise, a qualified identifier ''QualifiedIdentifier''
is a degenerate form of unqualified identifier ''Identifier'' where the set of possible qualifiers is 
provided by the environment. The algorithms here are used to specify the meaning of both kinds 
of references.

<p>**Identifier resolution** - given an execution environment with a scope chain, a set of open 
namespaces and an identifier, find a property name that matches the identifier.

<p>Informally, identifiers are resolved to a name and an owning object by searching the list of scope 
objects for a name that matches the identifier and at least one of the open namespaces. If more than 
one name is matched, the scope of the open namespaces
is used to select the matches in the most recently opened namespaces. If more than one namespace is still 
matched and the owning object is a class instance, select further refine the set of matches by preferring
the names introduced in the least derived class. If more than one name is still matched, then report an 
error. If no names are matched, then return no value. Otherwise return the name and owning object.

<IMPL>
<INCLUDE file="mach.sml" name="fun findName">

<p>**Search object list** - given a list of objects, set of namespaces and an identifier, search for a
matching property name

<p>Informally, for each object in the object list, search for at least one matching name in the current 
scope object. If one or more matches is found, return the matches; otherwise continue 
with next scope. If all scope objects are searched, then return no value.

<IMPL>
<INCLUDE file="mach.sml" name="fun findNamesInScope">

<p>**Object search** - given an object, a set of namespaces and an identifier,
search for a matching property name.

<p>Informally, for each object in the prototype chain and for each namespace in the given namespace set,
search for a matching name in the current object. If a match is found, add that namespace to 
set of matches and continue with next namespace. If at least one match is found, return 
the matches; otherwise continue with next object in prototype chain. If all prototype objects are
searched, then return no value.

<IMPL>
<INCLUDE file="mach.sml" name="fun findNamesInObject">

<p>**Select namespaces by scope** - given a list of lists of open
namespaces (most recently opened to least recently opened) and a set of names, 
select the name(s) that is in the most recently opened namespace(s)

<p>Informally, for each set of namespaces in the list of sets of open namespaces and
for each namespace in the set of namespaces and for each name in the set of names, if the namespace and the 
name's namespace are the same, then add the namespace to the set of matching namespaces; continue with 
the next namespace, if the set of matching namespaces is not empty, return that set; otherwise
continue with next set of namespaces. If all sets of namespaces have been searched, then return an
empty list.

<IMPL>
<INCLUDE file="mach.sml" name="fun selectNamespacesByScope">

<p>**Select namespaces by class** - given an object, a set of namespaces and an identifier,
select the name that matches the most generic binding in that object. This
step is necessary to avoid object integrity issues that arise when a derived
class introduces a binding with the same identifier and a different namespace 
in the open namespaces.

<p>Informally, for each class inherited from object, ordered from most generic to most derived, and
for each namespace in the given set of namespaces, search for a matching name in the current 
class. If a match is found then add name to set of matches. Continue with next name. If
the set of maching namespaces is not empty then return that set; otherwise continue with next class.
If all classes have been searched, then return and empty list.

<IMPL>
<INCLUDE file="mach.sml" name="fun selectNamespacesByClass">

<p>**Helper functions**

<IMPL>
{{{
fun head x = hd x (* return the first element of a list *)
fun tail x = tl x (* return all but the first element of a list *)

fun matchNamespaces (ns1: NAMESPACE list, ns2: NAMESPACE list)
    : NAMESPACE list =
    (* compute the intersection of two NAMESPACE lists *)
    <LDOTS>

fun getNamespaces (bindings : (NAME * 'a) list, identifier: IDENTIFIER)
    : NAMESPACE list =
    (* get the namespaces of binding names that have a certain identifier *)
    <LDOTS>

fun getInstanceBindings (class: CLASS) 
    : (NAME * DEFINITION) list =
    (* get the instance bindings of a class *)
    <LDOTS>

fun getBindings (object: OBJECT option)
    : (NAME * DEFINITION) list =
    (* get the bindings of an object *)
    <LDOTS>

fun getPrototypeObject (object: OBJECT option)
    : OBJECT option =
    (* get the prototype (as in '[[proto]]') object of an object *)
    <LDOTS>

fun getScopeObject (scope: SCOPE option)
    : OBJECT option =
    (* get the first scope object of a scope chain *)
    <LDOTS>

fun getOuterScope (scope: SCOPE option)
    : SCOPE option =
    (* get the next outer scope (as in '[[parent]]') in a scope chain *)
    <LDOTS>

fun getScope ({scope,...}: ENV)
    : SCOPE = 
    (* get the scope chain of an execution environment *)
    scope

fun getOpenNamespaces (env: ENV, identifier: IDENTIFIER)
    : NAMESPACE list list =
    (* get the list of list of namespaces that are open for an identifier *)
    <LDOTS>
}}}
<!--
<INCLUDE file="mach.sml" name="fun matchNamespaces">
<INCLUDE file="mach.sml" name="fun getScope">
<INCLUDE file="mach.sml" name="fun inheritedClassesOf">
<INCLUDE file="mach.sml" name="fun getScopeObject">
<INCLUDE file="mach.sml" name="fun getBindings">
<INCLUDE file="mach.sml" name="fun getNamespaces">
<INCLUDE file="mach.sml" name="fun head">
<INCLUDE file="mach.sml" name="fun tail">
-->

== Phased Identifier Resolution ==

<p>To avoid the problem of dynamic properties shadowing fixed properties, it is necessary to
resolve names in such as way that gives priority to fixed properties. The relevant principle
is that if an identifier may be resolved in an earlier phase (e.g. the name of a type during
program initialization), then its meaning shall remain fixed over the life of the program.
Conceptually, this means that we need to model in the lookup mechanism the phases of execution 
that involve name resolution.

===== Implemenation Note =====

<p>While this two-phase algorithm might appear to double the amount
of work to do, in practical implementations it does the opposite,
greatly reducing the cost of identifier resolution. The reason is that
the set of fixed properties visible in many contexts can be calculated
statically during parsing and compilation, and identifier references
can be resolved to names once during this stage, and never again at
runtime.

<p>Even if identifier resolution is delayed until runtime, a successful
resolution to a fixed property can frequently be cached -- for
example in cases of unqualified lexical references, or unqualified
object references on typed objects -- because no new fixed property may be
introduced at runtime that would make a successful match
ambiguous.
