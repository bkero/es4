= Reading and Writing Properties =

<P> This chapter describes the algorithms for //property access//:
testing objects for the presence of a property, reading from and
writing to a property, and removing a property.  Property access is
always by the name of the property.  A property name is represented
either as an instance of the pre-defined class ''Name'', or as a
''string'' (which represents a name in the ''public'' namespace).

<SPECNOTE> This chapter complements the chapter on names, scopes, and
name resolution.  At this time, there is some overlap between the two
chapters.

<P> Property accesses are subject to run-time checks, and property
access fails (an exception is thrown) if a check does not pass.  The
exact exception depends on the particular check.

<NOTE> For example, a property created by ''let'' or ''const'' or a
property whose type is a non-nullable type without a default value
must be written (initialized) before it is read; properties created by
''const'' cannot be written more than once; and properties that have
type annotations can be updated with a new value only if the allocated
type of the new value is a compatible subtype of the storage type of
the property.  A **ReferenceError** is thrown in the first two
instances, and a **TypeError** is thrown in the last.

<P> A property may be virtual, that is to say, the reading and writing
of the property may be implemented by //getter// and //setter//
methods on the object, and an expression that is syntactically a
reference to the property is in fact an invocation of these methods.
Virtual dynamic properties may be implemented by //catch-all//
methods.

<FIXME> We need a definition of "method", this is the first use.

== Catch-All Methods ==

<P> This section contains a normative overview of the catch-all
facility.  A more precise, also normative, description is given in
later sections of this chapter, as part of the general description of
property access.

<SPECNOTE> Any conflicts between the two descriptions are obviously bugs.

<P> Objects may contain fixture properties in the ''meta'' namespace:
''meta::get'', ''meta::set'', ''meta::has'', and ''meta::delete''.
These properties always name methods.  Jointly they are known as
//catch-all methods//.

<NOTE> The requirement that the ''meta'' properties always name
methods must be checked by the language implementation.  The namespace
''meta'' is reserved and known to the implementation and may only be
used in specific circumstances.  See section (...).

<P> If a catch-all method is defined on the object then it is invoked
when a dynamic property is accessed: ''meta::has'' is invoked to
determine if the object has the property; ''meta::get'' is invoked to
read a property's value; ''meta::set'' is invoked to update or create
a property; and ''meta::delete'' is invoked to delete a property.  A
catch-all method is invoked even if the dynamic property that is being
accessed already exists on the object.

<P> A catch-all method operates on the receiver object of the method
call, not on the receiver's prototype objects.

<P> If a catch-all method returns normally then the value it returns
(if any) becomes the result of the operation, possibly after being
converted to a canonical type.

<P> If a catch-all method throws an exception, and the exception
thrown is an instance of the pre-defined class
''__ES4__::DefaultBehaviorClass'', then the default behavior for the catch-all
is triggered.

<P> ''DefaultBehaviorClass'' is a singleton class; its only instance
is is stored in the global constant ''__ES4__::DefaultBehavior''.

<NOTE> The mechanism is analogous to the one defined for iterators,
where an instance of the singleton ''__ES4__::iterator::StopIterationClass'' is stored in
the global property ''__ES4__::iterator::StopIteration''.

<P> The ''meta::get'' method is invoked on one argument, a property
name.  The value returned is the property value.  The default behavior
for ''meta::get'' is to retrieve the value from a dynamic property in
the object's property map.

<P> The ''meta::set'' method is invoked on two arguments, a property
name and a value.  Any value returned is ignored.  The default
behavior for ''meta::set'' is to update or attempt to create a dynamic
property in the object's property map.

<P> The ''meta::has'' method is invoked on one argument, a property
name.  Any value returned by the method is converted to ''boolean''.
The default behavior for ''meta::has'' is to search for a dynamic
property in the object's property map.

<P> The ''meta::delete'' method is invoked on one argument, a property
name.  Any value returned by the method is converted to ''boolean''.
The default behavior for ''meta::delete'' is to attempt to delete a
dynamic property from the object's property map.

== Checking for the Presence of a Property ==

<P> The HasOwnProperty protocol is invoked to check whether an object
//obj// contains a property named by //name//.

<SPECNOTE> In terms of the 3rd Edition Specification, the
HasOwnProperty protocol implements the test for whether an object "has
a property", as used in the implementations of [[Get]], [[Put]],
[[HasProperty]], and other internal subroutines.

<P> An object is said to contain a property if the property is in the
object's prototype map or if the ''meta::has'' catchall claims the
property to be present.

<SEM>
<INCLUDE file="eval.sml" name="and hasOwnProperty">

<NOTE> The ''regs'' parameter represents the virtual machine state.  The
operator ''&lt;*'' tests subtype compatibility.

== Reading a property value ==

<P> The GetProperty protocol is invoked to read the value of a
property named by //name// from an object //obj//.  The flag
//isStrict// is true if the ES4 code that caused GetProperty to be
invoked was compiled in strict mode.

<P> Specifically, there will be an AST node for the property reference
whose ''strict'' flag is set because it represents a source code
phrase that was recognized in a region of code that was covered by a
strict mode pragma.

<SPECNOTE> There may be several types of AST nodes carrying strict
flags and invoking GetProperty, depending on how the AST is eventually
structured.

<P> The GetProperty protocol queries the object for the presence of
the property using the HasOwnProperty protocol, moving up the object's
prototype chain if the object does not contain the property.  Once an
object on the prototype chain is found that contains the object, the
internal ''getPropertyHelper'' function is invoked to extract the
property value.  If no property is found, then a default value may be
returned, or, in strict mode, an exception may be thrown.

<FIXME> The GetProperty protocol below overlaps with the
''searchObject'' algorithm described in Names; the two algorithms must
be reconciled.  That will happen when the protocol here is described
in terms of SML (because then they will use the same code).

<SEM>
<PRE>
fun GetProperty(obj, name, isStrict)
  for every object in obj, obj's prototype, ...
    if HasOwnProperty(obj, name)
      return getPropertyHelper(obj, name, isStrict)
    end
  end

  if obj allows dynamic property creation
    if obj has a structural array type with a "rest" type constraint, denote it T
      if T has a default value
        return that default value
      else
        throw a ReferenceError
            "Cannot read uninitialized property with non-nullable type"
      end
    end
    return undefined
  end

  if isStrict
    throw a ReferenceError
        "Trying to read undefined property from non-dynamic object"
  end

  return undefined
end
</PRE>

<P> The internal ''getPropertyHelper'' function reads the property named by
//name// from an object //obj//, implementing strict mode checking if
//isStrict// is true.  An error is signalled in strict mode if the
object's ''meta::has'' catch-all returned true for //name// and the
property cannot be read.

<SEM>
<PRE>
fun getPropertyHelper(obj, name, isStrict)
  if (name is a property in the property map of obj, denote it obj.name && 
      the fixed attribute of obj.name is true)
    if obj.name is a method
      return a closure 
          where obj is bound as this to the method extracted from obj.name
    end
    if obj.name is a getter/setter pair, denote the getter obj.name.[[Getter]]
      return obj.name.[[Getter]]()
    end
    return the value of obj.name
  end

  if (meta::get is a property in the property map of obj, denote it obj.meta::get
      && the fixed attribute of obj.meta::get is true)
    try 
      return obj.meta::get(name)
    catch DefaultBehavior
      ; fall through to the next case
    end
  end

  if name is a property in the property map of obj
    if obj.name is a getter/setter pair, denote the getter obj.name.[[Getter]]
      return obj.name.[[Getter]]()
    end
    return obj.name
  end

  if isStrict
    throw a ReferenceError, "Property not found"
  else
    return undefined
  end
end
</PRE>

<NOTE> A bound method has identity, so if ''m'' is a method on the
class of some object ''o'' then the expression ''o.m'' always
evaluates to the same object value (in terms of ''==='').


== Writing a property value ==

<P> The SetProperty protocol is invoked to write a value //value// to
a property named by //name// on an object //obj//.  The object may or
may not have a property of that name when SetProperty is invoked, and
SetProperty may attempt to create the property.  The flag //isStrict//
is true if the ES4 code that caused SetProperty to be invoked was
compiled in strict mode.

<P> Specifically, there will be an AST node for the property update
whose ''strict'' flag is set because it represents a source code
phrase that was recognized in a region of code that was covered by a
strict mode pragma.

<FIXME> This protocol must be specified as SML code.

<SEM>
<PRE>
fun SetProperty(obj, name, value, isStrict)
  if (name is a property in the property map of obj, denote it obj.name && 
      the fixed attribute of obj.name is true)
    return setPropertyHelper(obj, name, value, isStrict)
  end

  if (meta::set is a property in the property map of obj, denote it obj.meta::set
      && the fixed attribute of meta::set is true)
    try 
      invoke obj.meta::set(name, value)
      return
    catch DefaultBehavior
      ; fall through to the next case
    end
  end

  if name is a property in the property map of obj
    return setPropertyHelper(obj, name, value, isStrict)
  end

  if the dynamic attribute on obj is true
    if isStrict && obj is a global object
      throw a ReferenceError
          "illegal to create props on global obj in strict mode"
    end

    if (obj has an array type with a "rest" type constraint, denote it T &&
        the type of value is not a compatible subtype of T)
      throw a TypeError
          "allocated type of value is not compatible with \
          \storage type of property"
    end

    place a new object into the property map of obj
      property name = name
      property value = value
      property flags = (writable=true, 
                        enumerable=true, 
                        removable=true, 
                        fixed=false)
    return
  end

  if isStrict
    throw a ReferenceError, "cannot create a property on a non-dynamic object"
  end
}
</PRE>

<FIXME> We must take into account the [[CanPut]] functionality from ES3!

<P> The internal ''setPropertyHelper'' function is invoked when
//name// is known to name a property in //obj//.

<FIXME> Here I simply assume that methods are not writeable, but this
may or may not be the right abstraction we want to use; the RI has two
cases here anyway, and that's the code that will eventually be here.

<SEM>
<PRE>
fun setPropertyHelper(obj, name, value, isStrict)
  if obj.name is a getter/setter pair, denote the setter obj.name.[[Setter]]
    return obj.name.[[Setter]](value)
  end

  if the writeable attribute of obj.name is false
    if isStrict
      throw a ReferenceError, "Attempting to update read-only value"
    end
    return
  end

  if (obj.name has a type annotation, denote it T &&
      the type of value is not a compatible subtype of T)
    throw a TypeError, "Attempting to store value of incompatible type"
  end

  store value in obj.name

  if the writeOnce attribute of obj.name is true
    set the writeOnce attribute of obj.name to false
    set the writeable attribute of obj.name to false
  end
end
</PRE>


== Deleting a property ==

<P> The DeleteProperty protocol is invoked to remove a property named
by //name// from an object //obj//.  The object may or may not have a
property of that name when DeleteProperty is invoked.  The flag
//isStrict// is true if the ES4 code that caused DeleteProperty to be
invoked was compiled in strict mode.

<P> Specifically, there will be an AST node for the property deletion
whose ''strict'' flag is set because it represents a source code
phrase that was recognized in a region of code that was covered by a
strict mode pragma.

<FIXME> This protocol must be specified as SML code.

<SEM>
<PRE>
fun DeleteProperty(obj, name, isStrict)
  if (name is a property in the property map of obj, denote it obj.name &&
      the fixed attribute of obj.name is true)
    if isStrict
      throw a ReferenceError, "can't delete fixture properties"
    end
    return false
  end

  if (meta::delete is a property in the property map of obj, 
             denote it obj.meta::delete
      && the fixed attribute of meta::delete is true)
    try 
      return obj.meta::delete(name)
    catch DefaultBehavior
      ; fall through to the next case
    end
  end
  
  if name is a property in the property map of obj, denote it obj.name
    if the removable attribute of obj.name is true
      remove obj.name from the property map of obj
      return true
    end

    if isStrict
      throw a ReferenceError, "can't delete non-removable property"
    end
  end

  return false
end
</PRE>
