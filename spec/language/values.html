= Values =

<!-- Eventually there will be a section here on object creation and class instantiation.
     Maybe even a separate chapter.  Among the things discussed there:

       - Type instantiation: when does a type have to be defined?
         There is some sort of notion of "use" of a type, but that
         has to be pinned down precisely.

       - new T is the canonical form even for record and array types T.
         Derived forms like { x: 10 } : E boil away in the parser always,
         we don't need to know what E is.  -->

<!--
<hr>
<pre>
FILE:                       spec/language/values.html
DRAFT STATUS:               DRAFT 2 - IN PROGRESS - 2008-05-02
SPEC AUTHORS:               Jeff, Graydon
REVIEWED AGAINST ES3:       NO
REVIEWED AGAINST ERRATA:    NO
REVIEWED AGAINST BASE DOC:  NO
REVIEWED AGAINST PROPOSALS: NO
REVIEWED AGAINST CODE:      NO
SCOPE:                      The structure and behavior of objects, including the
                            and conversions of primitive object values.
</pre>
<hr>
-->

<p>The evaluation of a program, described in section ..., entails
among its effects the calculation and manipulation of values.

<FIXME> Draft 1 of the specification does not include a description of
evaluation.

<p>An //ECMAScript value// is either undefined, null, or an
object. Every ECMAScript value has an associated ECMAScript type,
called the value's //allocated type//.  The allocated type is fixed
when the value is allocated in memory, and cannot change over the
lifetime of the value.

<SEM>
<INCLUDE file="mach.sml" name="datatype VALUE">

<COMP>In the 3rd edition of the language, several individual //types// were defined. The 3 types
formerly called primitive (number, string, boolean) are now represented as object values. The term
//type// has a different meaning in the 4th edition.

== Undefined == 

<p>There is exactly one undefined value, denoted by the semantic value ''Undefined'' and stored in
the global constant property **public::undefined** in ECMAScript.

<p>The allocated type of the undefined value is called the undefined type. The undefined value is
the only value with the undefined type as its allocated type. The undefined type is denoted by the
semantic value ''UndefinedType'', which is the denoted in ECMAScript type-expression contexts by the
identifier **undefined**.

<COMP>Inside of type-expression contexts, the token **undefined** is reserved and has a fixed
meaning. Outside of type-expression contexts the token is interpreted as in earlier editions.

== Null ==

<p>There is exactly one null value, denoted by the semantic value ''Null'' and by the null literal
**null** in ECMAScript.

<p>The allocated type of the null value is called the null type. The null value is the only value
with the null type as its allocated type. The null type is denoted by the semantic value
''NullType'' and denoted in ECMAScript type-expression contexts by the null literal **null**.

<NOTE>While the null and undefined values have similar meanings, they have different conventions of
use. The null value is intended to indicate a missing object value, while the undefined value is
intended to indicate a missing property on an existing object value. These indeded uses are
conventions, and are not enforced by the language semantics.

== Object ==

<p>All values except the null and undefined values are object values.

<p>An object value consists of a mutable property binding map, an immutable object identifier, an
immutable tag, and an immutable prototype value.

<SEM>
<INCLUDE file="mach.sml" name="and OBJ">

=== Property Binding Map === 

<p>A property binding map associates at most one property with any name. If an object's property
binding map associates a property ''P'' with a name ''N'', then the object is said to have a
//binding// for ''N''. Alternatively, the property ''P'' is said to be //bound to// the name ''N'',
in the object.

<p>Bindings can be added, removed, or replaced within a property binding map. The semantic type of a
property binding map is unspecified.

<p>A property binding map stores the order in which properties are added to the map. A property's
position in this order is unchanged when the property is replaced. This order is used in
enumeration.

<SEM>
<INCLUDE file="mach.sml" name="and PROPERTY_BINDINGS">

==== Properties ====

<p>A //property// consists of a type, a state, and a set of attributes. The type of a property is
also called the property's //storage type//, to differentiate it from the allocated type of any
value that the property may contain.

<COMP>In earlier editions of the language, some characteristics of an object were modeled as
//internal properties// with distinct names such as ''[[Class]]'' or ''[[Value]]''. These
characteristics of objects are described differently in the 4th edition, using a combination of
supporting semantic and ECMAScript standard library functionality.

<SEM>
<INCLUDE file="mach.sml" name="and PROPERTY">

==== Property States ====

<p>The //state// of a property encodes either a value associated with the property, or else one of a
small number of intermediate non-value conditions that a property can assume during evaluation. 

<p>When a property is created, it is //allocated// in a state that derives from its storage type.

<p>A property with storage type <b>*</b> is allocated in the value state, with the undefined value.

<p>A property with a storage type that has the null type as a subtype is allocated in the value
state, with the null value.

<p>Any other property is allocated in the uninitialized state, and must be initialized during the
initialization phase of object construction, before the object's first constructor begins evaluation.

<p>If a property is in value state, then the allocated type of the value held in the property is a
compatible subtype of the storage type of the property.

<p>Additional property states are defined for encoding non-value properties, such as types, type
variables, and virtual properties (defined by getter and setter functions).

<SEM>
<INCLUDE file="mach.sml" name="and PROPERTY_STATE">

==== Property Attributes ==== 

<p>A property can have zero or more attributes from the following set: 

<table>
<tr>
  <th>Attribute</th>
  <th>Description</th>
</tr>
<tr>
  <td>''writable''</td>
  <td>  
    An attribute that can be one of three values. When the value is ''Writable'', the property can
    be written to an arbitrary number of times. When the value is ''WriteOnce'', the property can be
    written to once, after which the attribute assumes the value ''ReadOnly''. When the value is
    ''ReadOnly'', attempts to write to the property after initialization will fail.
  </td>
</tr>
<tr>
  <td>''enumerable''</td>
  <td>
    A boolean attribute. If true, then the property is to be enumerated by **for-in** and
    **for-each-in** enumeration. Otherwise the property is ignored by such enumeration.
  </td>
</tr>
<tr>
  <td>''removable''</td>
  <td>
    A boolean attribute. If true, then the property can be removed using the **delete** operator.
    If false, the **delete** operator fails.
  </td>
</tr>
<tr>
  <td>''fixed''</td>
  <td>
    <p>A boolean attribute. If true, then the property was defined as part of the object's fixed
      structure and dominates most non-fixed properties during name resolution (with some
      exceptions). If false, then the property is a dynamic addition to the object and is consulted
      //after// fixed properties during name resolution.</p>
  </td>
</tr>
</table>

<p>The ''fixed'' attribute is mutually exclusive with the ''removable'' attribute.



<SEM>
<INCLUDE file="mach.sml" name="datatype WRITABILITY">
<INCLUDE file="mach.sml" name="type ATTRS">

=== Object Prototype === 

<p>The //prototype// of an object is a means of dynamically delegating behavior from one object to
another. In various conditions, the language defines the evaluation of an unsuccessful property
access on an object in terms of subsequent property accesses on the object's prototype.


=== Object Identifier ===

<p>The //identifier// of an object uniquely identifies the object. The semantic type of an object
identifier is unspecified, and its value cannot be directly observed by ECMAScript code. Equality of
objects is partially defined in terms of equality of the objects' identifiers, so all identifiers
must be comparable with one another for equality.

<SEM>
<INCLUDE file="mach.sml" name="and OBJ_IDENTIFIER">

=== Object Tag === 

<p>The //tag// of an object encodes both the object's ECMAScript type, and any underlying semantic
value associated with the object.

<p>The ''ObjectTag'' and ''ArrayTag'' tags are present on objects of structural types ''ObjectType''
and ''ArrayType'', respectively. 

<p>The ''PrimitiveTag'' tag is present on objects that are instances of a small number of classes,
described in the following section.

<p>The ''InstanceTag'' tag is present on any object that is an instance of a class but does //not//
have an ''ObjectTag'', ''ArrayTag'' or ''PrimitiveTag'' tag.

<p>The ''NoTag'' tag is present only on un-named objects that implement scopes.

<SEM>
<INCLUDE file="mach.sml" name="and TAG">

==== Primitive Tag ====

<p>Some objects have additional a semantic value associated with them. Such objects are called
//primitive objects// and have a //primitive tag//. The semantic value is held in the tag, and is only
directly accessible in semantic code.

<p>ECMAScript code can determine if an object is primitive through a correspondence between
primitive tags and a set of 10 specific ECMAScript class types. The correspondence is a
bijection: any instance of these types has the corresponding primitive tag, and any object with a
primitive tag is an instance of the corresponding class.

<p>The allocated type of a primitive object may be more specific than the corresponding class
type. In particular, function objects may have more specific subtypes of the class
**public::Function**. In such cases, the allocated type of the object is present in the semantic
value held by the primitive tag.

<p>The correspondence between primitive tags and classes is the following:
<ul>
<li>The primitive tag ''Boolean'' corresponds to the class **__ES4__::boolean**.
<li>The primitive tag ''Double'' corresponds to the class **__ES4__::double**.
<li>The primitive tag ''Decimal'' corresponds to the class **__ES4__::decimal**.
<li>The primitive tag ''String'' corresponds to the class **__ES4__::string**.
<li>The primitive tag ''Namespace'' corresponds to the class **__ES4__::Namespace**.
<li>The primitive tag ''Class'' corresponds to the class **__ES4__::Class**.
<li>The primitive tag ''Interface'' corresponds to the class **__ES4__::Interface**.
<li>The primitive tag ''Function'' corresponds to the class **public::Function**.
<li>The primitive tag ''Type'' corresponds to the class **__ES4__::Type**.
<li>The primitive tag ''Generator'' corresponds to the class **helper::GeneratorImpl**.
</ul>

<SEM>
<INCLUDE file="mach.sml" name="and PRIMITIVE">

== Semantic Values ==

<p>Many aspects of the language depend on the semantic values associated with primitive objects. The
following sections describe the semantic values, and highlight various details of the
correspondences that exist between particular semantic values and the ECMAScript values they are
held by.

=== Special Constructors ===

<p>While much of the behavior of primitive objects is defined //inside// the ECMAScript language (in
the section ...library), the means of //constructing// primitive objects and associating semantic
values with them is (at least partially) defined //outside// the ECMAScript language, in semantic
code.

<p>Therefore the construction of any primitive object is described by a //special constructor//
defined in semantic code, rather than a //standard constructor// that would otherwise be defined in
standard library code. The behavior of each special constructor is described in the following
sections.

=== Boolean Values ===

<p>A //boolean value// is either of two semantic values called ''true'' and ''false''. These correspond
to the boolean literal values **true** and **false**, which denote the two sole instances of the
class **__ES4__::boolean**. Such objects are called //boolean objects//.

<p>No instances of the class **__ES4__::boolean** can be constructed aside from the two values
**true** and **false**: the **__ES4__::boolean** constructor is a special constructor that always
evaluates to one of the two boolean objects.

=== Double Values ===

<FIXME>I cut this section down significantly from ES3, since the corresponding section 8.5 in the
old standard mostly consisted of a very weird sort of selective paraphrasing of bits of 754 itself:
restatements of algorithms that are perfectly well described in 754, or of facts such as the
definition of the denormalized numbers that //never even get used// in the subsequent spec. I assume
anyone reading this section and caring about 754 doubles actually has the 754 spec and can read
it. Spelling out the whole 754 spec title in this section likewise seems redundant, since that's the
point of the normative references section at the beginning of the document.

<p>A //double value// is a double precision, 64-bit format binary floating point value, as specified
in the IEEE 754 standard.

<p>A double value can be held in the primitive tag of an instance of the class
**__ES4__::double**. Such objects are called //double objects//.

<p>Two special double values are held in special double objects: one "Not-a-Number" (NaN) value,
stored in the global constant **public::NaN**, and one "infinite" value, stored in the global
constant **public::Infinity**.

<p>ECMAScript provides no way of distinguishing any of the different IEEE 754 NaN values from one
another.  All NaN values in are considered unequal to themselves, and to every other value.

<p>In this specification, the phrase "the number value of //x//" where //x// represents an exact
nonzero real mathematical quantity means a number chosen according to the IEEE 754 rounding mode
"rounds to nearest".

<p>Some ECMAScript operators deal only with integers in the range -2<sup>31</sup> through
2<sup>31</sup>-1, inclusive, or in the range 0 through 2<sup>32</sup>-1 inclusive. These operators
accept any double value but first convert each such value to one of 2<sup>32</sup> integer
values. See descriptions of the ''ToInt32'' and ''ToUint32'' operators in sections ...</p>

=== Decimal Values ===

<p>A //decimal value// is a 128-bit format decimal floating point value, as specified in the draft
IEEE 754r standard.

<p>A decimal value can be held in the primitive tag of an instance of the class
**__ES4__::decimal**. Such objects are called //decimal objects//.

<p>Some ECMAScript operators convert double values to decimal values when either operand to the
operator is a decimal value. This conversion can be lossy.

<FIXME>Fill in more? How detailed should this section get?

=== String Values ===

<p>A //string value// is a finite ordered sequence of zero or more 32 bit unsigned integer values
("elements"). String values are generally used to represent textual data, in which case each element
in the string is treated as a code point value (see section ...).

<p>A string value can be held in the primitive tag of an instance of the class
  **__ES4__::string**. Such objects are called //string objects//.

<p>Each element of a string is regarded as occupying a position within the sequence. These positions
are indexed with nonnegative integers. The first element (if any) is at position 0, the next element
(if any) is at position 1, and so on. The length of a string is the number of elements (32-bit
values) within it. The empty string has length zero and therefore contains no elements.

<p>All operations on string (except as otherwise stated) treat them as sequences of undifferentiated
32-bit unsigned integers. In particular, operations on strings do not ensure the resulting string is
in normalised form, they do not ensure language-sensitive results, and they do not alter their
behavior when dealing with 32-bit values outside the legal range of UTF-32 code points.

<NOTE>The rationale behind these decisions was to keep the implementation of strings as simple and
high-performing as possible. The intent is that textual data coming into the execution environment
from outside (e.g., user input, text read from a file or received over the network, etc.) be
converted to Unicode Normalised Form C before the running program sees it. Usually this would occur
at the same time incoming text is converted from its original character encoding to Unicode (and would
impose no additional overhead). Since it is recommended that ECMAScript source code be in Normalised
Form C, string literals are guaranteed to be normalised (if source text is guaranteed to be normalised), 
as long as they do not contain any Unicode escape sequences.

<FIXME>The previous paragraphs regarding string values are adapted from ES3, but personally I think
they are very awkward-reading, and would like to rewrite them a bit.

<FIXME>Minor spelling nit: normalised or normalized? We use "initialize" earlier in the spec, but we
should decide on UK english or US english. Being a schizoid Canadian I have no hope of choosing.

<p>String literals evaluate to string objects. 

<p>The equality of string objects -- in both the **==** and **===** sense -- is defined as the
equality of the underlying string values. This in turn is established by the identities of the
string elements, considered pairwise and in sequence. Inequalities and relational operations of
strings are similarly defined in terms of sequence comparisons on string elements. No other forms of
textual equality or collation are defined.

=== Namespace Values ===

<p>Namespaces are defined and discussed in section ...names. Their notable features are recounted
here.

<p>A //namespace value// is either transparent or opaque. A transparent namespace has an associated
identifying string value. An opaque namespace has an associated unique identifier of unspecified
representation.

<p>A namespace value can be held in the primitive tag of an instance of the class
**__ES4__::Namespace**. Such objects are called //namespace objects//.

<p>A namespace value and can be defined as a fixture in a global or class static scope using a
**namespace** definition.

<p>Any two transparent namespaces with equal identifying strings are considered equal. Any two
opaque namespaces with equal unique identifiers are equal. 

<SEM>
<INCLUDE file="ast.sml" name="type OPAQUE_NAMESPACE_IDENTIFIER">
<INCLUDE file="ast.sml" name="datatype NAMESPACE">

=== Class Values ===

<p>A //class value// consists of a name and a set of namespaces, fixtures and types.

<p>A class value can be held in the primitive tag of an instance of the class
**__ES4__::Class**. Such objects are called //class objects//.

<p>A class value and can be defined as a fixture in the global scope using a **class** definition.

<p>Each //class definition// corresponds to zero or more class values, and thus zero or
more class objects. If a class definition is not type-parametric, it corresponds to exactly one
class object, and that class object is called //the value of// the class definition.

<p>A class value holds //class fixtures// and //instance fixtures//. If **C** is a class object,
then the class fixtures of the associated class value describe fixed properties found on the
class object **C**. In this way, the class fixtures effectively describe an implicit anonymous
subtype of **__ES4__::Class** that the class object **C** is an instance of.

<FIXME>__ES4__::Class is obsolete, probably. It still exists but we have proper metaobjects for this sort of thing

<FIXME>This tying-knots stuff at the top of the type hierarchy is always a little subtle and hard to
word. Suggestions welcome.

<p>Class values can be //instantiated// to produce new objects. Instantiation is described in
section....

<SEM>
<INCLUDE file="ast.sml" name="and CLASS">

==== Instance Fixtures ====

<p>In addition to class fixtures, a class value holds //instance fixtures//. These describe the
fixed properties found on //instances of// the class.

<p>An object is an //instance// of a class value ''C'' if the object's tag is ''InstanceTag'' and
the class type in the tag is ''ClassType C''.

<p>If an object **X** is an instance of a class value ''C'', then every for every //instance
fixture// ''F'' in ''C'', a property ''P'' exists on **X** satisfying the following conditions:
<ul>
<li>''P'' is not ''removable''.
<li>''P'' is not ''enumerable''.
<li>''P'' is ''fixed''.
<li>If ''F'' is declared as **const** then the ''writable'' attribute of ''P'' is initially
''WriteOnce''. Otherwise the attribute is initially ''Writable''.
<li>The type of ''F'' is the type of ''P''.
</ul>

==== Class Types and Class-Instance Types ====

<p>A class corresponds to a pair of types: an instance class type and a static class type.

<p>The //instance class type// of a class value ''C'' is ''ClassType C'', denoted in a type
expression by the name of ''C'' itself, and is the allocated type of any instance of ''C''. The tag
of any instance of ''C'' is ''InstanceTag C''.

<p>The //static class type// of a class value ''C'' is the allocated type of the class object
//holding// ''C''. In such an object, the static class type is stored in a field within ''C'', and
is an anonymous subtype of the ''ClassType'' of **__ES4__::Class**. The tag of such an object is
''PrimitiveTag (Class C)''.

=== Interface Values ===

<p>An //interface value// consists of a name and a set of fixtures and types.

<p>An interface closure value can be held in the primitive tag of an instance of the class
**__ES4__::Interface**. Such objects are called //interface objects//.

<FIXME>__ES4__::Interface is obsolete, probably. It still exists but we have proper metaobjects for this sort of thing

<p>An interface value and can be defined as a fixture in the global scope using an **interface** definition.

<p>Each //interface definition// corresponds to zero or more interface objects. If an
interface definition is not type-parametric, it corresponds to exactly one interface object, and
that interface object is called //the value of// the interface definition.

<p>An interface value contains declarations of //instance fixtures//, but no definitions.

<p>Interfaces are //implemented// by classes, and any class implementing an interface must define,
for each instance fixture declared in the interface, an instance fixture with the same name and type
of the instance fixture.

<p>An interface value ''I'' also defines a type ''InterfaceType I''. If a class ''C'' implements
interface ''I'', the type ''ClassType C'' is a subtype of ''InterfaceType I''.

<SEM>
<INCLUDE file="ast.sml" name="and INTERFACE">

=== Function Closures ===

<p>A //function closure value// consists of a captured scope chain, an optional captured ''this''
object, and a function value.

<p>A function closure value can be held in the primitive tag of an instance of the class
**__ES4__::Function**. Such objects are called //function objects//.

<p>A function closure value can be defined as a fixture in a scope using a **function** definition.

<p>Each //function definition// corresponds to zero of more function objects. 

<P>A //function expression// may also evaluate to a function object.

<p>A function value contains set of parameter fixtures and a block of ECMAScript code. 

<p>Function closure values can be //invoked// to evaluate the ECMAScript code stored in the block of
the closure's associated function value. Invocation is described in section....

<SEM>
<INCLUDE file="mach.sml" name="withtype FUN_CLOSURE">
<INCLUDE file="ast.sml" name="and FUNC">

=== Type Values ===

<FIXME>fill in

=== Generator Values ===

<FIXME>fill in
