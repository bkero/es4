= Values =

<hr>
<pre>
FILE:                       spec/language/values.html
DRAFT STATUS:               DRAFT 2 - IN PROGRESS - 2008-05-02
SPEC AUTHORS:               Jeff, Graydon
REVIEWED AGAINST ES3:       NO
REVIEWED AGAINST ERRATA:    NO
REVIEWED AGAINST BASE DOC:  NO
REVIEWED AGAINST PROPOSALS: NO
REVIEWED AGAINST CODE:      NO
SCOPE:                      The structure and behavior of objects, including the
                            and conversions of primitive object values.
</pre>
<hr>

<p>The execution of a program, described in section ..., entails among its effects the calculation
and manipulation of values.

<p>An //ES4 value// is either undefined, null, or an object. Every ES4 value has an associated ES4
type, called the value's //allocated type//, which is fixed when the value is allocated in memory,
and cannot change over the lifetime of the value. 

<IMPL>
<INCLUDE file="mach.sml" name="datatype VALUE">

<COMP>In the 3rd edition of the language, several individual //types// were defined. The 3 types
formerly called primitive (number, string, boolean) are now represented as object values. The term
//type// has a different meaning in the 4th edition.

== Undefined == 

<p>There is exactly one undefined value, denoted by the semantic value ''Undef'' and stored in the
global constant property **public::undefined** in ES4.

<p>The allocated type of the undefined value is called the undefined type. The undefined value is
the only value with the undefined type as its allocated type. The undefined type is denoted by the
semantic value ''UndefinedType'', which is the denoted in ES4 type-expression contexts by the
identifier **undefined**.

<COMP>As with earlier editions of the language, **undefined** is not a reserved word outside of
type-expression contexts, and so might be shadowed by a user defined property with the same name.

== Null ==

<p>There is exactly one null value, denoted by the semantic value ''Null'' and by the null literal
**null** in ES4.

<p>The allocated type of the null value is called the null type. The null value is the only value
with the null type as its allocated type. The null type is denoted by the semantic value
''NullType'' and denoted in ES4 type-expression contexts by the null literal **null**.

<NOTE>While the null and undefined values have similar meanings, they have different conventions of
use. The null value is intended to indicate a missing object value, while the undefined value is
intended to indicate a missing property on an existing object value. These indeded uses are
conventions, and are not enforced by the language semantics.

== Objects ==

<p>All values except the null and undefined values are object values.

<p>An object value consists of a mutable property binding map, an immutable object identifier, an
immutable tag, and an immutable prototype value.

<IMPL>
<INCLUDE file="mach.sml" name="and OBJ">

=== Property Binding Map === 

<p>A property binding map associates at most one property with any name. If an object's property map
associates a property ''P'' with a name ''N'', then the object is said to have a //binding// for
''N''. Alternatively, the property ''P'' is said to be //bound to// the name ''N'', in the object.

<p>Bindings can be added, removed, or replaced within a property binding map. The semantic type of a
property binding map is unspecified.

<IMPL>
<INCLUDE file="mach.sml" name="and PROPERTY_BINDINGS">

==== Properties ====

<p>A //property// consists of a type, a state, and a set of attributes. The type of a property is
also called the property's //storage type//, to differentiate it from the allocated type of any
value that the property may contain.

<COMP>In earlier editions of the language, some characteristics of an object were modeled as
//internal properties// with distinct names such as ''[[Class]]'' or ''[[Value]]''. These
characteristics of objects are described differently in the 4th edition, using a combination of
supporting semantic and ES4 standard library functionality.

<IMPL>
<INCLUDE file="mach.sml" name="and PROPERTY">

==== Property States ====

<p>The //state// of a property encodes either a value associated with the property, or else one of a
small number of intermediate non-value conditions that a property can assume during execution. 

<p>When a property is created, it is //allocated// in a state that derives from its storage type.

<p>A property with storage type <b>*</b> is allocated in the value state, with the undefined value.

<p>A property with a storage type that has the null type as a subtype is allocated in the value
state, with the null value.

<p>Any other property is allocated in the uninitialized state, and must be initialized during the
initialization phase of object construction, before the object's first constructor begins execution.

<p>If a property is in value state, then the allocated type of the value held in the property is a
compatible subtype of the storage type of the property.

<p>Additional property states are defined for encoding non-value properties, such as types, type
variables, and virtual properties (defined by getter and setter functions).

<IMPL>
<INCLUDE file="mach.sml" name="and PROPERTY_STATE">

==== Property Attributes ==== 

<p>The //attributes// of a property govern the behavior of property lookup, enumeration,
modification and deletionThere are four attributes that may be set on a property.

<IMPL>
<INCLUDE file="mach.sml" name="type ATTRS">

=== Object Prototype === 

<p>The //prototype// of an object is a means of dynamically delegating behavior from one object to
another. In various conditions, the language defines the execution of an unsuccessful property
access on an object in terms of subsequent property accesses on the object's prototype.


=== Object Identifier ===

<p>The //identifier// of an object uniquely identifies the object. The semantic type of an object
identifier is unspecified, and its value cannot be directly observed by ES4 code. Equality of
objects is partially defined in terms of equality of the objects' identifiers, so all identifiers
must be comparable with one another for equality.

<IMPL>
<INCLUDE file="mach.sml" name="and OBJ_IDENTIFIER">

=== Object Tag === 

<p>The //tag// of an object encodes both the object's ES4 type, and any underlying semantic value
associated with the object.

<IMPL>
<INCLUDE file="mach.sml" name="and TAG">

<p>The ''ObjectTag'' and ''ArrayTag'' tags are present on objects of structural types ''ObjectType''
and ''ArrayType'', respectively. 

<p>The ''PrimitiveTag'' tag is present on objects that are instances of a small number of classes,
described in the following section.

<p>The ''InstanceTag'' tag is present on any object that is an instance of an ES4 class but does
//not// have an ''ObjectTag'', ''ArrayTag'' or ''PrimitiveTag''. 

<p>The ''NoTag'' tag is present only on un-named objects that implement scopes.

==== Primitive Tag ====

<p>Some objects have additional a semantic value associated with them. Such objects are called
//primitive objects// and have a //primitive tag//. The semantic value is held in the tag, and is only
directly accessible in semantic code.

<p>ES4 code can determine if an object is primitive through a correspondence between primitive tags and a
set of 10 specific ES4 instance types. The correspondence is a bijection: any instance of these
types has the corresponding primitive tag, and any object with a primitive tag is an instance of the
corresponding type.

<p>The allocated type of a primitive object may be more specific than the corresponding instance
type. In particular, function objects may have more specific subtypes of the ES4 class
**public::Function**. In such cases, the allocated type of the object is present in the semantic
value held by the primitive tag.

<p>The correspondence between primitive tags and classes is the following:
<ul>
<li>The primitive tag ''Boolean'' corresponds to the ES4 class **__ES4__::boolean**.
<li>The primitive tag ''Double'' corresponds to the ES4 class **__ES4__::double**.
<li>The primitive tag ''Decimal'' corresponds to the ES4 class **__ES4__::decimal**.
<li>The primitive tag ''String'' corresponds to the ES4 class **__ES4__::string**.
<li>The primitive tag ''Namespace'' corresponds to the ES4 class **__ES4__::Namespace**.
<li>The primitive tag ''Class'' corresponds to the ES4 class **__ES4__::Class**.
<li>The primitive tag ''Interface'' corresponds to the ES4 class **__ES4__::Interface**.
<li>The primitive tag ''Function'' corresponds to the ES4 class **public::Function**.
<li>The primitive tag ''Type'' corresponds to the ES4 class **__ES4__::Type**.
<li>The primitive tag ''Generator'' corresponds to the ES4 class **helper::GeneratorImpl**.
</ul>

<IMPL>
<INCLUDE file="mach.sml" name="and PRIMITIVE">

== Semantic Values ==

<p>Many aspects of the language depend on the semantic values associated with primitive objects. The
following sections describe the semantic values, and highlights various details of the
correspondences that exist between particular semantic values and the ES4 values they are present
on.

=== Special Constructors ===

<p>While much of the behavior of primitive objects is defined //inside// the ES4 language (in the
section ...library), the means of //constructing// primitive objects and associating semantic values
with them is (at least partially) defined //outside// the ES4 language, in semantic code. 

<p>Therefore the construction of any primitive object is described by a //special constructor// defined
in semantic code, rather than a //standard constructor// defined in ES4. The behavior of each
special constructor is described in the following sections.

=== Boolean Values ===

<p>A boolean value is either of two semantic values called ''true'' and ''false''. These correspond
to the ES4 boolean literal values **true** and **false**, which denote the two sole instances of the
ES4 class **__ES4__::boolean**.

<p>No instances of the ES4 class **__ES4__::boolean** can be constructed aside from the two values
**true** and **false**: the **__ES4__::boolean** constructor is a special constructor that always
evaluates to one of the two boolean values.

<p>A "wrapper class" called **public::Boolean** exists. Instances of **public::Boolean** contain a
single **__ES4__::boolean** primitive object, and delegate most of their functionality to this inner
"wrapped" value.

<p>The value of **public::Boolean.prototype** is identical to **__ES4__::boolean.prototype**. This
value is refered to without distinction as //the boolean prototype//, since it is shared between
both classes.

=== Double Values ===

<p>A double value can be one of exactly 18437736874454810927 (that is,
2<sup>64</sup>-2<sup>53</sup>+3) possible values, representing the double-precision 64 bit format
IEEE 754 values as specified in the IEEE Standard for Binary Floating-Point Arithmetic, except that
none of the 9007199254740990 (that is, 2<sup>53</sup>-2) distinct "Not-a-Number" (NaN) values of the
IEEE Standard can be distinguished from one another.

<p>One such NaN value is bound to the ES4 constant **public::NaN**, and every NaN value compares
unequal to every other NaN value, including itself. Double and decimal NaN values are the only
values that compare unequal to themselves under the ES4 **===** operator.

<p>All other operations on double values corresond to operations defined in IEEE 754.

<FIXME>Copy more text here and edit the text from ES3 describing Number values. Or just rewrite, as
the ES3 text focused on odd things and wasn't very plain.

=== Decimal Values ===

<p>A decimal value can be any of those described by the //decimal128// datatype of the IEEE 754r
draft standard for floating point arithmetic.

<FIXME>fill in more

=== String Values ===

<p>A string value is a finite ordered sequence of zero or more 32 bit unsigned integer values
("elements"). String values are generally used to represent textual data, in which case each element
in the string is treated as a code point value (see section ...).

<p>Each element is regarded as occupying a position within the sequence. These positions are indexed
with nonnegative integers. The first element (if any) is at position 0, the next element (if any) is
at position 1, and so on. The length of a string is the number of elements (32-bit values) within
it. The empty string has length zero and therefore contains no elements.

<p>When a string contains actual textual data, each element is considered to be a single UTF-32 code
point (or "character"). Whether or not this is the actual storage format of a string, the characters
within a string are numbered as though they were represented using UTF-32. 

<p>All operations on string (except as otherwise stated) treat them as sequences of undifferentiated
32-bit unsigned integers. In particular, operations on strings do not ensure the resulting string is
in normalised form, they do not ensure language-sensitive results, and they do not alter their
behavior when dealing with 32-bit values outside the legal range of UTF-32 code points.

<NOTE>The rationale behind these decisions was to keep the implementation of strings as simple and
high-performing as possible. The intent is that textual data coming into the execution environment
from outside (e.g., user input, text read from a file or received over the network, etc.) be
converted to Unicode Normalised Form C before the running program sees it. Usually this would occur
at the same time incoming text is converted from its original character encoding to Unicode (and would
impose no additional overhead). Since it is recommended that ECMAScript source code be in Normalised
Form C, string literals are guaranteed to be normalisec (if source text is guaranteed to be normalised), 
as long as they do not contain any Unicode escape sequences.

<FIXME>The previous paragraphs regarding string values are adapted from ES3, but personally I think
they are very awkward-reading, and would like to rewrite them a bit.

<p>String values are instances of the ES4 class **__ES4__::string**.

<p>String literals in ES4 programs evaluate to instances of **__ES4__::string**. 

<p>The equality of **__ES4__::string** objects -- in both the **==** and **===** sense -- is defined
as the equality of the underlying string values. This in turn is established by the identities of
the string elements, considered pairwise and in sequence. Inequalities and relational operations of
strings are similarly defined in terms of sequence comparisons on string elements. No other forms of
textual equality or collation are defined.

<p>A "wrapper class" called **public::String** exists. Instances of **public::String** contain a
single **__ES4__::string** primitive object, and delegate most of their functionality to this inner
"wrapped" value.

<p>The value of **public::String.prototype** is identical to **__ES4__::string.prototype**. This
value is refered to without distinction as //the string prototype//, since it is shared between
both classes.

=== Namespace Values ===

<p>Namespaces are defined and discussed in section ...names. Their notable features are recounted
here.

<p>A namespace value is either transparent or opaque. A transparent namespace has an associated
identifying string value. An opaque namespace has an associated unique identifier of unspecified
representation.

<IMPL>
<INCLUDE file="ast.sml" name="datatype NAMESPACE">
<INCLUDE file="ast.sml" name="type OPAQUE_NAMESPACE_IDENTIFIER">

<p>A namespace value is an instance of the ES4 class **__ES4__::Namespace**, and can be defined as
a fixture in a scope using a **namespace** definition.

<p>Any two transparent namespaces with equal identifying strings are considered equal. Any two
opaque namespaces with equal unique identifiers are equal. 

<p>Each fixture for an opaque namespace is assigned a new unique namespace identifier by the
execution context, and the same namespace identifier is never assigned to more than one opaque
namespace fixture in a single execution context.

=== Class Values ===

<p>A class value is an object holding the semantic description of a class definition. Each class
definition corresponds to zero or more class values. If a class definition is not type-parametric,
it corresponds to exactly one class value, and that class value is called //the value of// the
class.

<IMPL>
<INCLUDE file="ast.sml" name="and CLS">

<p>The semantic definition of a class **C** lists //class fixtures// and //instance fixtures//. The
class fixtures of the semantic definition of **C** describe the fixtures found on the class object
**C**. In this way, the class fixtures effectively describe an implicit anonymous //meta-class//
that the class object **C** is an instance of.

<FIXME>This tying-knots stuff at the top of the type hierarchy is always a little subtle and hard to
word. Suggestions welcome.

==== Instance Fixtures ====

<p>In addition to class fixtures, the semantic value of a class definition holds a description of
//instance fixtures//. These describe the fixed structure of //instances// of the class.

<p>An object is an //instance// of a class value **C** if the object's tag is ''InstanceTag'' and the
instance type in the tag is the ''InstanceType'' found in the semantic class definition held in **C**.

<p>If an object **X** is an instance of a class value **C**, then every for every //instance
fixture// **F** in the semantic class value held in **C**, a property **P** exists on **X**
satisfying the following conditions:
<ul>
<li>**P** is not ''Removable''.
<li>**P** is not ''Enumerable''.
<li>**P** is ''Fixed''.
<li>If **F** is declared as **const** then **P** is not ''Writable''. Otherwise **P** is ''Writable''.
<li>The type of **F** is the type of **P**.
</ul>

<p>In this way the instance fixtures in the semantic class value associated with the class
object **C** describe the fixed properties that exist in every instance of **C**.

=== Interface Values ===

<FIXME>fill in

=== Function Values ===

<FIXME>fill in

=== Type Values ===

<FIXME>fill in

=== Generator Values ===

<FIXME>fill in
