= Values =

<!-- Eventually there will be a section here on object creation and class instantiation.
     Maybe even a separate chapter.  Among the things discussed there:

       - Type instantiation: when does a type have to be defined?
         There is some sort of notion of "use" of a type, but that
         has to be pinned down precisely.

       - new T is the canonical form even for record and array types T.
         Derived forms like { x: 10 } : E boil away in the parser always,
         we don't need to know what E is.  -->

<!--
<hr>
<pre>
FILE:                       spec/language/values.html
DRAFT STATUS:               DRAFT 3 - IN PROGRESS - 2008-06-20
SPEC AUTHORS:               Jeff, Graydon
REVIEWED AGAINST ES3:       NO
REVIEWED AGAINST ERRATA:    NO
REVIEWED AGAINST BASE DOC:  NO
REVIEWED AGAINST PROPOSALS: NO
REVIEWED AGAINST CODE:      YES - code fragments are live
SCOPE:                      The structure and behavior of objects, including the
                            and conversions of primitive object values.
</pre>
<hr>
-->

<p>The evaluation of a program, described in section ..., entails among its effects the calculation
and manipulation of values.

<FIXME> Draft 1 of the specification does not include a description of evaluation.

<p>An //ECMAScript value// is either undefined, null, or an object. Every ECMAScript value has an
associated ECMAScript type, called the value's //allocated type//.  The allocated type is fixed when
the value is allocated in memory, and cannot change over the lifetime of the value.

<SEM>
<INCLUDE file="mach.sml" name="datatype VALUE">

<COMP>In the 3rd edition of the language, several individual //types// were defined. The three types
formerly called primitive (number, string, boolean) are now represented as object values. The term
//type// has a different meaning in the 4th edition.

== Object Values ==

<p>An //object value// is any ECMAScript value that is not the null value or the undefined value.

<p>An object value consists of a mutable property binding map, an immutable fixture map, an
immutable object identifier, an immutable tag, and an immutable prototype reference.

<SEM>
<INCLUDE file="mach.sml" name="and OBJECT">

=== Property Map === 

<p>A //property map// associates at most one property with any name. If an object's property map
associates a property ''P'' with a name ''N'', then the object is said to have a //binding// for
''N''. Alternatively, the property ''P'' is said to be //bound to// the name ''N'', in the object.

<p>Bindings can be added, removed, or replaced within a property map. The semantic type of a
property map is unspecified.

<p>A property map stores the order in which properties are added to the map. A property's position
in this order is unchanged when the property is replaced. This order is used by property enumeration
(see the chapter on Statements).

<FIXME> "Replacement" is not an adequate abstraction here; we wish to have an "update" operation.
Replacement on the language level occurs when a property is deleted by the delete operator (or 
an equivalent mechanism) and a new property with the same name is inserted; under this kind of
replacement, the property's position may change.  With a "replacement" on the semantic level,
that is to say an update, the property's position never changes.

<SEM>
<INCLUDE file="mach.sml" name="and PROPERTY_MAP">

==== Properties ====

<p>A //property// consists of a type, a state, and a set of attributes. The type of a property is
also called the property's //storage type//, to differentiate it from the allocated type of any
value that the property may contain.

<COMP>In earlier editions of the language, some characteristics of an object were modeled as
//internal properties// with distinct names such as ''[[Class]]'' or ''[[Value]]''. These
characteristics of objects are described differently in the 4th edition, using a combination of
supporting semantic and ECMAScript standard library functionality.

<SEM>
<INCLUDE file="mach.sml" name="and PROPERTY">

<FIXME> The term //storage type// is not ideal because it also applies
to the return value constraint on a function object; there is no
"storage" in that context.  It's possible that //annotated type//
would be a better term.

==== Property States ====

<p>The //state// of a property encodes either a value associated with the property, or else a pair
of functions that describe a "virtual" value.

<p>If a property is in the //value// state, reading the property returns the value and writing the
property updates the value.

<p>If a property is in the //virtual value// state, reading the property executes the associated
"getter" function, and writing the property executes the associated "setter" function.

<SEM>
<INCLUDE file="mach.sml" name="and PROPERTY_STATE">

<FIXME> It is probably not necessary for the getter and setter to be "option", the 
missing part of the pair is always generated by the language implementation.

==== Property Attributes ==== 

<p>A property can have zero or more attributes from the following set: 

<table>
<tr>
  <th>Attribute</th>
  <th>Description</th>
</tr>
<tr>
  <td>''writable''</td>
  <td>  
    An attribute that can be one of three values. When the value is ''Writable'', the property can
    be written to an arbitrary number of times. When the value is ''WriteOnce'', the property can be
    written to once, after which the attribute assumes the value ''ReadOnly''. When the value is
    ''ReadOnly'', attempts to write to the property after initialization will fail.
  </td>
</tr>
<tr>
  <td>''enumerable''</td>
  <td>
    A boolean attribute. If true, then the property is to be enumerated by **for-in** and
    **for-each-in** enumeration. Otherwise the property is ignored by such enumeration.
  </td>
</tr>
<tr>
  <td>''removable''</td>
  <td>
    A boolean attribute. If true, then the property can be removed using the **delete** operator.
    If false, the **delete** operator fails.
  </td>
</tr>
<tr>
  <td>''fixed''</td>
  <td>
    <p>A boolean attribute. If true, then the property was defined as a fixture in the object's
      fixture map and dominates most non-fixed properties during name resolution. If false, then the
      property is a dynamic addition to the object and is usually consulted //after// fixed
      properties during name resolution.</p>
  </td>
</tr>
</table>

<p> The ''fixed'' attribute is mutually exclusive with the ''removable'' attribute.

<P> If a property is not ''Writable'' it is also not ''removable''.

<P> If a property is ''fixed'' it is not ''enumerable''.


<SEM>
<INCLUDE file="mach.sml" name="datatype WRITABILITY">
<INCLUDE file="mach.sml" name="type ATTRS">

==== Names ====

<p>A //name// consists of a namespace and an identifier. 

<p>A name may identify a property binding within a property map.

<SEM>
<INCLUDE file="ast.sml" name="type NAME">

===== Identifiers =====

<p>An //identifier// is a string.

<SEM>
<INCLUDE file="ast.sml" name="type IDENTIFIER">

===== Namespaces =====

<p>A //namespace// is a semantic value that can be either transparent or opaque.

<p>A //transparent namespace// consists of a character string that identifies the namespace.

<p>An //opaque namespace// consists of a unique namespace identifier of unspecified representation.

<SEM>
<INCLUDE file="ast.sml" name="datatype NAMESPACE">
<INCLUDE file="ast.sml" name="type OPAQUE_NAMESPACE_IDENTIFIER">

====== Standard namespaces ======

<P>Two important namespaces are used throughout the following sections.

<P>The //public namespace// is the transparent namespace whose identifying string is the empty
string, **""**.

<P>The //4th Edition namespace// is the transparent namespace whose identifying string is the string
**__ES4__**.

<p>The 4th Edition namespace is bound to the global property name **""::__ES4__** (that is, the name
formed by qualifying the identifier **__ES4__** with the public namespace) and can therefore be seen
by code loaded in either 3rd Edition or 4th Edition mode.

<P>The public namespace is bound to the global property name **__ES4__::public** (that is, the name
formed by qualifying the identifier **public** with the 4th Edition namespace). 

<P>When a program is loaded in 3rd Edition mode, the initial definition environment has the public
namespace open. When a program is loaded in 4th Edition mode, the initial definition enviornment has
both the public namespace and the 4th Edition namespace open.

<P>All property names defined subsequently in this specification are written in one of two forms:
<ul>
<li>Qualified, using the ECMAScript name-expression notation **namespace::identifier**
<li>Unqualified, using the notation of a bare **identifier**, implicitly qualified by the 4th Edition namespace
</ul>

<NOTE> The **public** namespace is distinguished in several ways. The names of properties added
dynamically to objects are qualified by **public** by default, so all properties created by 3rd
Edition code running on a 4th Edition implementation are **public**, and **public** is sometimes
called "the compatibility namespace" for that reason. The default namespace qualifier that is
applied to declarations in every scope is **public**, so absent other qualification every property
on every object and every lexically bound name is in the **public** namespace.

=== Object Prototype === 

<p>The //prototype// of an object is a means of dynamically delegating behavior from one object to
another. In various conditions, the result of an unsuccessful property access on an object is
defined in terms of subsequent property accesses on the object's prototype.

<P>The value of the prototype can be the null value or an object value.

=== Object Identifier ===

<p>The //identifier// of an object uniquely identifies the object. The semantic type of an object
identifier is unspecified, and its value cannot be directly observed by ECMAScript code. Equality of
objects is partially defined in terms of equality of the objects' identifiers, so all identifiers
must be comparable with one another for equality.

<SEM>
<INCLUDE file="mach.sml" name="and OBJECT_IDENTIFIER">

=== Object Tag === 

<p>The //tag// of an object encodes both the object's allocated type, and any underlying semantic
value associated with the object.

<p>The ''ObjectTag'' tag is present on an object of with the structural type ''ObjectType'' as its allocated type. 

<p>The ''ArrayTag'' tag is present on an object of with the structural type ''ArrayType'' as its allocated type. 

<p>The ''PrimitiveTag'' tag is present on objects that are instances of a small number of classes,
described in the following section.

<p>The ''InstanceTag'' tag is present on any object that is an instance of a class but does //not//
have an ''ObjectTag'', ''ArrayTag'' or ''PrimitiveTag'' tag.

<p>The ''NoTag'' tag is present only on un-named objects that implement scopes.

<SEM>
<INCLUDE file="mach.sml" name="and TAG">

==== Primitive Tag ====

<p>In addition to an allocated type, some objects have an extra semantic value stored in their
tag. Such objects are called //primitive objects// and have a //primitive tag// containing the
semantic value. The extra semantic value is only directly accessible in semantic code.

<p>ECMAScript code can determine if an object is primitive through a correspondence between
primitive tags and a set of 9 specific ECMAScript types. The correspondence is a bijection: any
instance of these types has the corresponding primitive tag, and any object with a primitive tag is
an value of the corresponding type.

<p>The allocated type of a primitive object may be a subtype of the corresponding type listed
here. In particular, function objects may have more specific subtypes of the class
**public::Function**, and class and interface objects are both subtypes of the interface
**helper::Type**. In such cases, the allocated type of the object is described by the semantic value
held by the primitive tag.

<p>The correspondence between primitive tags and object types is the following:
<ul>
<li>The primitive tag ''BooleanPrimitive'' corresponds to the class **boolean**.
<li>The primitive tag ''DoublePrimitive'' corresponds to the class **double**.
<li>The primitive tag ''DecimalPrimitive'' corresponds to the class **decimal**.
<li>The primitive tag ''StringPrimitive'' corresponds to the class **string**.
<li>The primitive tag ''NamespacePrimitive'' corresponds to the class **Namespace**.
<li>The primitive tag ''FunctionPrimitive'' corresponds to the class **public::Function**.
<li>The primitive tag ''TypePrimitive'' corresponds to the class **helper::Type**.
<li>The primitive tag ''GeneratorPrimitive'' corresponds to the class **helper::GeneratorImpl**.
<li>The primitive tag ''ArgumentsPrimitive'' corresponds to the class **helper::Arguments**.
</ul>

<SEM>
<INCLUDE file="mach.sml" name="and PRIMITIVE">

=== Fixture Map ===

<p>A //fixture map// is a structure that describes, but does not contain, a set of fixed property
bindings. These descriptions of fixed properties are called //fixtures//. The properties described
by an object's fixture map are //lazily instantiated// as fixed property bindings on the object. Any
attempt to access a property binding described by a fixture in an object's fixture map, but not
present in the object's property map, causes the property to be added to the property map.

<p>All instances of a class share a single fixture map.


== Undefined Value == 

<p>The //undefined value// is a unique constant denoted by the semantic value ''UndefinedValue'' and
stored in the global constant property **public::undefined** in ECMAScript.

<NOTE> The namespace **public** is predefined and is used for all global names that were also
defined by the 3rd Edition Specification.

<p>The //undefined type// is the allocated type of the undefined value. The undefined value is the
only value with the undefined type as its allocated type. The undefined type is denoted by the
semantic value ''UndefinedType'', which is denoted in ECMAScript type-expression contexts by the
identifier **undefined**.

<COMP>Inside of type-expression contexts, the token **undefined** is reserved and has a fixed
meaning. Outside of type-expression contexts the token is interpreted as in earlier editions.


== Null Value ==

<p>The //null value// is a unique constant denoted by the semantic value ''NullValue'' and by the
null literal **null** in ECMAScript.

<p>The //null type// is the allocated type of the null value. The null value is the only value with
the null type as its allocated type. The null type is denoted by the semantic value ''NullType'' and
denoted in ECMAScript type-expression contexts by the null literal **null**.

<NOTE>While the null and undefined values have similar meanings, they have different conventions of
use. The null value is intended to indicate a missing object value, while the undefined value is
intended to indicate a missing property on an existing object value or an uninitialized property or
variable. These intended uses are conventions, and are not enforced by the language semantics.


== Semantic Values ==

<p>Many aspects of the language depend on the semantic values associated with primitive objects. The
following sections describe the semantic values and the correspondences that exist between
particular semantic values and the ECMAScript values they are held by.

=== Special Constructors ===

<p>While much of the behavior of primitive objects is defined //inside// the ECMAScript language (in
the section ...library), the means of //constructing// primitive objects and associating semantic
values with them is (at least partially) defined //outside// the ECMAScript language, in semantic
code and specification prose.

<p>Therefore the construction of any primitive object is described by a //special constructor//
defined in semantic code and specification prose, rather than a //standard constructor// that would
otherwise be defined in standard library code. The specifications of any such special constructors are
given in the following sections, accompanying the specifications of the semantic values.

=== Boolean Values ===

<p>A //boolean value// is one of two semantic values called ''true'' and ''false''. These correspond
to the ES4 boolean literal values **true** and **false**, which denote the two sole instances of the
class **boolean**. Such objects are called //boolean objects//.

<NOTE> The namespace **__ES4__** is predefined.  It is used to tag
global names that have been introduced in the 4th&nbsp;Edition.

<p>No instances of the class **boolean** can be constructed aside from the two values
**true** and **false**: the **boolean** constructor is a special constructor that always
evaluates to one of the two boolean objects.

=== Double Values ===

<FIXME>I cut this section down significantly from ES3, since the corresponding section 8.5 in the
old standard mostly consisted of a very weird sort of selective paraphrasing of bits of 754 itself:
restatements of algorithms that are perfectly well described in 754, or of facts such as the
definition of the denormalized numbers that //never even get used// in the subsequent spec. I assume
anyone reading this section and caring about 754 doubles actually has the 754 spec and can read
it. Spelling out the whole 754 spec title in this section likewise seems redundant, since that's the
point of the normative references section at the beginning of the document.

<FIXME>Waldemar objects to that paring down, pointing out that the purpose of the selective
paraphrasing was to include a specific subset of IEEE 754 arithmetic into ES3.  For example, signalling
NaNs are not part of that subset, and there are (supposedly) competing round-to-nearest algorithms,
of which one needed to be selected.  So it's possible that the real fix here is to be explicit
as to why a subset of IEEE 754 arithmetic is described in the ECMAScript Specification.

<p>A //double value// is a double precision, 64-bit format binary floating point value, as specified
in the IEEE 754 standard.

<p>A double value can be held in the primitive tag of an instance of the class
**double**. Instances of **double** are called //double objects//.

<p>Two special double values are held in special double objects: one "Not-a-Number" (NaN) value,
stored in the global constant **public::NaN**, and one "infinite" value, stored in the global
constant **public::Infinity**.

<FIXME> There are also NaN and Infinity properties (as well as others) on the ''Number'' object; those
are all double values.  ES4 will have NaN and Infinity properties on the ''decimal'' object, 
and probably on the ''double'' object for the sake of consistency.

<p>ECMAScript provides no way of distinguishing any of the different IEEE 754 NaN values from one
another.  All NaN values are considered unequal to themselves, and to every other value.

<p>In this specification, the phrase "the number value of //x//" where //x// represents an exact
nonzero real mathematical quantity means a number chosen according to the IEEE 754 rounding mode
"rounds to nearest".

<FIXME> That does not take into account decimal.

<p>Some ECMAScript operators deal only with integers in the range -2<sup>31</sup> through
2<sup>31</sup>-1, inclusive, or in the range 0 through 2<sup>32</sup>-1 inclusive. These operators
accept any double or decimal value but first convert each such value to one of 2<sup>32</sup> integer
values. See descriptions of the ''ToInt32'' and ''ToUint32'' operators in sections ...</p>

=== Decimal Values ===

<p>A //decimal value// is a 128-bit format decimal floating point value, as specified in the draft
IEEE 754r standard.

<p>A decimal value can be held in the primitive tag of an instance of the class
**decimal**. Such objects are called //decimal objects//.

<p>Some ECMAScript operators convert double values to decimal values when either operand to the
operator is a decimal value. This conversion can be lossy.

<FIXME> More information will appear here.

=== String Values ===

<p>A //string value// is a finite ordered sequence of zero or more 32 bit unsigned integer values
("elements"). String values are generally used to represent textual data, in which case each element
in the string is treated as a code point value (see section ...).

<COMPNOTE> ES3 required code points to be 16 bit unsigned integer
values; ES4 will likely allow code points to be either 16 bits or 32
bits.

<FIXME> This section must accomodate implementations that wish to
stick with 16-bit code points, as ES3 requires.

<p>A string value can be held in the primitive tag of an instance of the class
  **string**. Such objects are called //string objects//.

<p>Each element of a string is regarded as occupying a position within the sequence. These positions
are indexed with nonnegative integers. The first element (if any) is at position 0, the next element
(if any) is at position 1, and so on. The length of a string is the number of elements (32-bit
values) within it. The empty string has length zero and therefore contains no elements.

<p>All operations on string (except as otherwise stated) treat them as sequences of undifferentiated
32-bit unsigned integers. In particular, operations on strings do not ensure the resulting string is
in normalised form, they do not ensure language-sensitive results, and they do not alter their
behavior when dealing with 32-bit values outside the legal range of UTF-32 code points.

<NOTE>The rationale behind these decisions was to keep the implementation of strings as simple and
high-performing as possible. The intent is that textual data coming into the execution environment
from outside (e.g., user input, text read from a file or received over the network, etc.) be
converted to Unicode Normalised Form C before the running program sees it. Usually this would occur
at the same time incoming text is converted from its original character encoding to Unicode (and would
impose no additional overhead). Since it is recommended that ECMAScript source code be in Normalised
Form C, string literals are guaranteed to be normalised (if source text is guaranteed to be normalised), 
as long as they do not contain any Unicode escape sequences.

<FIXME>The previous paragraphs regarding string values are adapted from ES3, but personally I think
they are very awkward-reading, and would like to rewrite them a bit.

<p>String literals evaluate to string objects. 

<p>The equality of string objects -- in both the **==** and **===** sense -- is defined as the
equality of the underlying string values. This in turn is established by the identities of the
string elements, considered pairwise and in sequence. Inequalities and relational operations of
strings are similarly defined in terms of sequence comparisons on string elements. No other forms of
textual equality or collation are defined.

=== Namespace Values ===

<p>Namespaces are defined in section ...namespaces.

<p>A namespace can be held in the primitive tag of an instance of the class
**Namespace**. Such objects are called //namespace objects//.

<p>A namespace can be defined as a fixture in a global or class static scope using a **namespace**
definition.

=== Type Values ===

<p>A //type value// is a description of a set of values. Types are described in chapter ...types. 

<p>A type value can be held in the tag of an object, in a primitive tag ''TypePrimitive''. An object
of such a primitive type tag is called a //type object//.

<p>Two sorts of type values are of particular significance: class values and interface values.

==== Class Values ====

<p>A //class value// consists of a name and a set of namespaces, fixtures and types.

<p>A class value can be held in a ''ClassType'' value, which can be held in the tag of a type
object. An object carrying a primitive type tag of class type is called a //class object//.

<p>A class value can be defined as a fixture in the global scope using a **class** definition.

<p>Each //class definition// corresponds to zero or more class values, and thus zero or more class
objects. If a class definition is not type-parametric, it corresponds to exactly one class object,
and that class object is called //the value of// the class definition.

<p>A class value holds //class fixtures// and //instance fixtures//. If **C** is a class object,
then the class fixtures of the associated class value describe fixed properties found on the class
object **C**.

<p>Every class object corresponding to a class definition contains a fixture for each static fixture
in the class definition. If a class definition is type-parametric, each unique set of type-arguments
applied to the class creates a unique class object, each with its own unique copy of the static
fixtures of the class definition.

<p>Class values can be //instantiated// to produce new objects. Instantiation is described in
section....

<SEM>
<INCLUDE file="ast.sml" name="and CLASS">

==== Instance Fixtures ====

<p>In addition to class fixtures, a class value holds //instance fixtures//. These describe the
fixed properties found on //instances of// the class.

<p>An object is an //instance// of a class value ''C'' if the object's tag is ''InstanceTag'' and
the class type in the tag is ''ClassType C''.

<p>If an object **X** is an instance of a class value ''C'', then for every //instance fixture//
''F'' in ''C'', a property ''P'' is defined on **X** satisfying the following conditions:
<ul>
<li>''P'' is not ''removable''.
<li>''P'' is not ''enumerable''.
<li>''P'' is ''fixed''.
<li>If ''F'' is declared as **const** then the ''writable'' attribute of ''P'' is initially
''WriteOnce''. Otherwise the attribute is initially ''Writable''.
<li>The type of ''F'' is the type of ''P''.
</ul>

==== Instance Types and Class Types ====

<p>A class corresponds to a pair of types: an instance class type and a static class type.

<p>The //instance class type// of a class value ''C'' is ''ClassType C'', denoted in a type
expression by the name of ''C'' itself, and is the allocated type of any instance of ''C''. The tag
of any instance of ''C'' is ''InstanceTag C''.

<p>The //static class type// of a class value ''C'' is the allocated type of the class object
//holding// ''C''. The tag of such an object is ''PrimitiveTag (TypePrimitive (ClassType C))''. The
static type of such an object is ''ClassType C'', which is defined as a subtype of the
''InstanceType'' **helper::ClassTypeImpl**. The class fixtures in the class ''C'' are defined as
instance fixtures on the class object holding ''C''.

==== Interface Values ====

<p>An //interface value// consists of a name and a set of fixtures and types.

<p>An interface value can be held in an ''InterfaceType'' value, which can be held in the tag of a
type object. An object carrying a primitive type tag of interface type is called an //interface
object//.

<p>An interface value can be defined as a fixture in the global scope using an **interface**
definition.

<p>Each //interface definition// corresponds to zero or more interface objects. If an interface
definition is not type-parametric, it corresponds to exactly one interface object, and that
interface object is called //the value of// the interface definition.

<p>An interface value contains declarations of //instance fixtures//, but no definitions.

<p>Interfaces are //implemented// by classes, and any class implementing an interface must define,
for each instance fixture declared in the interface, an instance fixture with the same name and type
of the instance fixture.

<p>An interface value ''I'' also defines a type ''InterfaceType I''. If a class ''C'' implements
interface ''I'', the type ''ClassType C'' is a subtype of ''InterfaceType I''.

<SEM>
<INCLUDE file="ast.sml" name="and INTERFACE">

=== Closures ===

<p>A //closure value// consists of a captured scope chain, an optional captured ''this'' object, and
a function value.

<p>A closure value can be held in the primitive tag of an instance of the class
**public::Function**. Such objects are called //function objects//.

<p>A closure value can be defined as a fixture in a scope using a **function** definition.

<p>Each //function definition// corresponds to zero of more function objects. 

<P>A //function expression// may also evaluate to a function object.

<p>A function value contains a set of parameter fixtures and a block of ECMAScript code. 

<p>Closure values can be //invoked// to evaluate the ECMAScript code stored in the block of the
closure's associated function value. Invocation is described in section....

<FIXME> Function definitions can be type-parametric; needs to be described.

<SEM>
<INCLUDE file="mach.sml" name="withtype CLOSURE">
<INCLUDE file="ast.sml" name="and FUNC">

=== Generator Values ===

<FIXME>fill in
