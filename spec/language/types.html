= Types =

<hr>
<pre>
FILE:                       spec/language/names.html
DRAFT STATUS:               DRAFT 1 - ROUGH - 2008-03-17
SPEC AUTHORS:               Cormac, Jeff
REVIEWED AGAINST ES3:       NO
REVIEWED AGAINST ERRATA:    NO
REVIEWED AGAINST BASE DOC:  NO
REVIEWED AGAINST PROPOSALS: NO
REVIEWED AGAINST CODE:      NO
SCOPE:                      The dynamic type system
</pre>
<hr>

<p>ECMAScript includes a gradual type system that supports a range of typing disciplines, including
dynamically-typed code (as in ES3), statically-typed code (much like in Java or C#), and various
combinations of statically- and dynamically-typed code, with convenient interoperation between the two.

<p>Type annotations are supported, but not required. A variable with no type annotation implicitly is
assigned the type "*", meaning that it can hold any value (much like variables in ES3).

<p>ES4 provides two language modes. In //standard mode//, all type annotations are enforced via 
dynamic checks (unless static analysis can prove such checks to never fail). In strict mode, a
program is first checked by a static type checker or verifier before being executed; any program that
is ill-typed will be rejected by the verifier. If the program is not rejected, then it is executed
as in "standard" mode. That is, there is no difference in run-time behavior between "strict" and
"standard" modes.

<p>Every value has an //allocated type//. The allocated type is the 
type given to a value when it is created and which defines its fixed 
structure.

<p>Every property has a //storage type//. The storage type of a property
is given by its definition and constrains the set of values that
can be stored in the property.

<p>In general, if a property holds a value, then that value must have
a allocated type that is a //compatible subtype// of property's storage
type. The intuitive meaning of compatible subtype is that the subtype's 
(the allocated type) value set is a subset of the type it is compatible with
(the storage type). The precise meaning of compatible subtype is specified 
below.

== The Type Language ==

<p>ES4 includes the following types:

<p>The type ''null'', populated only by the value ''null''.

<p>The type ''undefined'', populated only by the value ''undefined''.

<p>The //any// type, denoted ''*'',  that represents all
possible ES4 values.

<p><FIXME> Should ''void'' be a type?

<p>A record type, such as ''{x: Number, y: Number}'', which represents
a record with two fields ''x'' and ''y'', both of type ''Number''.

<p>An array type, such as: ''[String]'' or ''[String,Number]''.
<FIXME>Have we resolved the tuple issue?

<p>A union type, such as ''(Number | String)'', which describes both
''Number'' and ''String'' values.

<p>A function type, such as:

{{{
    function (Number, String) : void
}}}

The return type can be omitted, in which case it defaults to the type
''*''.  A function type may include generic type parameters, as in the
type

{{{
    function.&lt;X>(X) : X
}}}

which describes the generic identity function.  A function type may
include a type constraint for the ''this'' binding, as in

{{{
    function(this : Vector) : void
}}}

A function type may use the symbol "''=''" on argument types to indicate
that these arguments have default values, as in:

{{{
    function(Number, String=) : void
}}}

For this function type, the number of arguments at a corresponding
call site may be either 1 or 2. Finally, a function type may also include
a rest-argument, denoted by "''...''", to indicate that any number of
additional parameters are permitted, as in:

{{{
    function(String, ...) : void
}}}

<p>A reference to a named type, such as: ''String'' or
''X''.

<p>An type application such as ''Vector.&lt;Number>'', which
instantiates the generic class ''Vector'' to hold values of type
''Number''. Note that a  generic class definition such as

{{{
    class Vector.&lt;X> {...}
}}}

introduces a binding for ''Vector'', but ''Vector'' is not actually a
type, in that it requires additional type parameters to become a
normal type, as in ''C.&lt;Number>''.

<p> A //nullable type//, such as ''?String'', which abbreviates
''(String | null)''. (Nullable types are desugared by the parser, and
so do not appear in the AST below.)

<p> A //non-null type// of the form ''T!'', which is identical to the
type ''T'' except that it does not include the value ''null''.

<p>

Internally, the reference implementation also introduces the
following kinds of types:

<p> A //NominalType// is a reference to a class or interface
definition.

<p> An //ObjectRefType// is used to extract a field of a record type
or an array type.

<FIXME>Explain the intuitive meaning of each type expression.


<IMPL>
<INCLUDE file="ast.sml" name="datatype TYPE">

<FIXME>The above datatype is commented out in the RI, and so may not
yet be consistent with the following code.


<p>A //reifiable type// is any type that is not "*" or a union type.


== Type Normalization ==

<p>When each type is encountered in the program source code at
compile-time, it is first //normalized//.

<p>In the scope of a type abbreviation such as

{{{
    type X = T;
}}}

type normalization replaces all references to the type variable ''X''
with the corresponding type ''T''.

<p>Similarly, in the content of a parameterized type abbreviation

{{{
    type X.&lt;Y1, .., Yn> = T;
}}}

type normalization replaces all occurrences of ''X.&lt; S1, .., Sn>''
with ''T[Y1:=S1, .., Yn:=Sn]''.

<NOTE> We use the notation '' T[Y1:=S1,..,Yn:=Sn] '' to denote the
capture-free replacement of all free occurrences of each type variable
''Yi'' within the type ''T'' by the corresponding type ''Si''.

<p>References to nominal types

<p>NonNullType

<p>Finally, type normalization finally converts the resulting type
into a canonical or representative element of its equivalence class.
The notion of type equivalence is defined below.
This //canonicalization// process is necessary to efficiently support generics.

== The Subtyping Relation ==

<p>The subtyping relation is a binary relation on normalized types.
If a type ''S'' is a subtype of type ''T'', then a value of type ''S''
generally behaves as if it had type ''T''.

<p>The subtyping
relation is defined by the  collection of subtype rules described in
the following subsections.

=== Subtyping is Reflexive and Transitive ===

<p>
Subtyping is reflexive, so every type is a subtype of itself.

<p>
Subtyping is transitive, so if ''S'' is a subtype of ''T'' and ''T''
is in turn a subtype of ''U'', then ''S'' is also a subtype of ''U''.

=== Subtyping Record Types ===

<p> The record type ''{l1:S1,..,ln:Sn}'' is a subtype of
''{l1:T1,..,lm:Tm}'' if m <LEQ> n and ''Si'' is equivalent to ''Ti''
for all i in 1..m.

<p> The ordering of the ''label:Type'' bindings in a record type is
irrelevant, and so re-arranging these bindings yields an equivalent
type.  In particular, this re-arranging may be necessary in order to
make the above rule applicable.

=== Subtyping Array Types ===

<p> For array types, we have ''[S1,...,Sn]'' is a subtype of
''[T1,...,Tm]'' provided that each ''S_i'' is //equivalent// to the
corresponding type ''Ti''.  If the two sequences of types are of
different length, then the shorter sequence is first extended to match
the length of the longer sequence by repeating the last element before
applying the above test. Thus, for example, ''[Number,String,String]''
is a subtype of ''[Number,String]''.
The equivalence relation on types is defined
below.

<FIXME> Have we converged on array/tuple types?

=== Subtyping Union Types ===

<p> For union types, a type ''S'' is a subtype of ''(T1,..,Tn)'' if
there exists some i in 1..n such that ''S'' is a subtype of ''Ti''.

<p> Also, a union type ''(S1,..,Sn)'' is a subtype of a type ''T'' if for all i in
1..n, ''Si'' is a subtype of ''T''.

=== Subtyping Function Types ===

<p> A function type ''function(S1,..,Sn):U'' is a subtype of
''function(T1,..,Tn):R'' if ''U'' is a subtype of ''R'' and ''Si'' is
equivalent to ''Ti'' for all i in 1..m.

<NOTE> Function subtyping is invariant in the argument position, and
covariant in the result type.

<p> This rule generalizes to default arguments and rest arguments
according to the following rule, where the number of default arguments
(indicated via the ''='' symbol)
in each function type may be zero, and where ''[...]'' indicates an
optional rest argument.  A function type

{{{
    function(S1, .., Sn, S_{n+1}=, .., Sm=, [...]) : U
}}}
is a subtype of
{{{
    function(T1, .., Tp, T_{p+1}=, .., Tq=, [...]) : R
}}}

if ''U'' is a subtype of ''R'' and n <LEQ> p and ''Si'' is equivalent
to ''Ti'' for all i in 1..min(q,m).

<UL>
  <LI>If neither function type above has a rest argument, then in
addition we require that  q <LEQ> m.

  <LI>If only the first function type has a rest argument, then no
additional conditions are needed.

  <LI>If the second function type has a rest argument, then we require that
the first function type has a rest argument as well, and ''Si'' must
be equivalent to ''*'' for all i in ''{q+1}..m''.
</UL>

<p>
For generic functions, alpha-renaming of the type variable preserves
the meaning of types.  Moreover,

{{{
    function.&lt;X1,..,Xn> (argtypes1) : R1
}}}
is a subtype of
{{{
    function.&lt;X1,..,Xn> (argtypes2) : R2
}}}

if and only if

{{{
    function(argtypes1) : R1
}}}
is a subtype of
{{{
    function(argtypes2) : R2
}}}

That is, to check subtyping between generic functions, we alpha-rename
the type variables to be identical in both types, and then proceed to
check subtyping on the remainder of the type.

<p>
The types in a subtype relation may
contain free type variables, which are assumed to denote some unknown
type. Thus, for example, within the scope of any binding for a type
variable ''X'', we have that the type ''X'' is a subtype of type ''X''
(via reflexivity).

=== Subtyping Nominal Types ===

<p>
Given a class definition

{{{
    class C extends D implements I1, .., In { ... }
}}}

we have that the type ''C'' is a subtype of ''D'', and also that ''C''
is a subtype of ''Ij'' for j in 1..m.

<p>
Given an interface definition

{{{
    interface K extends I1, .., In { ... }
}}}

we have that the type ''K'' is a subtype of ''Ij'' for j in 1..m.

<p>These rules generalize to generic classes and interfaces via
appropriate renaming of bound variables. For example, given a generic
class definition

{{{
    class C.&lt;x1, .., xn> extends D.&lt;T1, .., Tm> {...}
}}}

we have that ''C.&lt;S1, .., Sn>'' is a subtype of

{{{
    D.&lt;T1[x1:=S1,..,xn:=Sn], .., Tm[x1:=S1,..,xn:=Sn]>
}}}


<FIXME> AppType, ObjectRefType, NonNullableType, IdentType vs NominalType

== Implementation of the Subtype Relation ==

<p>
The subtype relation is defined by the following
function ''subType''. This function takes an additional argument
called ''extra'', which is later used to extend the subtype relation with
additional rules (for example, to define the compatible-subtyping
relation below).

<p>Reflexivity is included
explicitly in the code below, whereas transitivity is a consequence
of all the other rules for subtyping.

<IMPL>
<INCLUDE file="type.sml" name="fun subType">

== Type Equivalence ==

Two types are //equivalent// if they are both subtypes of each other.
The function ''equivType'' below checks type equivalence in a
straightforward manner by checking subtyping in both directions, but
more efficient implementations are of course possible. Like
''subType'', ''equivType'' also takes an ''extra'' parameter.

<IMPL>
<INCLUDE file="type.sml" name="and equivType">

== Compatible-Subtyping ==

<p>Every value in ES has an associated //allocated type//, which is a type that is
associated with the value when the value is first allocated or created. An allocated
type is always a reifiable type. The allocated type of a value is invariant; for example,
updating the fields of an object cannot change the allocated tpe of that object.

<p>In general, if a property of type ''T'' hold a value ''v'' of type ''S'', then ''S''
is a compatible-subtype of ''T''.  

<p> 
<IMPL>
<INCLUDE file="type.sml" name="fun compatibleSubtype">

<FIXME>Add prose from Cormac's //Type System// whitepaper.



