= Types =

<hr>
<pre>
FILE:                       spec/language/names.html
DRAFT STATUS:               DRAFT 1 - ROUGH - 2008-03-17
SPEC AUTHORS:               Cormac, Jeff
REVIEWED AGAINST ES3:       NO
REVIEWED AGAINST ERRATA:    NO
REVIEWED AGAINST BASE DOC:  NO
REVIEWED AGAINST PROPOSALS: NO
REVIEWED AGAINST CODE:      NO
SCOPE:                      The dynamic type system
</pre>
<hr>

<FIXME> typeParams in function type
<FIXME> References to nominal types, INSTANCE_TYPE, typedefs, etc
<FIXME> Generic type application
<FIXME> Cross-check with normative grammer on terminology, etc
<FIXME> Introduce ''..'' meta-notation somewhere

<p>ECMAScript includes a gradual type system that supports a range of
typing disciplines, including dynamically-typed code (as in ES3),
statically-typed code (much like in Java or C#), and various
combinations of statically- and dynamically-typed code, with
convenient interoperation between the two.

<p>Type annotations are supported, but not required. A variable with
no type annotation implicitly is assigned the type "*", meaning that
it can hold any value (much like variables in ES3).

<p>ES4 provides two language modes. In //standard mode//, all type
annotations are enforced via dynamic checks (unless static analysis
can prove such checks to never fail). In strict mode, a program is
first checked by a static type checker or verifier before being
executed; any program that is ill-typed will be rejected by the
verifier. If the program is not rejected, then it is executed as in
"standard" mode. That is, there is no difference in run-time behavior
between "strict" and "standard" modes.

<p>Every value has an //allocated type//. The allocated type is the 
type given to a value when it is created and which defines its fixed 
structure.

<p>Every property has a //storage type//. The storage type of a
property is given by its definition and constrains the set of values
that can be stored in the property.

<p>If a property holds a value, then that value must have
an allocated type that is a //compatible subtype// of property's
storage type. The compatible subtype relation is an extension of the
traditional subtype relation that supports more flexible
interoperation between typed and untyped code.
The precise definition of the compatible
subtype relation is included below.

== The Type Language ==

=== The External Type Language ===

<p>ES4 includes the following types:

<p>The type ''null'', populated only by the value ''null''.

<p>The type ''undefined'', populated only by the value ''undefined''.

<p>The //any// type, denoted ''*'',  that represents all
possible ES4 values.

<p>A record type, such as ''{x: Number, y: Number}'', which represents
a record with two fields ''x'' and ''y'', both of type ''Number''.

<p>An array type, such as ''[... String]'', which describes arrays
containing zero or more ''String'' object. An array type can provide
different types for some initial array entries, as in the type
''[Number, Number, ...String]'', which says that the array has at
least two entries, that these entries are both ''Number'' objects, and that
any additional entries are ''String'' objects.

<p>A union type, such as ''(Number | String)'', which describes both
''Number'' and ''String'' values.

<p>A function type, such as

{{{
    function (Number, String) : String
}}}

The return type can be omitted, in which case it defaults to the
//any// type ''*''. The return type can also be declared as ''void'',
to indicate that no value is returned.

<p>A function type may include generic type parameters, as in the following
type for the generic identity function. 

{{{
    function.&lt;X>(X) : X
}}}

<p>A function type may
include a type constraint for the ''this'' binding, as in

{{{
    function(this : Vector, Number, String) : String
}}}

<p>A function type may use the symbol "''=''"  to indicate
which arguments have default values, as in:

{{{
    function(Number, String=) : String
}}}

For this function type, the number of arguments at a corresponding
call site may be either 1 (a ''Number'') or 2 (a ''Number'' and a
''String'').

<p>Finally, a function type may include a rest-argument, denoted
by "''...''", to indicate that any number of additional parameters are
permitted, as in:

{{{
    function(String, ...) : String
}}}

<p> A //nullable type//, such as ''?String'', is simply an
abbreviation for the union type
''(String | null)''. (Nullable types are desugared by the parser, and
so do not appear in the AST below.)

<p> A //non-null type// has the form ''T!''. This type is identical to the
type ''T'' except that it does not include the value ''null''.

<p>A reference to a named type, such as ''String'' or
''X''.

<p>A type application, such as ''Vector.&lt;Number>'', which
instantiates the generic class ''Vector'' to hold values of type
''Number''. Note that a  generic class definition such as

{{{
    class Vector.&lt;X> {...}
}}}

introduces a binding for ''Vector'', but ''Vector'' itself is not actually a
type, since it requires additional type parameters to become a
normal type, as in ''Vector.&lt;Number>''.

<p>The type language includes //type names//, which can refer to
nominal types (ie, class or interface types), type definitions, or to
type variables bound by a generic parameter list, for example, the
type variable ''X'' in the following class definition:

{{{
    class Vector.<X> {
        ...
    }
}}}

To help avoid name collision during type normalization (described
below), each type variable bound in generic parameter list is assigned
an associated //nonce//, or unique integer, and any corresponding
reference to that type variable includes that nonce.  References to
nominal types or to types introduced via type definitions do not
include a nonce.


=== The Internal Representation of Types ===

<p> To support destructuring assignment, the reference implementation
internally uses the following two additional type forms:

<p> A //type name reference// has the form ''T.n'', where ''T'' is a type
and ''n'' is a name. The type ''T'' should resolve to a record type
with a field named ''n'' of some type ''S'', and ''T.n'' denotes that
type ''S''.

<p> A //type index reference// has the form ''T[i]'', where ''T'' is a
type and ''i'' is an integer. The type ''T'' should resolve to an
array type whose entry at index ''i'' is some type ''S'', and ''T[i]''
denotes that type ''S''.

<p> Internally, the reference implementation also resolves type names
that refer to nominal types into an //instance type//. Essentially, an
instance type includes the Name of a particular nominal type, plus any
type arguments to which that nominal type is being applied. (This type
argument list is empty for references to non-generic nominal types.)

<p> In addition, instance types do not include null, and so a type
name that refers to a nullable class ''C'' would be expanded into a
union type that includes ''null'' explicitly in addition to an
instance type for ''C''. The ''INSTANCE_TYPE''
implementation type described below includes additional fields that
facilitate efficient evaluation, and these are described elsewhere.

<FIXME>Additional  ''INSTANCE_TYPE'' fields described where?
<IMPL>
<INCLUDE file="ast.sml" name="datatype TYPE">
<INCLUDE file="ast.sml" name="and FUNCTION_TYPE">
<INCLUDE file="ast.sml" name="and INSTANCE_TYPE">

<FIXME>The above datatype is commented out in the RI, and so may not
yet be consistent with the following code.



== The Subtype and Type Equivalence Relations ==

<p>The subtyping relation is a binary relation on normalized types.
If a type ''S'' is a subtype of type ''T'', then a value of type ''S''
generally behaves as if it had type ''T''.

<p>The type equivalence relation is also a binary relation on types.
Two types are equivalent if and only if they are both subtypes of each other.

<p>The subtyping
relation is defined by the  collection of subtype rules described in
the following subsections.

=== Subtyping is Reflexive and Transitive ===

<p>
Subtyping is reflexive, so every type is a subtype of itself.

<p>
Subtyping is transitive, so if ''S'' is a subtype of ''T'' and ''T''
is in turn a subtype of ''U'', then ''S'' is also a subtype of ''U''.

=== Subtyping Record Types ===

<p> A record type ''{N1:S1, .., Nn:Sn}'' (where each ''Ni'' is a name
and each ''Si'' is a type) is a subtype of
''{N1:T1, .., Nm:Tm}'' if m <LEQ> n and ''Si'' is equivalent to ''Ti''
for all i in 1..m.

<p> The ordering of the ''Name:Type'' bindings in a record type is
irrelevant, and so re-arranging these bindings yields an equivalent
type.  In particular, this re-arranging may be necessary in order to
make the above rule applicable.

=== Subtyping Array Types ===

<p> An array type ''[S1, .., Sn, S, ..., S]'' is a subtype of ''[S1,
.., S_n, ..., S}]''.  The supertype demands one fewer element in the
array than the subtype does.  For example, ''[Number, String, String,
...String]'' is a subtype of ''[Number, ...String]'', via transitivity.

<NOTE> Here, "''...''" represents concrete syntax, but "''..''" is
meta-syntax, and so "''S1, .., Sn''" represents a sequence of
zero-or-more types.

<p> An array type ''[S1, .., Sn, ..., S]'' is a subtype of ''[T1,
.., Tn, ..., T]'' if ''S'' is equivalent to ''T'' and if each ''S_i'' is
//equivalent// to  ''Ti'' for i in 1..n.


=== Subtyping Union Types ===

<p> A union type ''(S1 | .. | Sn)'' is a subtype of a type ''T'' if
''Si'' is a subtype of ''T'' for all i in 1..n.

<p> A type ''S'' is a subtype of ''(T1 | .. | Tn)'' if
there exists some i in 1..n such that ''S'' is a subtype of ''Ti''.


=== Subtyping Function Types ===

<p> A function type ''function(S1, .., Sn) : U'' is a subtype of
''function(T1, .., Tn) : R'' if ''U'' is a subtype of ''R'' and ''Si'' is
equivalent to ''Ti'' for all i in 1..m.

<NOTE> Function subtyping is invariant in the argument position, and
covariant in the result type.

<p> This rule generalizes to ''this'' arguments, default arguments,
and rest arguments according to the following rule, where the number
of default arguments (indicated via the ''='' symbol) in each function
type may be zero, and where ''[...]'' indicates an optional rest
argument.  A function type

{{{
    function(this:S1, S2, .., Sn, S_{n+1}=, .., Sm=, [...]) : U
}}}
is a subtype of
{{{
    function(this:T1, T2, .., Tp, T_{p+1}=, .., Tq=, [...]) : R
}}}

if ''U'' is a subtype of ''R'' and n <LEQ> p and ''Si'' is equivalent
to ''Ti'' for all i in 1..min(q,m). In addition:

<UL>
  <LI>If neither function type  has a rest argument, then we require that  q <LEQ> m.

  <LI>If only the first function type has a rest argument, then no
additional conditions are needed.

  <LI>If the second function type has a rest argument, then the first
function type must have a rest argument as well, and ''Si'' must be
equivalent to ''*'' for all i in ''(q+1)..m''.

</UL>

<p>
For generic functions, alpha-renaming of the type variable preserves
the meaning of types.  Moreover,

{{{
    function.&lt;X1,..,Xn> (argtypes1) : R1
}}}
is a subtype of
{{{
    function.&lt;X1,..,Xn> (argtypes2) : R2
}}}

if and only if

{{{
    function(argtypes1) : R1
}}}
is a subtype of
{{{
    function(argtypes2) : R2
}}}

That is, to check subtyping between generic functions, we alpha-rename
the type variables to be identical in both types, and then proceed to
check subtyping on the non-generic versions of the two function types.

<p>
The types in a subtype relation may
contain free type variables, which are assumed to denote some unknown
type. For example, within the scope of any binding for a type
variable ''X'',   the type ''X'' is a subtype of type ''X''
(via reflexivity).

=== Subtyping Non-Null Types ===

<p>A non-null type ''S!'' is a subtype of type ''T''
if ''S'' is a subtype of the union type ''(T | null)''.

<p>A type ''S'' is a subtype of a non-null type ''T!''
if ''S'' is a subtype of ''T''
and the type ''null'' is //not// a subtype of ''S''.

<p>A nominal type ''C'' (or
''C.&lt;T1, .., Tn>'') can be declared as a //non-null// type via any of the
following declarations:

{{{
    class C! ..
    class C.&lt;X1, .., Xn>! ..
    interface C! ..
    interface C.&lt;X1, .., Xn>! ..
}}}

<p>If ''C'' is a non-null nominal type, then the types ''C'' and
''C!'' are equivalent.
''C''.

<p>If ''C'' is a nominal type that is not declared as non-null, then
the types ''C'' and ''(C!  | null)'' are equivalent.


<p>Analogous subtype rules hold for type applications of the form
''C.&lt;T1, .., Tn>''.

=== Subtyping Nominal Types ===

<p>
Given a class definition

{{{
    class C extends D implements I1, .., In { ... }
}}}

the type ''C'' is a subtype of ''D'', and also ''C'' is a subtype of
''Ij'' for j in 1..n.

<p>
Given an interface definition

{{{
    interface K extends I1, .., In { ... }
}}}

we have that the type ''K'' is a subtype of ''Ij'' for j in 1..m.

<p>These rules generalize to applications of generic classes and interfaces via
appropriate renaming of bound variables. For example, given a generic
class definition

{{{
    class C.&lt;x1, .., xn> extends D.&lt;T1, .., Tm> {...}
}}}

we have that ''C.&lt;S1, .., Sn>'' is a subtype of

{{{
    D.&lt;T1[x1:=S1,..,xn:=Sn], .., Tm[x1:=S1,..,xn:=Sn]>
}}}

<p>Also,
''C.&lt;T1, .., Tn>'' is a subtype of
''C.&lt;S1, .., Sn>'' if each type ''Ti'' is equivalent to the
corresponding type ''Si'' for i in 1..n.

<NOTE>The subtype relation only relates normalized types, and so does
not deal with the type constructors ''IdentType'', or
''ObjectRefType'',  which are removed during type normalization.

=== Relating Structural and Nominal Types ===

<p> A record type ''{N1:S1, .., Nn:Sn}''  is a subtype of the nominal
type ''public::Object''.

<p> An array type ''[S1, .., Sn]''  is a subtype of the nominal
types ''public::Array'' and ''public::Object''.

<p> Any function type  is a subtype of the nominal
types ''public::Function'' and ''public::Object''.

=== Type Definitions and Type References ===

<p>
In the scope of a type definition

{{{
    type X = T
}}}

the type ''X'' (that is, a reference to that type variable) is
equivalent to the type ''T''.

<p>
In the scope of a generic type definition

{{{
    type X.&lt;Y1, .., Yn> = T
}}}

the type application ''X.&lt;<S1, .., Sn>'' is
equivalent to the type ''T[Y1:=S1, .., Yn:=Sn]''.

<p>A //type name reference type// of the form ''T.name'' is equivalent to the type
''S'' if ''T'' is a record type  ''{ name:S, .. }''.

<p>A //type index reference type// of the form ''T[i]'' is equivalent to the type
''Si'' if ''T'' is an array type   ''[S1, .., Sn, ...S]''
and 1 <LEQ> i <LEQ> n. If i <GT> n, then ''T[i]'' is equivalent to ''S''.

== Type Normalization ==

<p>At compile time, each type ''T'' in the program source code is
//normalized// into a canonical or representative element of its
equivalence class.  That is, the type ''T'' is considered equivalent
(under the equivalence relation defined above) to some collection of
types, and the normalization process replaces ''T'' with some
representative element of this equivalence class. In particular, if
two types ''T1'' and ''T2'' are equivalent, then normalization will
convert them both into an identical normalized type.

<p>This //normalization// process is necessary to efficiently support
generics.

<p>A //normalized type// is one that is the result of this
normalization process. Normalized types do not (1) include references to
type definitions, (2) type name reference types, or (3) type index
reference types.

<FIXME>References to nominal types

== Implementation of the Subtype Relation ==

<p>
The subtype relation is defined by the following
function ''subType''. This function takes an additional argument
called ''extra'', which is later used to extend the subtype relation with
additional rules (for example, to define the compatible-subtyping
relation below).

<p>Reflexivity is included
explicitly in the code below, whereas transitivity is a consequence
of all the other rules for subtyping.

<IMPL>
<INCLUDE file="type.sml" name="fun subType">

== Type Equivalence ==

Two types are //equivalent// if they are both subtypes of each other.
The function ''equivType'' below checks type equivalence in a
straightforward manner by checking subtyping in both directions, but
more efficient implementations are of course possible. Like
''subType'', ''equivType'' also takes an ''extra'' parameter.

<NOTE>The following implementation is straightforward and sufficies
for a specification, but its worst-case time complexity is exponential
in the height of a type, and so this naive approach would be
inadequate in an implementation.

<IMPL>
<INCLUDE file="type.sml" name="and equivType">

== Compatible Types ==

<p>The compatibility relation is a binary relation on types. Two types ''S''
and ''T'' are compatible if ''T'' can be obtained from ''S'' by replacing certain
portions of ''S'' by the any type ''*''.

<p>Thus, for example, the record type ''{x : int}'' is compatible with
both ''{x : *}'' and with ''*'', but the type ''{x : *}'' is not
compatible with ''{x : int}''.

<p>In addition, if ''T'' is a generic nominal type, then the type
''T.&lt;Number>'' is compatible with ''T.&lt;*>''.

<p>This compatibility relation is reflexive and transitive, but not
symmetric.

== Compatible-Subtyping ==

<p>The compatible-subtype relation is a binary relation on types.  A
type ''S'' is a compatible-subtype of a type ''T'' if there exists
some type ''U'' such that ''S'' is a subtype of ''U'' and ''U''
compatible with ''T''.

<p>For example, the record type ''{x : int, y : bool}'' is a
compatible-subtype of the types ''{x : *, y : *}'', ''{x : int}'',
''{x : *}'', and ''*''.

<p>The compatible-subtyping relation is reflexive and transitive, but not symmetric.

<p>The compatible-subtyping relation is implemented by calling the
previously-defined ''subType'' predicate and passing in an ''extra''
parameter that reasons about compatibility, in that every type is
compatible with ''*''.
<IMPL>
<INCLUDE file="type.sml" name="fun compatibleSubtype">


== Type Invariants at Run Time ==

<p>A //reifiable type// is any type that is not "''*''" or a union type.

<p>Every value in ES has an associated //allocated type//, which is a type that is
associated with the value when the value is first allocated or created. An allocated
type is always a reifiable type. The allocated type of a value is invariant; for example,
updating the fields of an object cannot change the allocated tpe of that object.

<p>If a property of type ''T'' hold a value ''v'' of type ''S'', then ''S''
is a compatible-subtype of ''T''.  


