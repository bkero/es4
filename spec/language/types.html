= Types =

<hr>
<pre>
FILE:                       spec/language/names.html
DRAFT STATUS:               DRAFT 1 - ROUGH - 2008-03-17
SPEC AUTHORS:               Cormac, Jeff
REVIEWED AGAINST ES3:       NO
REVIEWED AGAINST ERRATA:    NO
REVIEWED AGAINST BASE DOC:  NO
REVIEWED AGAINST PROPOSALS: NO
REVIEWED AGAINST CODE:      NO
SCOPE:                      The dynamic type system
</pre>
<hr>

<p>ECMAScript includes a gradual type system that supports a range of typing disciplines, including
dynamically-typed code (as in ES3), statically-typed code (much like in Java or C#), and various
combinations of statically- and dynamically-typed code, with convenient interoperation between the two.

<p>Type annotations are supported, but not required. A variable with no type annotation implicitly is
assigned the type "*", meaning that it can hold any value (much like variables in ES3).

<p>ES4 provides two language modes. In //standard mode//, all type annotations are enforced via 
dynamic checks (unless static analysis can prove such checks to never fail). In strict mode, a
program is first checked by a static type checker or verifier before being executed; any program that
is ill-typed will be rejected by the verifier. If the program is not rejected, then it is executed
as in "standard" mode. That is, there is no difference in run-time behavior between "strict" and
"standard" modes.

<p>Every value has an //allocated type//. The allocated type is the 
type given to a value when it is created and which defines its fixed 
structure.

<p>Every property has a //storage type//. The storage type of a property
is given by its definition and constrains the set of values that
can be stored in the property.

<p>In general, if a property holds a value, then that value must have
a allocated type that is a //compatible subtype// of property's storage
type. The intuitive meaning of compatible subtype is that the subtype's 
(the allocated type) value set is a subset of the type it is compatible with
(the storage type). The precise meaning of compatible subtype is specified 
below.

== Type Expressions ==

<p>A type may be expressed by any of the following kinds of expressions:

<p>The keyword ''null''
<p>The symbol ''*''
<p>The contextually-reserved keyword ''undefined''
<p>An //Identifier Expression// expression such as: ''String'' or
''X''
<p>A //RecordType// expression such as: ''{x: Number, y: Number}''
<p>An //ArrayType// expression such as: ''[String]'' or ''[String,Number]''
<p>A //UnionType// expression such as: ''(Number, String)''
<p>A //FunctionType// expression such as: ''function (Number, String)
: void''. A function type may include generic type parameters, as in
''function.&lt;X>(X):X'' for the generic identity function.
A function type may include a type requirement for the
''this'' binding, as in ''function(this:Vector):void''. A function
type may also include default values for some arguments, denoted by
''function(Number, String=):void'', in which case the minimum number
of required arguments at a call site is 1. Finally, a function type
may also include a rest-args, as in ''function(Number, String,
...):void''.
<p> A //NullableType//, such as ''String?'' or ''String!''
<p> A //LamType// ...
<p>An //TypeApplication// expression such as: ''Vector.&lt;Number&gt;''
<p>A //LikeType// expression such as: ''like {x: Number}''

<p>Internally, the reference implementation also introduces the
following kinds of types:

<p> A //NominalType// is a reference to a class or interface
definition.
<p> An //ObjectRefType// is used to extract a field of a record type
or an array type.

<p>ES4 supports generic function types,

<FIXME>Explain the intuitive meaning of each type expression.


<IMPL>
<INCLUDE file="ast.sml" name="datatype TYPE">

<p>A //reifiable type// is any type tha tis not "*", a union type, or a //like// type.

<p>In the context of a class definition such as ''class C.&lt;X>
 {...}'',
we cannot declare a variable of type //C//. We refer to //C// as a
 //type constructor//, which is distinct from a regular type, in that it
requires additional type parameters to become a normal type of the
form ''C.<T>''.

== Type Compatibility and Subtyping ==

<p>Every value in ES has an associated //allocated type//, which is a type that is
associated with the value when the value is first allocated or created. An allocated
type is always a reifiable type. The allocated type of a value is invariant; for example,
updating the fields of an object cannot change the allocated tpe of that object.

<p>In general, if a property of type ''T'' hold a value ''v'' of type ''S'', then ''S''
is a compatible-subtype of ''T''. There are some exceptions where ''T'' is a //like-type//.

<p> 
<IMPL>
<INCLUDE file="type.sml" name="datatype BICOMPAT">
<INCLUDE file="type.sml" name="datatype VARIANCE">
<INCLUDE file="type.sml" name="fun groundMatchesGeneric">



=== Subtyping ===

<FIXME>Add prose from Cormac's //Type System// whitepaper.

=== Compatible Subtyping ===

<FIXME>Add prose from Cormac's //Type System// whitepaper.


