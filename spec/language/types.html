= Types =

<hr>
<pre>
FILE:                       spec/language/names.html
DRAFT STATUS:               DRAFT 1 - ROUGH - 2008-03-17
SPEC AUTHORS:               Cormac, Jeff
REVIEWED AGAINST ES3:       NO
REVIEWED AGAINST ERRATA:    NO
REVIEWED AGAINST BASE DOC:  NO
REVIEWED AGAINST PROPOSALS: NO
REVIEWED AGAINST CODE:      NO
SCOPE:                      The type system
</pre>
<hr>

<p>ECMAScript includes a gradual type system that supports a range of typing disciplines, including
dynamically-typed code (as in ES3), statically-typed code (much like in Java or C#), and various
combinations of statically- and dynamically-typed code, with convenient interoperation between the two.

<p>Type annotations are supported, but not required. A variable with no type annotation implicitly is
assigned the type "*", meaning that it can hold any value (much like variables in ES3).

<p>ES4 provides two language modes. In //standard mode//, all type annotations are enforced via 
dynamic checks (unless static analysis can prove such checks to never fail). In strict mode, a
program is first checked by a static type checker or verifier before being executed; any program that
is ill-typed will be rejected by the verifier. If the program is not rejected, then it is executed
as in "standard" mode. That is, there is no difference in run-time behavior between "strict" and
"standard" modes.

<p>Every value has an //allocated type//. The allocated type is the 
type given to a value when it is created and which defines its fixed 
structure.

<p>Every property has an //storage type//. The storage type of a property
is given by its definition and constrains the set of values that
can be stored in the property.

<p>In general, if a property holds a value, then that value must have
a allocated type that is a //compatible subtype// of property's storage
type. The intuitive meaning of compatible subtype is that the subtype's 
(the allocated type) value set is a subset of the type it is compatible with
(the storage type). The precise meaning of compatible subtype is specified 
below.

== Type Expressions ==

<p>A type may be expressed by any of the following kinds of expressions:

<p>The keyword ''null''
<p>The symbol ''*''
<p>A //PrimaryName// expression such as: ''String''
<p>An //TypeApplication// expression such as: ''Vector.<Number>''
<p>A //FunctionType// expression such as: ''function (Number, String=) : void''
<p>A //RecordType// expression such as: ''{x: Number, y: Number}''
<p>A //UnionType// expression such as: ''(Number, String)''
<p>An //ArrayType// expression such as: ''[String]''
<p>A //LikeType// expression such as: ''like {x: Number}''

<FIXME>Explain the intuitive meaning of each type expression.

<IMPL>
{{{
datatype TYPE_EXPR =
         SpecialType of SPECIAL_TY
       | UnionType of TYPE_EXPR list
       | ArrayType of TYPE_EXPR list
       | TypeName of IDENT_EXPR
       | ElementTypeRef of (TYPE_EXPR * int)
       | FieldTypeRef of (TYPE_EXPR * IDENT)
       | FunctionType of FUNC_TYPE
       | ObjectType of FIELD_TYPE list
       | LikeType of TYPE_EXPR
       | WrapType of TYPE_EXPR
       | AppType of 
         { base: TYPE_EXPR,
           args: TYPE_EXPR list }
       | LamType of
         { params: IDENT list,
           body: TYPE_EXPR }
       | NullableType of 
         { expr:TYPE_EXPR,
           nullable:bool }
       | InstanceType of INSTANCE_TYPE

datatype SPECIAL_TY =
         Any
       | Null
       | Undefined
       | VoidType

}}}

<p>A //reifiable type// is any type tha tis not "*", a union type, or a //like// type.

<p>In the context of a class definition such as ''class C.<X> {...}'', the class name
//C// is considered to be a type, but it is somewhat unusual in that we cannot declare
a variable of type //C//. We refer to //C// as a //higher-order// type, in that it
requires additional type parameters to become a normal or //first-order// type of the
form ''C.<T>''.

== Type Compatibility ==

<p>Every value in ES has an associated //allocated type//, which is a type that is
associated with the value when the value is first allocated or created. An allocated
type is always a reifiable type. The allocated type of a value is invariant; for example,
updating the fields of an object cannot change the allocated tpe of that object.

<p>In general, if a property of type ''T'' hold a value ''v'' of type ''S'', then ''S''
is a compatible-subtype of ''T''. There are some exceptions where ''T'' is a //like-type//.

=== Subtyping ===

<FIXME>Add prose from Cormac's //Type System// whitepaper.

=== Compatible Subtyping ===

<FIXME>Add prose from Cormac's //Type System// whitepaper.


