= Types =

<hr>
<pre>
FILE:                       spec/language/names.html
DRAFT STATUS:               DRAFT 1 - ROUGH - 2008-03-17
SPEC AUTHORS:               Cormac, Jeff
REVIEWED AGAINST ES3:       NO
REVIEWED AGAINST ERRATA:    NO
REVIEWED AGAINST BASE DOC:  NO
REVIEWED AGAINST PROPOSALS: NO
REVIEWED AGAINST CODE:      NO
SCOPE:                      The dynamic type system
</pre>
<hr>

<p>ECMAScript includes a gradual type system that supports a range of typing disciplines, including
dynamically-typed code (as in ES3), statically-typed code (much like in Java or C#), and various
combinations of statically- and dynamically-typed code, with convenient interoperation between the two.

<p>Type annotations are supported, but not required. A variable with no type annotation implicitly is
assigned the type "*", meaning that it can hold any value (much like variables in ES3).

<p>ES4 provides two language modes. In //standard mode//, all type annotations are enforced via 
dynamic checks (unless static analysis can prove such checks to never fail). In strict mode, a
program is first checked by a static type checker or verifier before being executed; any program that
is ill-typed will be rejected by the verifier. If the program is not rejected, then it is executed
as in "standard" mode. That is, there is no difference in run-time behavior between "strict" and
"standard" modes.

<p>Every value has an //allocated type//. The allocated type is the 
type given to a value when it is created and which defines its fixed 
structure.

<p>Every property has a //storage type//. The storage type of a property
is given by its definition and constrains the set of values that
can be stored in the property.

<p>In general, if a property holds a value, then that value must have
a allocated type that is a //compatible subtype// of property's storage
type. The intuitive meaning of compatible subtype is that the subtype's 
(the allocated type) value set is a subset of the type it is compatible with
(the storage type). The precise meaning of compatible subtype is specified 
below.

== Type Expressions ==

<p>A type may be expressed by any of the following kinds of expressions:

<p>The type ''null'', populated only by the value ''null''.
<p>The type ''undefined'', populated only by the value ''undefined''.
<p>The //any// type, denoted ''*'',  that represents all
possible ES4 values.
<p>An //Identifier Expression// expression such as: ''String'' or
''X''.
<p>A //RecordType// expression such as ''{x: Number, y: Number}'',
which represents a record with two fields ''x'' and ''y'', both of type
''Number''.
<p>An //ArrayType// expression such as: ''[String]'' or
''[String,Number]''.
<FIXME>Have we resolved the tuple issue?
<p>A //UnionType// expression such as ''(Number | String)'',
which describes both ''Number'' and ''String'' values. 
<p>A //FunctionType// expression such as: ''function (Number, String)
: void''. A function type may include generic type parameters, as in
''function.&lt;X>(X):X'' for the generic identity function.
A function type may include a type requirement for the
''this'' binding, as in ''function(this:Vector):void''. A function
type may also include default values for some arguments, denoted by
''function(Number, String=):void'', in which case the number
of arguments at a call site is either 1 or 2. Finally, a function type
may also include a rest-args, as in ''function(Number, String,
...):void''.
<p> A //NullableType//, such as ''?String'', which abbreviates
''(String | null)''.
<p> A //NonNullableType//, such as ''String!'' (which does not include ''null'').
<p>An //TypeApplication// expression such as:
''Vector.&lt;Number&gt;'', 
which instantiates the generic type ''Vector'' to hold values of type ''Number''.

<p>Internally, the reference implementation also introduces the
following kinds of types:

<p> A //NominalType// is a reference to a class or interface
definition.
<p> An //ObjectRefType// is used to extract a field of a record type
or an array type.

<p>ES4 supports generic function types,

<FIXME>Explain the intuitive meaning of each type expression.


<IMPL>
<INCLUDE file="ast.sml" name="datatype TYPE">

<p>A //reifiable type// is any type that is not "*" or a union type.

<p> A generic class definition ''class C.&lt;X> {...}''  introduces a
//type constructor// ''C'', but ''C'' is not actually a proper type,
in that it requires additional type parameters to become a normal type
of the form ''C.&lt;T>''.

== Subtyping ==

The subtyping relation is a binary relation on types.  If S is a
subtype of T, then a value of type S can generally be assigned to a
property of type T. Two types
are //equivalent// if they are both subtypes of each other.



The types in a subtype relation may
contain free type variables, which are assumed to denote the same but
unknown type. (See the rule for generic functions below.)   The subtyping
relation is defined by the following rules:

<IMPL>
<INCLUDE file="type.sml" name="datatype TYPE_COMPARISON">
<INCLUDE file="type.sml" name="fun compareTypes">

== Compatible-Subtyping ==

<p>Every value in ES has an associated //allocated type//, which is a type that is
associated with the value when the value is first allocated or created. An allocated
type is always a reifiable type. The allocated type of a value is invariant; for example,
updating the fields of an object cannot change the allocated tpe of that object.

<p>In general, if a property of type ''T'' hold a value ''v'' of type ''S'', then ''S''
is a compatible-subtype of ''T''.  

<p> 
<IMPL>
<INCLUDE file="type.sml" name="datatype TYPE_COMPARISON">
<INCLUDE file="type.sml" name="fun compareTypes">
<INCLUDE file="type.sml" name="fun compatibleSubtype">



=== Subtyping ===

<FIXME>Add prose from Cormac's //Type System// whitepaper.

=== Compatible Subtyping ===

<FIXME>Add prose from Cormac's //Type System// whitepaper.


