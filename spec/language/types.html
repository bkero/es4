= Types =

<hr>
<pre>
FILE:                       spec/language/names.html
DRAFT STATUS:               DRAFT 1 - ROUGH - 2008-03-17
SPEC AUTHORS:               Cormac, Jeff
REVIEWED AGAINST ES3:       NO
REVIEWED AGAINST ERRATA:    NO
REVIEWED AGAINST BASE DOC:  NO
REVIEWED AGAINST PROPOSALS: NO
REVIEWED AGAINST CODE:      NO
SCOPE:                      The dynamic type system
</pre>
<hr>

<p>ECMAScript includes a gradual type system that supports a range of typing disciplines, including
dynamically-typed code (as in ES3), statically-typed code (much like in Java or C#), and various
combinations of statically- and dynamically-typed code, with convenient interoperation between the two.

<p>Type annotations are supported, but not required. A variable with no type annotation implicitly is
assigned the type "*", meaning that it can hold any value (much like variables in ES3).

<p>ES4 provides two language modes. In //standard mode//, all type annotations are enforced via 
dynamic checks (unless static analysis can prove such checks to never fail). In strict mode, a
program is first checked by a static type checker or verifier before being executed; any program that
is ill-typed will be rejected by the verifier. If the program is not rejected, then it is executed
as in "standard" mode. That is, there is no difference in run-time behavior between "strict" and
"standard" modes.

<p>Every value has an //allocated type//. The allocated type is the 
type given to a value when it is created and which defines its fixed 
structure.

<p>Every property has a //storage type//. The storage type of a property
is given by its definition and constrains the set of values that
can be stored in the property.

<p>In general, if a property holds a value, then that value must have
a allocated type that is a //compatible subtype// of property's storage
type. The intuitive meaning of compatible subtype is that the subtype's 
(the allocated type) value set is a subset of the type it is compatible with
(the storage type). The precise meaning of compatible subtype is specified 
below.

== Type Expressions ==

<p>A type may be expressed by any of the following kinds of expressions:

<p>The type ''null'', populated only by the value ''null''.
<p>The type ''undefined'', populated only by the value ''undefined''.
<p>The //any// type, denoted ''*'',  that represents all
possible ES4 values.
<p>An //Identifier Expression// expression such as: ''String'' or
''X''.
<p>A //RecordType// expression such as ''{x: Number, y: Number}'',
which represents a record with two fields ''x'' and ''y'', both of type
''Number''.
<p>An //ArrayType// expression such as: ''[String]'' or
''[String,Number]''.
<FIXME>Have we resolved the tuple issue?
<p>A //UnionType// expression such as ''(Number | String)'',
which describes both ''Number'' and ''String'' values. 
<p>A //FunctionType// expression such as: ''function (Number, String)
: void''. A function type may include generic type parameters, as in
''function.&lt;X>(X):X'' for the generic identity function.
A function type may include a type requirement for the
''this'' binding, as in ''function(this:Vector):void''. A function
type may also include default values for some arguments, denoted by
''function(Number, String=):void'', in which case the number
of arguments at a call site is either 1 or 2. Finally, a function type
may also include a rest-args, as in ''function(Number, String,
...):void''.
<p> A //NullableType//, such as ''?String'', which abbreviates
''(String | null)''.
<p> A //NonNullableType//, such as ''String!'' (which does not include ''null'').
<p>An //TypeApplication// expression such as:
''Vector.&lt;Number&gt;'', 
which instantiates the generic type ''Vector'' to hold values of type ''Number''.

<p>Internally, the reference implementation also introduces the
following kinds of types:

<p> A //NominalType// is a reference to a class or interface
definition.
<p> An //ObjectRefType// is used to extract a field of a record type
or an array type.

<p>ES4 supports generic function types,

<FIXME>Explain the intuitive meaning of each type expression.


<IMPL>
<INCLUDE file="ast.sml" name="datatype TYPE">

<p>A //reifiable type// is any type that is not "*" or a union type.

<p> A generic class definition ''class C.&lt;X> {...}''  introduces a
//type constructor// ''C'', but ''C'' is not actually a proper type,
in that it requires additional type parameters to become a normal type
of the form ''C.&lt;T>''.

== Subtyping Relation ==

<p>The subtyping relation is a binary relation on types.  If a type ''S'' is a
subtype of type ''T'', then a value of type ''S'' generally behaves as if it had
type ''T''.

<p>
Subtyping is reflexive and transitive.

<p>
The types in a subtype relation may
contain free type variables, which are assumed to denote the same but
unknown type. (See the rule for generic functions below.)   The subtyping
relation is defined by the following rules:

=== Subtyping Nominal Types ===

<p>
Given a class definition ''class C extends D implements I1,...,In { ... }'', we have that
the type ''C''
is a subtype of ''D'', and also that ''C'' is a subtype of ''Ij'', for
j in 1..m.

<p>
Given an interface definition ''interface K extends I1,...,In { ... }'', we have that
the type ''K'' is a subtype of ''Ij'', for j in 1..m.

<p>These rules generalize to generic classes and interfaces via
appropriate renaming of bound variables. For example, given a generic
class definition ''class C.&lt;x1,..,xn> extends D.&lt;T1,..,Tm>
{...}'', we have that ''C.&lt;S1,..,Sn>'' is a subtype of
''D.&lt;T1[x1:=S1,..,xn:=Sn],..,Tm[x1:=S1.,,,.xn:=Sn]>''.  Here, use
the notation ''T1[x1:=S1,..,xn:=Sn]'' to denote the capture-free
replacement of all free occurrences of each type variable ''xi''
within the type ''T'' by the corresponding type ''Si''.

=== Subtyping Array and Record Types ===

<p> For array types, we have ''[S1,...,Sn]'' is a subtype of
''[T1,...,Tm]'' provided that each ''S_i'' is //equivalent// to the
corresponding type ''Ti''.  If the two sequences of types are of
different length, then the shorter sequence is first extended to match
the length of the longer sequence by repeating the last element before
applying the above test. Thus, for example, ''[Number,String,String]''
is a subtype of ''[Number,String]''.
The equivalence relation on types is defined
below.

<p> The record type ''{l1:S1,..,ln:Sn}'' is a subtype of
''{l1:T1,..,lm:Tm}'' if ''n''>=''m'' and for all i in 1..m, ''Si'' is
equivalent to ''Ti''.  The ordering of ''label:Type'' bindings in a
record type is irrelevant, and so can be re-arranged in order to make
this rule applicable.

=== Subtyping Union Types ===

<p> For union types, a type ''S'' is a subtype of ''(T1,..,Tn)'' if
there exists some i in 1..n such that ''S'' is a subtype of ''Ti''.

<p> Also, a union type ''(S1,..,Sn)'' is a subtype of a type ''T'' if for all i in
1..n, ''Si'' is a subtype of ''T''.

=== Subtyping Function Types ===


<p> A function type ''function(S1,..,Sn):U'' is a subtype of
''function(T1,..,Tn):R'' if ''U'' is a subtype of ''R'' and ''Si'' is
equivalent to ''Ti'' for all i in 1..m.

<NOTE> Function subtyping is invariant in the argument position, and
covariant in the result type.

<p>
This rule generalizes to default arguments and rest arguments as
follows, where the number of default arguments in each function type
may be zero, and where ''[...]'' indicates an optional rest argument.
A function type
{{{
    function(S1, .., Sn, S_{n+1}=, .., Sm=, [...]) : U
}}}
is a subtype of
{{{
    function(T1, .., Tp, T_{p+1}=, .., Tq=, [...]) : R
}}}

if ''U'' is a subtype of ''R'' and n <LEQ> p and ''Si'' is equivalent
to ''Ti'' for all i in 1..min(q,m).

If neither function type has a rest argument, then we require that  q <LEQ> m.

If only the first function type has a rest argument, then no
additional conditions are needed.

If the second function type has a rest argument, then we require that
the first function type has a rest argument as well, and ''Si'' must
be equivalent to ''*'' for all i in q+1..m.


but the first
function type d
<p>
This rule generalizes to default arguments as follows:
{{{
    function(S1, .., Sn, S_{n+1}=, .., Sm=) : U
}}}
is a subtype of
{{{
    function(T1, .., Tp, T_{p+1}=, .., Tq=) : R
}}}
if ''U'' is a subtype of ''R'' and
n <LEQ> p and q <LEQ> m and ''Si'' is equivalent to ''Ti'' for all i in 1..q.

<p>
For rest arguments in the subtype
only,
{{{
    function(S1, .., Sn, S_{n+1}=, .., Sm=, ...) : U
}}}
is a subtype of
{{{
    function(T1, .., Tp, T_{p+1}=, .., Tq= ) : R
}}}
if ''U'' is a subtype of ''R'' and
n <LEQ> p and ''Si'' is equivalent to ''Ti''  for all i in 1..min(q,m).

<p>
For rest arguments in both types,
{{{
    function(S1, .., Sn, S_{n+1}=, .., Sm=, ...) : U
}}}
is a subtype of
{{{
    function(T1, .., Tp, T_{p+1}=, .., Tq=, ...) : R
}}}
if ''U'' is a subtype of ''R'' and
n <LEQ> p and ''Si'' is equivalent to ''Ti''  for all i in 1..min(q,m)
and ''Si'' is equivalent to ''*'' for all i in q+1..m.

<p>
For generic functions, alpha-renaming of the generic type variable
preserves subtyping and equivalence. Moreover,
''function.&lt;X1,..,Xn>(argtypes):R'' is a subtype of
''function.&lt;X1,..,Xn>(argtypes+):R+ '' if ''function(argtypes):R'' is
a subtype of ''function(argtypes+):R+ ''. That is, to check subtyping
between generic functions, we rename the generic type variables to be
identical in both types, and then proceed to ignore them.

== Implementation of the Subtype Relation ==

<p>
The subtype relation is defined by the following
function ''subType''. This function takes an additional argument
''extra'', which is later used to extend the subtype relation with
additional rules (for example, to define the compatible-subtyping
relation below).

<p>Reflexivity is included
explicitly in the code below, whereas transitivity is a consequence
of all the other rules for subtyping.

<IMPL>
<INCLUDE file="type.sml" name="fun subType">

== Type Equivalence ==

Two types are //equivalent// if they are both subtypes of each other.
The function ''equivType'' below checks type equivalence in a
straightforward manner by checking subtyping in both directions, but
more efficient implementations are of course possible. Like
''subType'', ''equivType'' also takes an ''extra'' parameter.

<IMPL>
<INCLUDE file="type.sml" name="and equivType">

== Compatible-Subtyping ==

<p>Every value in ES has an associated //allocated type//, which is a type that is
associated with the value when the value is first allocated or created. An allocated
type is always a reifiable type. The allocated type of a value is invariant; for example,
updating the fields of an object cannot change the allocated tpe of that object.

<p>In general, if a property of type ''T'' hold a value ''v'' of type ''S'', then ''S''
is a compatible-subtype of ''T''.  

<p> 
<IMPL>
<INCLUDE file="type.sml" name="fun compatibleSubtype">

<FIXME>Add prose from Cormac's //Type System// whitepaper.



