<H1 id="class decimal"> The class ''decimal'' </h1>

<!-- Constants taken from http://pi.lacim.uqam.ca/eng/table_en.html,
     sometimes processed by math.sch in this directory.
     Constants should have 34 significant digits, round to even.
     Please leave a 35-digit (or better) constant inside an HTML 
     comment with the defn in case we find a need to change the
     rounding rule later.
  -->

<pre>
FILE:                       spec/library/decimal.html
DRAFT STATUS:               DRAFT 1 - ROUGH - 2007-09-20
REVIEWED AGAINST ES3:       NO
REVIEWED AGAINST ERRATA:    NO
REVIEWED AGAINST BASE DOC:  NO
REVIEWED AGAINST PROPOSALS: NO
REVIEWED AGAINST CODE:      NO
</pre>


<P> The class ''decimal'' is a final, non-nullable, non-dynamic direct
subclass of ''Object'' that represents 128-bit IEEE decimal floating
point number values in the range 
<NOBR>-(10<SUP>34</SUP>-1) <TIMES> 10<SUP>6111</SUP></NOBR> to
<NOBR>(10<SUP>34</SUP>-1) <TIMES> 10<SUP>6111</SUP></NOBR> inclusive,
plus the three special values -<INFINITY>, +<INFINITY>, and NaN.

<COMP> The class ''decimal'' is new in the 4th Edition of this
Standard.


== Synopsis ==

<P> The class ''decimal'' provides the following interface:

{{{
final class decimal!
{
    <SIGNATURE file="decimal.es" name="function decimal">
    <SIGNATURE file="decimal.es" name="meta static function invoke">
    
    static const MAX_VALUE: decimal = <LDOTS>
    static const MIN_VALUE: decimal = <LDOTS>
    static const NaN: decimal = <LDOTS>
    static const NEGATIVE_INFINITY: decimal = <LDOTS>
    static const POSITIVE_INFINITY: decimal = <LDOTS>
    static const E: decimal = <LDOTS>
    static const LN10: decimal = <LDOTS>
    static const LN2: decimal = <LDOTS>
    static const LOG2E: decimal = <LDOTS>
    static const LOG10E: decimal = <LDOTS>
    static const PI: decimal = <LDOTS>
    static const SQRT1_2: decimal = <LDOTS>
    static const SQRT2: decimal = <LDOTS>
    static const length: uint = 1

    <SIGNATURE file="decimal.es" name="override intrinsic function toString">
    <SIGNATURE file="decimal.es" name="override intrinsic function toLocaleString">
    <SIGNATURE file="decimal.es" name="override intrinsic function toJSONString">
    <SIGNATURE file="decimal.es" name="override intrinsic function valueOf">

    <SIGNATURE file="decimal.es" name="intrinsic function toFixed">
    <SIGNATURE file="decimal.es" name="intrinsic function toExponential">
    <SIGNATURE file="decimal.es" name="intrinsic function toPrecision">
}
}}}

<P> The ''decimal'' prototype object is identical to the ''Number''
prototype object (<XREF target="Number.prototype">).

== Methods on the ''decimal'' class object ==

=== new decimal( value=<LDOTS> ) ===

<DESC>The ''decimal'' constructor initialises the newly created
''decimal'' object by storing an implementation-dependent
representation of the decimal value of //value//, as converted by
''ToNumber'', in a private property.  The default //value// is +0.

<IMPL>The ''decimal'' constructor is implementation-dependent.

=== decimal( value=<LDOTS> ) ===

<DESC> When the ''decimal'' class object is called as a function it
performs a type conversion: it converts //value// (which defaults
to +0) to ''decimal''.

<RETN> The ''decimal'' class object called as a function returns
//value// converted to ''decimal''.

<SHORTIMPL>
<INCLUDE file="decimal.es" name="meta static function invoke">


== Value properties on the ''decimal'' class object ==

=== MAX_VALUE ===

<P> The value of ''MAX_VALUE'' is the largest positive finite value
represented by the ''decimal'' class, type, which is
<NOBR>(10<SUP>34</SUP>-1) <TIMES> 10<SUP>6111</SUP></NOBR>.

=== MIN_VALUE ===

<P> The value of ''MIN_VALUE'' is the smallest positive value
represented by the ''decimal'' class, which is
<NOBR>10<SUP>-6143</SUP></NOBR>.

=== NaN ===

<P> The value of ''NaN'' is the not-a-number value represented by a
''decimal'' instance.

=== NEGATIVE_INFINITY ===

<P> The value of ''NEGATIVE_INFINITY'' is the value -<INFINITY> as
represented by a ''decimal'' instance.

=== POSITIVE_INFINITY ===

<P> The value of ''POSITIVE_INFINITY'' is the value +<INFINITY> as
represented by a ''decimal'' instance.

=== E ===

<P> The value of ''E'' is the ''decimal'' value for //e//, the base of the
natural logarithms, which is approximately 2.718281828459045235360287471352662.

<!-- source: http://pi.lacim.uqam.ca/piDATA/expof1.txt
     exp(1) = 2.7182818284590452353602874713526624977572470936999595749669676277240766 -->

=== LN10 ===

<P>The value of ''LN10'' is the ''decimal'' value for the natural
logarithm of 10, which is approximately 2.302585092994045684017991454684364.

<!-- Source: http://pi.lacim.uqam.ca/piDATA/log10.txt
     log(10) = 2.302585092994045684017991454684364207601101488628772976033327900967572609677352480235997205089 -->

=== LN2 ===

<P>The value of ''LN2'' is the ''decimal'' value for the natural
logarithm of 2, which is approximately 0.6931471805599453094172321214581766.

<!-- Source: http://pi.lacim.uqam.ca/piDATA/1overlog2.txt
     1/log(2) = 1.44269504088896340735992468100189213742664595415298593413544940693110,
     1/1/log(2) = 0.6931471805599453094172321214581765680755001343602552541206800094933980
     (as computed by math.sch in this directory) -->

=== LOG2E ===

<P>The value of ''LOG2E'' is the ''decimal'' value for the base-2
logarithm of //e//, the base of the natural logarithms; this value is
approximately 1.442695040888963407359924681001892.

<NOTE> The value of ''decimal.LOG2E'' is approximately the reciprocal
of the value of ''decimal.LN2''.

<!-- Source: http://pi.lacim.uqam.ca/piDATA/1overlog2.txt
     1/log(2) = 1.44269504088896340735992468100189213742664595415298593413544940693110 -->

=== LOG10E ===

<P>The value of ''LOG10E'' is the decimal value for the base-10
logarithm of //e//, the base of the natural logarithms; this value is
approximately 0.4342944819032518276511289189166051.

<!-- Source: http://pi.lacim.uqam.ca/piDATA/1overlog10.txt
     1/log(10) = 0.43429448190325182765112891891660508229439700580366656611445378316586464920887 -->

<NOTE> The value of ''decimal.LOG10E'' is approximately the reciprocal
of the value of ''decimal.LN10''.

=== PI ===

<P>The value of ''PI'' is the ''decimal'' value for <PI>, the ratio of
the circumference of a circle to its diameter, which is approximately
3.141592653589793238462643383279503.

<!-- Source: http://pi.lacim.uqam.ca/piDATA/pi.html
     pi = 3.1415926535897932384626433832795028841971693993751058209749445923078164062862 -->

=== SQRT1_2 ===

<P>The value of ''SQRT1_2'' is the ''decimal'' value for the square
root of 1/2, which is approximately 0.7071067811865475244008443621048490.

<NOTE> The value of ''decimal.SQRT1_2'' is approximately the reciprocal
of the value of ''decimal.SQRT2''.

<!-- Source: http://pi.lacim.uqam.ca/piDATA/sqrt2.txt
     sqrt(2) = 1.41421356237309504880168872420969807856967187537694807317667973799073247846210 -->
     1/sqrt(2) = 0.7071067811865475244008443621048490392848359376884740365883398689953674
     as computed by math.sch -->

=== SQRT2 ===

<P>The value of ''SQRT2'' is the ''decimal'' value for the square root
of 2, which is approximately 1.414213562373095048801688724209698.

<!-- Source: http://pi.lacim.uqam.ca/piDATA/sqrt2.txt
     sqrt(2) = 1.41421356237309504880168872420969807856967187537694807317667973799073247846210 -->

== Methods on ''decimal'' instances ==

=== intrinsic::toString ( radix=<LDOTS> ) ===

<DESC> The intrinsic ''toString'' method converts this number value
to a string representation in a base given by //radix//.

<P> If radix is the number 10 or undefined, then the result is as for
the ''ToString'' operator.

<P> If radix is an integer from 2 to 36, but not 10, the result is an
implementation-dependent string

<RETN> The intrinsic ''toString'' method returns a string.

<SHORTIMPL>
<INCLUDE file="decimal.es" name="override intrinsic function toString">

=== intrinsic::toLocaleString ( ) ===

<DESC> The intrinsic ''toLocaleString'' method converts this number
value to a string value that represents the value of the integer
formatted according to the conventions of the host environment's
current locale.

<RETN> The intrinsic ''toLocaleString'' method returns an
implementation-dependent string.

<IMPL> The intrinsic ''toLocaleString'' method is
implementation-dependent, and it is permissible, but not encouraged,
for it to return the same thing as the intrinsic ''toString'' method.

<NOTE> The first parameter to this function is likely to be used in a
future version of this standard; it is recommended that
implementations do not use this parameter position for anything else.

=== toJSONString ===

<DESC> The intrinsic ''toJSONString'' method convert this ''decimal''
object to JSON format (<CITE ref="RFC4627">RFC 4627</CITE>).

<RETN> The intrinsic ''toJSONString'' method returns a ''string''.

<SHORTIMPL>
<INCLUDE file="decimal.es" name="override intrinsic function toJSONString">


=== intrinsic::valueOf ( ) ===

<DESC> The intrinsic ''valueOf'' method returns the number value
represented by this ''decimal'' object: the object itself.

<RETN> The intrinsic ''valueOf'' method returns its ''this'' object.

<SHORTIMPL>
<INCLUDE file="decimal.es" name="override intrinsic function valueOf">


=== intrinsic::toFixed ( fractionDigits=<LDOTS> ) ===

<DESC> The intrinsic ''toFixed'' method converts this number value
to a string in fixed-point notation with //fractionDigits// digits
after the decimal point.  If //fractionDigits// is **undefined**, 0
is assumed.

<RETN> The intrinsic ''toFixed'' method returns the fixed-point
notation string representation of this number value.

<SHORTIMPL>
<INCLUDE file="decimal.es" name="intrinsic function toFixed">

<FIXME> (Ticket #188.) That implementation is bogus.

<P> An implementation is permitted to extend the behaviour of toFixed
for values of //fractionDigits// less than 0 or greater than 20.  In
this case ''toFixed'' would not necessarily throw **RangeError** for
such values.

<FIXME> (Ticket #188.) Greater number of fractionDigits is possible for decimal.

<NOTE>The output of ''toFixed'' may be more precise than ''toString''
for some values because ''toString'' only prints enough significant
digits to distinguish the number from adjacent number values. For
example, ''(1000000000000000128).toString()'' returns
"1000000000000000100", while ''(1000000000000000128).toFixed(0)''
returns "1000000000000000128".

<FIXME> (Ticket #188.) Better example / more precision (for decimal).

=== intrinsic::toExponential ( fractionDigits=<LDOTS> ) ===

<DESC> The intrinsic ''toExponential'' method converts this number value
to a string in exponential notation with one digit before the
significand's decimal point and //fractionDigits// digits after the
significand's decimal point.  If //fractionDigits// is **undefined**,
include as many significand digits as necessary to uniquely specify
the number (just like in ''ToString'' except that in this case the
number is always output in exponential notation).

<RETN> The static ''toExponential'' method returns the exponential
notation string representation of this number value.

<SHORTIMPL>
<INCLUDE file="decimal.es" name="intrinsic function toExponential">

<FIXME> (Ticket #188.) That implementation is bogus.

<P>An implementation is permitted to extend the behaviour of
''toExponential'' for values of //fractionDigits// less than 0 or
greater than 20.  In this case ''toExponential'' would not necessarily
throw **RangeError** for such values.

<FIXME> (Ticket #188.) Greater number of fractionDigits is possible for decimal.

<NOTE> For implementations that provide more accurate conversions than
required by the rules above, it is recommended that the following
alternative version of step 19 be used as a guideline:

<P class="note">Let e, n, and f be integers such that //f <GEQ> 0//,
//10<SUP>f</SUP> <LEQ> n <LT> 10<SUP>f+1</SUP>//, the number value for
//n <TIMES> 10<SUP>e-f</SUP>// is //x//, and //f// is as small as
possible.  If there are multiple possibilities for //n//, choose the
value of //n// for which //n <TIMES> 10<SUP>e-f</SUP>// is closest in
value to //x//.  If there are two such possible values of //n//,
choose the one that is even.

<FIXME> (Ticket #188.) "Step 19" is obsolete.


=== intrinsic::toPrecision ( precision=<LDOTS> ) ===

<DESC> The intrinsic ''toPrecision'' method converts this number value
to a string, either in exponential notation with one digit before the
significand's decimal point and //precision//-1 digits after the
significand's decimal point or in fixed notation with //precision//
significant digits.  If precision is **undefined**, call ''ToString''
(<XREF target="operator:ToString">) instead.

<RETN> The intrinsic ''toPrecision'' method returns the selected string
representation of this number value.

<SHORTIMPL>
<INCLUDE file="decimal.es" name="intrinsic function toPrecision">

<FIXME> (Ticket #188.) That implementation is bogus.

<P> An implementation is permitted to extend the behaviour of
''toPrecision'' for values of precision less than 1 or greater than
21.  In this case ''toPrecision'' would not necessarily throw
**RangeError** for such values.

<FIXME> (Ticket #188.) Greater precision possible for decimal.


<!-- End of decimal.html -->
