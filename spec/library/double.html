<H1 id="class double"> The class ''double'' </h1>

<pre>
FILE:                       spec/library/double.html
DRAFT STATUS:               DRAFT 1 - ROUGH - 2007-09-20
REVIEWED AGAINST ES3:       NO
REVIEWED AGAINST ERRATA:    NO
REVIEWED AGAINST BASE DOC:  NO
REVIEWED AGAINST PROPOSALS: NO
REVIEWED AGAINST CODE:      NO
</pre>


<P> The class ''double'' is a final, non-nullable, non-dynamic direct
subclass of ''Object'' that represents 64-bit ("double precision")
IEEE binary floating point number values in the range
-(1-(1/2)<SUP>53</SUP>) <TIMES> 2<SUP>1024</SUP> to
+(1-(1/2)<SUP>53</SUP>) <TIMES> 2<SUP>1024</SUP> inclusive
(approximately the range -1.7976931348623157 <TIMES> 10<SUP>308</SUP>
to +1.7976931348623157 <TIMES> 10<SUP>308</SUP>, inclusive), plus the
three special values -<INFINITY>, +<INFINITY>, and NaN.

<COMP> The class ''double'' is new in the 4th Edition of this
Standard, but ''double'' models the "number values" in the 3rd
Edition.


== Synopsis ==

<P> The class ''double'' provides the following interface:

{{{
final class double!
{
    <SIGNATURE file="double.es" name="function double">
    <SIGNATURE file="double.es" name="static meta function invoke">
    
    static const MAX_VALUE: double = <LDOTS>
    static const MIN_VALUE: double = <LDOTS>
    static const NaN: double = <LDOTS>
    static const NEGATIVE_INFINITY: double = <LDOTS>
    static const POSITIVE_INFINITY: double = <LDOTS>
    static const E: double = <LDOTS>
    static const LN10: double = <LDOTS>
    static const LN2: double = <LDOTS>
    static const LOG2E: double = <LDOTS>
    static const LOG10E: double = <LDOTS>
    static const PI: double = <LDOTS>
    static const SQRT1_2: double = <LDOTS>
    static const SQRT2: double = <LDOTS>
    static const length: uint = 1

    <SIGNATURE file="double.es" name="override intrinsic function toString">
    <SIGNATURE file="double.es" name="override intrinsic function toLocaleString">
    <SIGNATURE file="double.es" name="override intrinsic function toJSONString">
    <SIGNATURE file="double.es" name="override intrinsic function valueOf">

    <SIGNATURE file="double.es" name="intrinsic function toFixed">
    <SIGNATURE file="double.es" name="intrinsic function toExponential">
    <SIGNATURE file="double.es" name="intrinsic function toPrecision">
}
}}}

<P> The ''double'' prototype object is identical to the ''Number''
prototype object (<XREF target="Number.prototype">).

== Methods on the ''double'' class object ==

=== new double( value=<LDOTS> ) ===

<DESC>The ''double'' constructor initialises the newly created
''double'' object by storing an implementation-dependent
representation of the double-precision value of //value//, converted
to a number by the ToNumber operator, in a private property.  The
default //value// is 0.

<IMPL> The ''double'' constructor is implementation-dependent.

=== double( value=<LDOTS> ) ===

<DESC> When the ''double'' class object is called as a function it
performs a type conversion: it converts //value// (which defaults
to +0) to ''double''.

<RETN> The ''double'' class object called as a function returns
//value// converted to ''double''.

<SHORTIMPL>
<INCLUDE file="double.es" name="static meta function invoke">

<FIXME> (Ticket #176.)  The optimization used here, ''magic::newDouble'' for ''new
double'', makes the spec harder than it needs to be.

== Value properties on the ''double'' class object ==

=== MAX_VALUE ===

<P> The value of ''MAX_VALUE'' is the largest positive finite value
represented by the ''double'' class, type, which is
approximately 1.7976931348623157 <TIMES> 10<SUP>308</SUP>.

=== MIN_VALUE ===

<P> The value of ''MIN_VALUE'' is the smallest positive value
represented by the ''double'' class, which is approximately 5 <TIMES>
10<SUP>-324</SUP>.

=== NaN ===

<P> The value of ''NaN'' is the not-a-number value represented by a
''double'' instance.

=== NEGATIVE_INFINITY ===

<P> The value of ''NEGATIVE_INFINITY'' is the value -<INFINITY> as
represented by a ''double'' instance.

=== POSITIVE_INFINITY ===

<P> The value of ''POSITIVE_INFINITY'' is the value +<INFINITY> as
represented by a ''double'' instance.

=== E ===

<P> The value of ''E'' is the ''double'' value for //e//, the base of the
natural logarithms, which is approximately 2.7182818284590452354.

=== LN10 ===

<P>The value of ''LN10'' is the ''double'' value for the natural
logarithm of 10, which is approximately 2.302585092994046.

=== LN2 ===

<P>The value of ''LN2'' is the ''double'' value for the natural
logarithm of 2, which is approximately 0.6931471805599453.

=== LOG2E ===

<P>The value of ''LOG2E'' is the ''double'' value for the base-2
logarithm of //e//, the base of the natural logarithms; this value is
approximately 1.4426950408889634.

<NOTE> The value of ''double.LOG2E'' is approximately the reciprocal
of the value of ''double.LN2''.

=== LOG10E ===

<P>The value of ''LOG10E'' is the double value for the base-10
logarithm of //e//, the base of the natural logarithms; this value is
approximately 0.4342944819032518.

<NOTE> The value of ''double.LOG10E'' is approximately the reciprocal
of the value of ''double.LN10''.

=== PI ===

<P>The value of ''PI'' is the ''double'' value for <PI>, the ratio of
the circumference of a circle to its diameter, which is approximately
3.1415926535897932.

=== SQRT1_2 ===

<P>The value of ''SQRT1_2'' is the ''double'' value for the square
root of 1/2, which is approximately 0.7071067811865476.

<NOTE> The value of ''double.SQRT1_2'' is approximately the reciprocal
of the value of ''double.SQRT2''.

=== SQRT2 ===

<P>The value of ''SQRT2'' is the ''double'' value for the square root
of 2, which is approximately 1.4142135623730951.


== Methods on ''double'' instances ==

=== intrinsic::toString ( radix=<LDOTS> ) ===

<DESC> The intrinsic ''toString'' method converts this number value
to a string representation in a base given by //radix//.

<P> If radix is the number 10 or undefined, then the result is as for
the ''ToString'' operator.

<P> If radix is an integer from 2 to 36, but not 10, the result is an
implementation-dependent string

<RETN> The intrinsic ''toString'' method returns a string.

<SHORTIMPL>
<INCLUDE file="double.es" name="override intrinsic function toString">


=== intrinsic::toLocaleString ( ) ===

<DESC> The intrinsic ''toLocaleString'' method converts this number
value to a string value that represents the value of the integer
formatted according to the conventions of the host environment's
current locale.

<RETN> The intrinsic ''toLocaleString'' method returns an
implementation-dependent string.

<IMPL> The intrinsic ''toLocaleString'' method is
implementation-dependent, and it is permissible, but not encouraged,
for it to return the same thing as the intrinsic ''toString'' method.

<NOTE> The first parameter to this function is likely to be used in a
future version of this standard; it is recommended that
implementations do not use this parameter position for anything else.

=== toJSONString ===

<DESC> The intrinsic ''toJSONString'' method convert this ''double''
object to JSON format (<CITE ref="RFC4627">RFC 4627</CITE>).

<RETN> The intrinsic ''toJSONString'' method returns a ''string''.

<SHORTIMPL>
<INCLUDE file="double.es" name="override intrinsic function toJSONString">


=== intrinsic::valueOf ( ) ===

<DESC> The intrinsic ''valueOf'' method returns the number value
represented by this ''double'' object: the object itself.

<RETN> The intrinsic ''valueOf'' method returns its ''this'' object.

<SHORTIMPL>
<INCLUDE file="double.es" name="override intrinsic function valueOf">


=== intrinsic::toFixed ( fractionDigits=<LDOTS> ) ===

<DESC> The intrinsic ''toFixed'' method converts the this number value
to a string in fixed-point notation with //fractionDigits// digits
after the decimal point.  If //fractionDigits// is **undefined**, 0
is assumed.

<RETN> The intrinsic ''toFixed'' method returns the fixed-point
notation string representation of this number value.

<SHORTIMPL>
<INCLUDE file="double.es" name="intrinsic function toFixed">

<FIXME> (Ticket #184.) Note that calling anything "step 10" no longer
makes sense.

<p class="fixme"> Note also that "step 10" is informative and needs to
be documented and implemented as such.

<P> An implementation is permitted to extend the behaviour of toFixed
for values of //fractionDigits// less than 0 or greater than 20.  In
this case ''toFixed'' would not necessarily throw **RangeError** for
such values.

<NOTE>The output of ''toFixed'' may be more precise than ''toString''
for some values because ''toString'' only prints enough significant
digits to distinguish the number from adjacent number values. For
example, ''(1000000000000000128).toString()'' returns
"1000000000000000100", while ''(1000000000000000128).toFixed(0)''
returns "1000000000000000128".


=== intrinsic::toExponential ( fractionDigits=<LDOTS> ) ===

<DESC> The intrinsic ''toExponential'' method converts this number value
to a string in exponential notation with one digit before the
significand's decimal point and //fractionDigits// digits after the
significand's decimal point.  If //fractionDigits// is **undefined**,
include as many significand digits as necessary to uniquely specify
the number (just like in ''ToString'' except that in this case the
number is always output in exponential notation).

<RETN> The intrinsic ''toExponential'' method returns the exponential
notation string representation of this number value.

<SHORTIMPL>
<INCLUDE file="double.es" name="intrinsic function toExponential">

<FIXME> (Ticket #185.) Implement this function.

<P>An implementation is permitted to extend the behaviour of
''toExponential'' for values of //fractionDigits// less than 0 or
greater than 20.  In this case ''toExponential'' would not necessarily
throw **RangeError** for such values.

<NOTE> For implementations that provide more accurate conversions than
required by the rules above, it is recommended that the following
alternative version of step 19 be used as a guideline:

<P class="note">Let e, n, and f be integers such that //f <GEQ> 0//,
//10<SUP>f</SUP> <LEQ> n <LT> 10<SUP>f+1</SUP>//, the number value for
//n <TIMES> 10<SUP>e-f</SUP>// is //x//, and //f// is as small as
possible.  If there are multiple possibilities for //n//, choose the
value of //n// for which //n <TIMES> 10<SUP>e-f</SUP>// is closest in
value to //x//.  If there are two such possible values of //n//,
choose the one that is even.

<FIXME> (Ticket #186.) "Step 19" is obsolete.

=== intrinsic::toPrecision ( precision=<LDOTS> ) ===

<DESC> The intrinsic ''toPrecision'' method converts this number value
to a string, either in exponential notation with one digit before the
significand's decimal point and //precision//-1 digits after the
significand's decimal point or in fixed notation with //precision//
significant digits.  If precision is **undefined**, call ''ToString''
(<XREF target="operator:ToString">) instead.

<RETN> The intrinsic ''toPrecision'' method returns the selected
string representation of this number value.

<SHORTIMPL>
<INCLUDE file="double.es" name="intrinsic function toPrecision">

<FIXME> (Ticket #185.) Implement this function.

<P> An implementation is permitted to extend the behaviour of
''toPrecision'' for values of precision less than 1 or greater than
21.  In this case ''toPrecision'' would not necessarily throw
**RangeError** for such values.

<!-- End of double.html -->
