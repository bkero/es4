= The Global Object =

<pre>
FILE:                       spec/library/global.html
DRAFT STATUS:               DRAFT 1 - ROUGH - 2007-09-20
REVIEWED AGAINST ES3:       NO
REVIEWED AGAINST ERRATA:    NO
REVIEWED AGAINST BASE DOC:  NO
REVIEWED AGAINST PROPOSALS: NO
REVIEWED AGAINST CODE:      NO
</pre>

<P> The global object is an instance of an implementation-dependent
class.  In particular, its the name of this class and the contents of
the class's prototype object are implementation-dependent.

<P> The class describing the global object does not have an accessible
constructor function; it is not possible to use the global object as a
constructor with the ''new'' operator.

<p> The class describing the global object does not have a
''meta::invoke'' method; it is not possible to call the global object
as a function.

== Synopsis ==

<p>The global object contains the following properties, functions,
types, and class definitions.

{{{
namespace __ES4__

class Object <LDOTS>
class Function <LDOTS>
class Array <LDOTS>
class String <LDOTS>
class Boolean <LDOTS>
class Number <LDOTS>
class Date <LDOTS>
class RegExp <LDOTS>
class Error <LDOTS>
class EvalError <LDOTS>
class RangeError <LDOTS>
class ReferenceError <LDOTS>
class SyntaxError <LDOTS>
class TypeError <LDOTS>
class URIError <LDOTS>

__ES4__ class string <LDOTS>
__ES4__ class boolean
__ES4__ class int <LDOTS>
__ES4__ class uint <LDOTS>
__ES4__ class double <LDOTS>
__ES4__ class decimal <LDOTS>
__ES4__ class Name <LDOTS>
__ES4__ class Namespace <LDOTS>
__ES4__ class ByteArray <LDOTS>
__ES4__ class Map.<K,V> <LDOTS>
__ES4__ class Vector.<T> <LDOTS>
__ES4__ class EncodingError <LDOTS>

__ES4__ type EnumerableId = <LDOTS>
__ES4__ type Numeric = <LDOTS>
__ES4__ type Strings = <LDOTS>
__ES4__ type Booleans = <LDOTS>

__ES4__ namespace intrinsic = <LDOTS>

intrinsic interface Field <LDOTS>
intrinsic interface FieldValue <LDOTS>
intrinsic interface Type <LDOTS>
intrinsic interface NominalType <LDOTS>
intrinsic interface InterfaceType <LDOTS>
intrinsic interface ClassType <LDOTS>
intrinsic interface AnyType <LDOTS>
intrinsic interface NullType <LDOTS>
intrinsic interface UndefinedType <LDOTS>
intrinsic interface UnionType <LDOTS>
intrinsic interface RecordType <LDOTS>
intrinsic interface FunctionType <LDOTS>
intrinsic interface ArrayType <LDOTS>

intrinsic type FieldIterator = <LDOTS>
intrinsic type FieldValueIterator = <LDOTS>
intrinsic type TypeIterator = <LDOTS>
intrinsic type InterfaceIterator = <LDOTS>

intrinsic class ControlInspector.<T> <LDOTS>

const NaN: double = <LDOTS>
const Infinity: double = <LDOTS>
const undefined: undefined = <LDOTS>
const __ECMASCRIPT_VERSION__ = <LDOTS>
const Math: Object = <LDOTS>

__ES4__ const global: Object = <LDOTS>

intrinsic function eval(s: string) <LDOTS>
intrinsic function parseInt(s: string, r: (int,undefined)=undefined): Numeric <LDOTS>
intrinsic function parseFloat(s: string): Numeric <LDOTS>
intrinsic function isNaN(n: Numeric): boolean <LDOTS>
intrinsic function isFinite(n: Numeric): boolean <LDOTS>
intrinsic function decodeURI(s: string): string <LDOTS>
intrinsic function decodeURIComponent(s: string): string <LDOTS>
intrinsic function encodeURI(s: string): string <LDOTS>
intrinsic function encodeURIComponent(s: string): string <LDOTS>
intrinsic function hashcode(x): uint <LDOTS>

function eval(x) <LDOTS>
function parseInt(s, r=undefined) <LDOTS>
function parseFloat(s) <LDOTS>
function isNaN(x) <LDOTS>
function isFinite(x) <LDOTS>
function decodeURI(x) <LDOTS>
function decodeURIComponent(x) <LDOTS>
function encodeURI(x) <LDOTS>
function encodeURIComponent(x) <LDOTS>

__ES4__ function hashcode(x) <LDOTS>
}}}

== Namespace for types ==

<p> All new classes and type definitions in the global object are
defined in the namespace ''__ES4__''.  This namespace is automatically
opened by the implementation for code that is to be treated as 4th
Edition code, but not for code that is to be treated as 3rd Edition
code.

<NOTE> The risk of polluting the name space for 3rd Edition code with
new names is deemed too great to always open the ''__ES4__'' name
space.

<p> The means by which an implementation determines whether to treat
code according to 3rd Edition or 4th Edition is outside the scope of
this Standard.

<NOTE> This standard makes recommendations for how mime types should
be used to tag script content in a web browser.  See <XREF
target="appendix-mime-types">.


== Value Properties of the Global Object ==

=== NaN ===

<P>The value of ''NaN'' is **NaN** (section 8.5).

<COMP>This property was not marked ReadOnly in 3rd Edition.

=== Infinity ===

<P>The value of ''Infinity'' is +<INFINITY> (section 8.5).

<COMP>This property was not marked ReadOnly in 3rd Edition.

=== undefined ===

<P>The value of undefined is **undefined** (section 8.1).

<COMP>This property was not marked ReadOnly in 3rd Edition.

=== __ECMASCRIPT_VERSION__ ===

<P>The value of ''__ECMASCRIPT_VERSION__'' is the version of this
Standard to which the implementation conforms.  For this 4th Edition
of the Standard, the value of ''__ECMASCRIPT_VERSION__'' is 4.

<NOTE>This property is new in 4th Edition.


== Function Properties of the Global Object ==

=== eval ===

==== The ''eval'' operator ====

<DESC> When the intrinsic and non-intrinsic ''eval'' functions are called
directly by name (that is, by the explicit use of the name ''eval'' as
an unqualified Identifier which is the MemberExpression in a
CallExpression) they are treated like operators in the language.  See
<XREF target="eval-operator">.

<RETN> The ''eval'' operator returns an ECMAScript value.

==== intrinsic::eval (s) ====

<DESC> When the intrinsic ''eval'' function is called as a method on
the global objects in whose scope it is closed then it evaluates its
argument as a program in the global scope that is the receiver object
in the call.

<p> When the intrinsic ''eval'' function is called as an ordinary
function under other names than ''eval'' then it evaluates its
argument as a program in a global scope that is the scope in which the
''eval'' function was closed.

<RETN> The intrinsic ''eval'' function returns the value computed by
the program that's evaluated.

<IMPL> The ''eval'' method is implementation-dependent.

==== eval (s) ====

<DESC> The non-intrinsic ''eval'' function can be called as a method
on the global object in whose scope it is closed, or it can be called
as an ordinary function under another name, just like the intrinsic
''eval'' function.

<P> If the argument to ''eval'' is a string, then the program
represented by that string is evaluated.  Otherwise the argument is
returned unchanged.

<INCLUDE file="Global.es" name="function eval">

<NOTE> The behavior of this function depends on the fact that the
non-intrinsic ''eval'' function is closed in the same global object as
the intrinsic ''eval'' function.  Thus there's no need to capture and
pass the ''this'' parameter.

==== Restrictions on the use of the ''eval'' property  ====

<p> If the value of the ''eval'' property is used in any way other
than than the three listed previously, or if the ''eval'' property is
assigned to, an ''EvalError'' exception may be thrown.

<COMP> The 3rd Edition of this Standard restricted the use of ''eval''
to the first case listed previously.


=== intrinsic::parseInt (s, r=<LDOTS>) ===

<DESC> The intrinsic ''parseInt'' function computes an integer value
dictated by interpretation of the contents of the string argument
//s// according to the specified radix //r// (which defaults to zero).  Leading whitespace in
//s// is ignored.  If //r// is zero, it is assumed to be 10 except when
the number begins with the character pairs 0x or 0X, in which case a
radix of 16 is assumed.  Any radix-16 number may also optionally begin
with the character pairs 0x or 0X.

<RETN> The intrinsic ''parseInt'' function returns a number.

<SHORTIMPL>
<INCLUDE file="Global.es" name="intrinsic function parseInt">

<P> The helper function ''isDigitForRadix(c,r)'' computes whether
''c'' is a valid digit for the radix ''r'', see <XREF
target="helper:isDigitForRadix">.

<p>The informative function ''numericValue(s, r)'' computes the
numeric value of a radix-''r'' string ''s''.  If ''r'' is 10 and ''s''
contains more than 20 significant digits, every significant digit
after the 20th may be replaced by a 0 digit, at the option of the
implementation; and if ''r'' is not 2, 4, 8, 10, 16, or 32, then the
returned value may be an implementation-dependent approximation to the
mathematical integer value that is represented by ''s'' in radix-''r''
notation.

<COMP>In the 3rd Edition of this Standard, the ''parseInt'' function was
allowed to, though not encouraged to, interpret a string with a
leading ''0'' but no leading ''0x'' or ''0X'' as a base-8 number if
the radix was not supplied in the call or was supplied as zero.  This
is no longer allowed; the function must interpret such a number as a
base-10 number.

<NOTE>''parseInt'' may interpret only a leading portion of the string as an
integer value; it ignores any characters that cannot be interpreted as
part of the notation of an integer, and no indication is given that
any such characters were ignored.

<h4 id="helper:isDigitForRadix">isDigitForRadix </h4>

<INCLUDE file="Global.es" name="helper function isDigitForRadix">


=== parseInt ( s, r=<LDOTS> ) ===

<DESC>The ''parseInt'' function converts its first argument to
''string'' and its second argument to ''int'', and then calls its
intrinsic counterpart.

<RETN>The ''parseInt'' function returns a number.

<SHORTIMPL>
<INCLUDE file="Global.es" name="function parseInt">


=== intrinsic::parseFloat (s) ===

<DESC>The intrinsic ''parseFloat'' function computes a number value
dictated by interpretation of the contents of the string argument //s// as a
decimal literal.

<RETN> The intrinsic ''parseFloat'' function returns a number.

<SHORTIMPL>
<INCLUDE file="Global.es" name="intrinsic function parseFloat">

<NOTE>''parseFloat'' may interpret only a leading portion of //s// as a
number value; it ignores any characters that cannot be interpreted as
part of the notation of an decimal literal, and no indication is given
that any such characters were ignored.

=== parseFloat (s) ===

<DESC>The ''parseFloat'' function converts its argument to ''string'',
then calls its intrinsic counterpart.

<RETN>The ''parseFloat'' function returns a number.

<SHORTIMPL>
<INCLUDE file="Global.es" name="function parseFloat">


=== intrinsic::isNaN (number) ===

<DESC>The intrinsic ''isNaN'' function tests whether a numeric value //number// is an
IEEE not-a-number value.

<RETN>The intrinsic ''isNaN'' function returns 
**true** if //number// is **NaN**, and otherwise returns **false**.

<SHORTIMPL>
<INCLUDE file="Global.es" name="intrinsic function isNaN">

=== isNaN (number) ===

<DESC>The ''isNaN'' function converts its argument to a number, then
calls its intrinsic counterpart.

<RETN>The ''isNaN'' function returns **true** if //number// is
**NaN**, and otherwise returns **false**.

<SHORTIMPL>
<INCLUDE file="Global.es" name="function isNaN">


=== intrinsic::isFinite (number) ===

<DESC>The intrinsic ''isFinite'' function tests whether a numeric value //number// is
finite (neither not-a-number nor an infinity).

<RETN>The intrinsic ''isFinite'' function returns **true** if //number// is
finite, and otherwise returns **false**.

<SHORTIMPL>
<INCLUDE file="Global.es" name="intrinsic function isFinite">


=== isFinite (number) ===

<DESC>The ''isFinite'' function converts its argument to a number,
then calls its intrinsic counterpart.

<RETN>The ''isFinite'' function returns **true** if //number// is
finite, and otherwise returns **false**.

<SHORTIMPL>
<INCLUDE file="Global.es" name="function isFinite">


=== URI Handling Function Properties ===

<p>Uniform Resource Identifiers, or URIs, are strings that identify
resources (e.g. web pages or files) and transport protocols by which
to access them (e.g. HTTP or FTP) on the Internet. The ECMAScript
language itself does not provide any support for using URIs except for
functions that encode and decode URIs as described in sections <XREF
target="decodeURI">, <XREF target="decodeURIComponent">, <XREF
target="encodeURI">, and <XREF target="encodeURIComponent">.

<NOTE>Many implementations of ECMAScript provide additional
functions and methods that manipulate web pages; these functions are
beyond the scope of this standard.

<p>A URI is composed of a sequence of components separated by component separators. The general form is:
<div class="indented">
//Scheme '':'' First ''/'' Second '';'' Third ''?'' Fourth//
</div>

<p>where the italicised names represent components and the ":", "/",
";" and "?" are reserved characters used as separators.  The
''encodeURI'' and ''decodeURI'' functions are intended to work with
complete URIs; they assume that any reserved characters in the URI are
intended to have special meaning and so are not encoded.  The
''encodeURIComponent'' and ''decodeURIComponent'' functions are
intended to work with the individual component parts of a URI; they
assume that any reserved characters represent text and so must be
encoded so that they are not interpreted as reserved characters when
the component is part of a complete URI.  The following lexical
grammar specifies the form of encoded URIs.

<div class="grammar">
<div class="nonterm">uri :::</div>
<div class="indented">uriCharacters<sub>opt</sub></div>

<div class="nonterm">uriCharacters :::</div>
<div class="indented">uriCharacter uriCharacters<sub>opt</sub></div>

<div class="nonterm">uriCharacter :::</div>
<div class="indented">uriReserved<br>
uriUnescaped<br>
uriEscaped</div>

<div class="nonterm">uriReserved ::: **one of**</div>
<div class="indented">''; / ? : @ & = + $ ,''</div>

<div class="nonterm">uriUnescaped :::</div>
<div class="indented">uriAlpha<br>
DecimalDigit<br>
uriMark</div>

<div class="nonterm">uriEscaped :::</div>
<div class="indented">% HexDigit HexDigit</div>

<div class="nonterm">uriAlpha ::: **one of**</div>
<div class="indented">''a b c d e f g h i j k l m n o p q r s t u v w x y z''<br>
''A B C D E F G H I J K L M N O P Q R S T U V W X Y Z''</div>

<div class="nonterm">uriMark ::: **one of**</div>
<div class="indented">''- _ . ! ~ * ' ( )''</div>
</div>

<FIXME> (Ticket #170.)  Upgrade to Unicode 5 in the following
sections, and upgrade to handling the entire (21-bit) Unicode
character set.

<p>When a character to be included in a URI is not listed above or is
not intended to have the special meaning sometimes given to the
reserved characters, that character must be encoded. The character is
first transformed into a sequence of octets using the UTF-8
transformation, with surrogate pairs first transformed from their
UCS-2 to UCS-4 encodings. (Note that for code points in the range
[0,127] this results in a single octet with the same value.)  The
resulting sequence of octets is then transformed into a string with
each octet represented by an escape sequence of the form "''%xx''".

<p>The encoding and escaping process is described by the helper
function ''encode'' taking two string arguments ''s'' and
''unescapedSet''.

<INCLUDE file="Global.es" name="helper function encode">
<INCLUDE file="Global.es" name="helper function twoHexDigits">

<p>The unescaping and decoding process is described by the helper
function ''decode'' taking two string arguments ''s'' and
''reservedSet''.

<INCLUDE file="Global.es" name="helper function decode">
<INCLUDE file="Global.es" name="helper function decodeHexEscape">

<p>The helper function ''isDigitForRadix'' was defined in section
<XREF target="helper:isDigitForRadix">.

<NOTE>The syntax of Uniform Resource Identifiers is given in
RFC2396.

<NOTE>A formal description and implementation of UTF-8 is
given in the Unicode Standard, Version 2.0, Appendix A.  In UTF-8,
characters are encoded using sequences of 1 to 6 octets. The only
octet of a "sequence" of one has the higher-order bit set to 0, the
remaining 7 bits being used to encode the character value. In a
sequence of n octets, n>1, the initial octet has the n higher-order
bits set to 1, followed by a bit set to 0. The remaining bits of that
octet contain bits from the value of the character to be encoded. The
following octets all have the higher-order bit set to 1 and the
following bit set to 0, leaving 6 bits in each to contain bits from
the character to be encoded. The possible UTF-8 encodings of
ECMAScript characters are:

<center>
<table border="1">
  <tr><th>Code Point Value</th><th>Representation</th>    <th>1st Octet</th><th>2nd Octet</th><th>3rd Octet</th><th>4th Octet</th></tr>
  <tr><td>0x0000 - 0x007F</td> <td>00000000 0zzzzzzz</td> <td>0zzzzzzz</td></tr>
  <tr><td>0x0080 - 0x07FF</td> <td>00000yyy yyzzzzzz</td> <td>110yyyyy</td> <td>10zzzzzz</td></tr>
  <tr><td>0x0800 - 0xD7FF</td> <td>xxxxyyyy yyzzzzzz</td> <td>1110xxxx</td> <td>10yyyyyy</td><td>10zzzzzz</td></tr>
  <tr><td>0xD800 - 0xDBFF<br>
          followed by<br>
          0xDC00 - 0xDFFF</td> <td>110110vv vvwwwwxx<br>
                                   followed by<br>
                                   110111yy yyzzzzzz</td> <td>11110uuu</td> <td>10uuwwww</td> <td>10xxyyyy</td> <td>10zzzzzz</td></tr>
  <tr><td>0xD800 - 0xDBFF<br>
      not followed by<br>
      0xDC00 - 0xDFFF</td>     <td>causes URIError</td></tr>
  <tr><td>0xDC00 - 0xDFFF</td> <td>causes URIError</td></tr>
  <tr><td>0xE000 - 0xFFFF</td> <td>xxxxyyyy yyzzzzzz</td> <td>1110xxxx</td> <td>10yyyyyy</td> <td>10zzzzzz</td></tr>
</table>
</center>

<p>Where
<div class="indented">uuuuu = vvvv + 1</div>
<p>to account for the addition of 0x10000 as in section 3.7,
Surrogates of the Unicode Standard version 2.0.

<p>The range of code point values 0xD800-0xDFFF is used to encode
surrogate pairs; the above transformation combines a UCS-2 surrogate
pair into a UCS-4 representation and encodes the resulting 21-bit
value in UTF-8. Decoding reconstructs the surrogate pair.

<p>The helper functions ''encode'' and ''decode'', defined above, use
the helper functions ''toUTF8'' and ''fromUTF8'' to convert code
points to UTF-8 sequences and to convert UTF-8 sequences to code
points, respectively.

<INCLUDE file="Global.es" name="helper function toUTF8">
<INCLUDE file="Global.es" name="helper function fromUTF8">

<p>Several helper strings are defined based on the grammar shown
previously:

<INCLUDE file="Global.es" name="helper const uriReserved">
<INCLUDE file="Global.es" name="helper const uriAlpha">
<INCLUDE file="Global.es" name="helper const uriDigit">
<INCLUDE file="Global.es" name="helper const uriMark">
<INCLUDE file="Global.es" name="helper const uriUnescaped">


==== intrinsic::decodeURI (encodedURI) ====

<DESC> The intrinsic ''decodeURI'' function computes a new version of
a URI in which each escape sequence and UTF-8 encoding of the sort
that might be introduced by the ''encodeURI'' function is replaced
with the character that it represents.  Escape sequences that could
not have been introduced by ''encodeURI'' are not replaced.

<RETN> The intrinsic ''decodeURI'' function returns a decoded string.

<SHORTIMPL>
<INCLUDE file="Global.es" name="intrinsic function decodeURI">

<NOTE>The character "''#''" is not decoded from escape sequences even
though it is not a reserved URI character.

==== decodeURI (encodedURI) ====

<DESC>The ''decodeURI'' function converts its argument to ''string'', then
calls its intrinsic counterpart.

<RETN> The ''decodeURI'' function returns a decoded string.

<SHORTIMPL>
<INCLUDE file="Global.es" name="function decodeURI">


==== intrinsic::decodeURIComponent (encodedURIComponent) ====

<DESC> The intrinsic ''decodeURIComponent'' function computes a new
version of a URI in which each escape sequence and UTF-8 encoding of
the sort that might be introduced by the ''encodeURIComponent''
function is replaced with the character that it represents.

<RETN> The intrinsic ''decodeURIComponent'' function returns a decoded string.

<SHORTIMPL>
<INCLUDE file="Global.es" name="intrinsic function decodeURIComponent">

==== decodeURIComponent (encodedURIComponent) ====

<DESC>The ''decodeURIComponent'' function converts its argument to
''string'', then calls its intrinsic counterpart.

<RETN> The ''decodeURIComponent'' function returns a decoded string.

<SHORTIMPL>
<INCLUDE file="Global.es" name="function decodeURIComponent">


==== intrinsic::encodeURI (uri) ====

<DESC> The intrinsic ''encodeURI'' function computes a new version of
a URI in which each instance of certain characters is replaced by one,
two or three escape sequences representing the UTF-8 encoding of the
character.

<RETN> The intrinsic ''encodeURI'' function returns a encoded string.

<SHORTIMPL>
<INCLUDE file="Global.es" name="intrinsic function encodeURI">

<NOTE>The character "''#''" is not encoded to an escape sequence
even though it is not a reserved or unescaped URI character.

==== encodeURI (uri) ====

<DESC>The ''encodeURI'' function converts its argument to string, then
calls its intrinsic counterpart.

<RETN> The ''encodeURI'' function returns a encoded string.

<SHORTIMPL>
<INCLUDE file="Global.es" name="function encodeURI">


==== intrinsic::encodeURIComponent (uriComponent) ====

<DESC> The intrinsic ''encodeURIComponent'' function computes a new
version of a URI in which each instance of certain characters is
replaced by one, two or three escape sequences representing the UTF-8
encoding of the character.

<RETN> The intrinsic ''encodeURIComponent'' function returns a encoded string.

<SHORTIMPL>
<INCLUDE file="Global.es" name="intrinsic function encodeURIComponent">

==== encodeURIComponent (uriComponent) ====

<DESC>The ''encodeURIComponent'' function converts its
argument to string, then calls its intrinsic counterpart.

<RETN> The ''encodeURIComponent'' function returns a encoded string.

<SHORTIMPL>
<INCLUDE file="Global.es" name="function encodeURIComponent">


=== intrinsic::hashcode (x) ===

<!-- [[proposals:hashcodes]] -->

<DESC> The intrinsic ''hashcode'' function computes a numeric value
for its argument such that if two values ''v1'' and ''v2'' are equal
by the operator ''intrinsic::==='' then ''hashcode(v1)'' is
numerically equal to ''hashcode(v2)''.

<P> The hashcode of any value for which ''isNaN'' returns **true** is
zero.

<P> The hashcode computed for an object does not change over time.

<RETN> The intrinsic ''hashcode'' function returns an unsigned integer.

<SHORTIMPL>
<INCLUDE file="Global.es" name="__ES4__ const function hashcode">

<P> The informative functions ''stringHash'' and ''objectHash''
compute hash values for strings and arbitrary objects, respectively.
They can take into account their arguments' immutable structure only.

<P> The implementation should strive to compute different hashcodes
for objects that are not the same by ''intrinsic::==='', as the
utility of this function depends on that property.  (The user program
should be able to expect that the hashcodes of objects that are not
the same are different with high probability.)

<NOTE> A typical implementation of ''stringHash'' will make use of the
string's character sequence and its length.

<NOTE> A typical implementation of ''objectHash'' may make use of the
object's address in memory if the object, or it may maintain a
separate table mapping objects to hash codes.

<IMPLNOTE>The intrinsic ''hashcode'' function should not return
pointer values cast to integers, even in implementations that do not
use a moving garbage collector.  Exposing memory locations of objects
may make security vulnerabilities in the host environment
significantly worse.  Implementations -- in particular those which
read network input -- should return numbers unrelated to memory
addresses if possible, or at least use memory addresses subject to
some cryptographically strong one-way transformation, or sequence
numbers, cookies, or similar.

<!--

=== Operator functions ===

<P> These are defined as implementing the primitive functionality of each
operator, bypassing any user overloading.  They can be referenced by
prefixing them with a namespace, eg ''intrinsic::===''.

<P> These may be obsolete now that we've killed the operator
overloading proposal and not yet accepted the generic function proposal.

-->

== Class and Interface Properties of the Global Object ==

<p>The class properties of the global object are defined in later sections of this Standard:
<ul>
  <li> The ''Object'' class is defined in section <XREF target="class Object">
  <li> The ''Function'' class is defined in section <XREF target="class Function">
  <li> The ''Name'' class is defined in section <XREF target="class Name">
  <li> The ''Namespace'' class is defined in section <XREF target="class Namespace">
  <li> The ''Array'' class is defined in section <XREF target="class Array">
  <li> The ''String'' and ''string'' classes are defined in sections <XREF target="class String"> and <XREF target="class string">, respectively.
  <li> The ''Boolean'' and ''boolean'' classes are defined in sections <XREF target="class Boolean"> and <XREF target="class boolean">, respectively.
  <li> The ''Number'', ''int'', ''uint'', ''double'', and ''decimal'' classes are defined in sections <XREF target="class Number">, <XREF target="class int">, <XREF target="class uint">, <XREF target="class double">, and <XREF target="class decimal">, respectively.
  <li> The ''Date'' class is defined in section <XREF target="class Date">
  <li> The ''RegExp'' class is defined in section <XREF target="class RegExp">
  <li> The ''Map'' class is defined in section <XREF target="class Map">
  <li> The ''Vector'' class is defined in section <XREF target="class Vector">
  <li> The ''ByteArray'' class is defined in section <XREF target="class ByteArray">
  <li> The ''ControlInspector'' class is defined in section <XREF target="class ControlInspector">
  <li> The ''Error'' class and its subclasses ''EvalError'', ''RangeError'', ''ReferenceError'', ''SyntaxError'', ''TypeError'', and ''URIError'' are defined in sections <XREF target="class Error">, <XREF target="class EvalError">, <XREF target="class RangeError">, <XREF target="class ReferenceError">,  <XREF target="class SyntaxError">, <XREF target="class TypeError">, and <XREF target="class URIError">, respectively.
</ul>



== Type Properties on the Global Object ==

=== EnumerableId ===

<p>The type ''EnumerableId'' is a union type that collects all nominal
types that are treated as property names by the iteration protocol and the
built-in objects:

{{{
__ES4__ type EnumerableId = (int,uint,Name,string);
}}}

=== Numeric ===

<p>The type ''Numeric'' is a union type that collects all nominal
types that are treated as numbers by the implementation:

{{{
__ES4__ type Numeric = (int,uint,double,decimal,Number);
}}}


== Meta-Object Interface and Type Properties of the Global Object ==

<P> The interface types ''Field'', ''FieldValue'', ''Type'',
''NominalType'', ''InterfaceType'', ''ClassType'', ''UnionType'',
''RecordType'', ''FunctionType'', and ''ArrayType'', as well as the
structural types ''FieldIterator'', ''FieldValueIterator'',
''TypeIterator'', and ''InterfaceIterator'', are defined in section
<XREF target="meta-objects">.


== Other Properties of the Global Object ==

=== Math ===

<P> See section <XREF target="math-object">.

<FIXME> (Ticket #171.) Currently we have a single ''const'' math
object that has some intrinsic fixture methods and some nonintrinsic
dynamic methods, as per E262-3.  When the user opens ''intrinsic'' the
intrinsic methods will be perferred, but only because the
implementation knows the type of the Math object in the global
environment.  This type is not exposed in the spec.  Thus the math
object can't be passed around as a strongly typed parameter (should we
wish for it).

<P class="fixme"> Alternative approaches are to (a) expose that type
and (b) separate the intrinsic bindings from the nonintrinsic global
bindings by having two bindings for Math, one of them intrinsic, the
other not.  (And in case (b) we'd expose that type, and it'd be final
and nondynamic.)

=== global ===

<!-- [[proposals:globals]] -->

<p>The intrinsic ''global'' property holds a reference to the global
object that contains that property.

<NOTE>There may be multiple global objects in a program, but these
objects may share values or immutable state: for example, their
''isNaN'' properties may hold the same function object.  However, each
global object has separate mutable state, and a separate value for the
intrinsic ''global'' property.

<NOTE>This property is new in 4th Edition.

<!-- End of global.html -->
