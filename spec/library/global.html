= The Global Object =

<HR>
<pre>
NAME:                       "The global object"
FILE:                       spec/library/global.html
CATEGORY:                   Pre-defined objects (E262-3 Chapter 15)
SOURCES:                    See REFERENCES section below
SPEC AUTHOR:                Lars
DRAFT STATUS:               DRAFT 2 - 2008-03-17
REVIEWED AGAINST ES3:       NO
REVIEWED AGAINST ERRATA:    YES
REVIEWED AGAINST BASE DOC:  YES
REVIEWED AGAINST PROPOSALS: NO
REVIEWED AGAINST CODE:      YES
REVIEWED AGAINST TICKETS:   NO
IMPLEMENTATION STATUS:      ?
TEST CASE STATUS:           ?

CHANGES SINCE DRAFT 1 (2008-03-12)

  * Fixed a bug in the definition of 'AnyBoolean'

  * 'intrinsic::hashcode' now handles 'Name' and 'Namespace' objects
    specially (since '===' does, see drafts for 'Name' and 'Namespace')

  * Added a definition for the type 'Callable' (ticket #153)

  * Added a restriction to the 'eval' operator, preventing it from
    introducing classes, interfaces, packages, namespaces, types, and
    program units

  * Minor wording and editing changes


OPEN ISSUES

  * The (re)design of 'eval', discussed at length below, is an obvious
    attempt at killing 'eval' by a thousand cuts (yet remaining
    backward compatible!)  The resulting design is not awfully
    baroque, but it does seem a little bit arbitrary when considered
    as a whole.  Insights appreciated.


NOTES

  * The following globally visible facilities will be defined in other
    draft specs that will eventually be cross-referenced from the
    present spec:

     - Iterator and generator facilities
     - Reflection facilities
     - ControlInspector

  * It's probable that ES4 will upgrade the Unicode support in the
    language in various ways, but nothing is quite definite yet
    (backward compatibility constraints are causing trouble).  If the
    Unicode support is in fact upgraded then changes will likely be
    made to the URI encoding and decoding functions defined in the
    present spec.

  * Due to the uniform implementer sentiment against the types 'int'
    and 'uint' in John Resig's ES4 tracking spreadsheet, I have
    removed those classes from the global object in this draft, and I
    have removed some of the uses of 'int' and 'uint' throughout the
    document.  I have also introduced the top-level functions isInt,
    isUint, toInt, and toUint to provide some of the functionality
    that is lost along with 'int' and 'uint'.  See [19] for a
    discussion.

    If the change to 'int' and 'uint' sticks, then the numerous other
    uses of 'int' and 'uint' that remain in this and other draft specs
    will be cleaned up fairly soon.


REFERENCES

  Most of the following references simply call for a new top-level
  property of some kind or other, they have no direct bearing on the
  semantics of the global object or the functions defined in the
  present spec.  The exceptions are [6a]-[6d], which pin down 'eval'
  in various ways; [9a]-[9c], which calls for making some global
  bindings read-only; [11], which call for new namespaces to hide new
  global bindings; and [8a] and [8b], which deal with changes
  resulting from updates to how Unicode is handled in the language.

[1] http:&#x2f;&#x2f;wiki.ecmascript.org/doku.php?id=proposals:builtin_classes
[2] http:&#x2f;&#x2f;wiki.ecmascript.org/doku.php?id=proposals:numbers
[3] http:&#x2f;&#x2f;wiki.ecmascript.org/doku.php?id=proposals:intrinsic_namespace
[4] http:&#x2f;&#x2f;wiki.ecmascript.org/doku.php?id=proposals:iterators_and_generators
[5] http:&#x2f;&#x2f;wiki.ecmascript.org/doku.php?id=proposals:name_objects
[6a] http:&#x2f;&#x2f;wiki.ecmascript.org/doku.php?id=proposals:resurrected_eval
[6b] http:&#x2f;&#x2f;bugs.ecmascript.org/ticket/226
[6c] http:&#x2f;&#x2f;bugs.ecmascript.org/ticket/235
[6d] http:&#x2f;&#x2f;bugs.ecmascript.org/ticket/297
[7] http:&#x2f;&#x2f;wiki.ecmascript.org/doku.php?id=proposals:decimal
[8a] http:&#x2f;&#x2f;wiki.ecmascript.org/doku.php?id=proposals:update_unicode
[8b] http:&#x2f;&#x2f;bugs.ecmascript.org/ticket/148
[9a] http:&#x2f;&#x2f;wiki.ecmascript.org/doku.php?id=proposals:bug_fixes
[9b] http:&#x2f;&#x2f;bugs.ecmascript.org/ticket/123
[9c] http:&#x2f;&#x2f;bugs.ecmascript.org/ticket/220
[10] http:&#x2f;&#x2f;wiki.ecmascript.org/doku.php?id=proposals:globals
[11] http:&#x2f;&#x2f;wiki.ecmascript.org/doku.php?id=proposals:versioning
[12] http:&#x2f;&#x2f;wiki.ecmascript.org/doku.php?id=proposals:meta_objects
[13a] http:&#x2f;&#x2f;wiki.ecmascript.org/doku.php?id=proposals:hashcodes
[13b] http:&#x2f;&#x2f;bugs.ecmascript.org/ticket/152
[14] http:&#x2f;&#x2f;wiki.ecmascript.org/doku.php?id=proposals:dictionary
[15] http:&#x2f;&#x2f;wiki.ecmascript.org/doku.php?id=proposals:vector
[16] http:&#x2f;&#x2f;wiki.ecmascript.org/doku.php?id=proposals:stack_inspection
[17a] http:&#x2f;&#x2f;bugs.ecmascript.org/ticket/8
[17b] http:&#x2f;&#x2f;bugs.ecmascript.org/ticket/83
[17c] http:&#x2f;&#x2f;bugs.ecmascript.org/ticket/171
[18] http:&#x2f;&#x2f;bugs.ecmascript.org/ticket/152
[19] http:&#x2f;&#x2f;bugs.ecmascript.org/ticket/371
[20] http:&#x2f;&#x2f;bugs.ecmascript.org/ticket/153
</pre>
<HR>

<P> The global object is an instance of an implementation-dependent
class.  In particular, the name of this class and the contents of
the class's prototype object are implementation-dependent.

<P> The class describing the global object does not have an accessible
constructor function; it is not possible to use the global object as a
constructor with the ''new'' operator.

<p> The class describing the global object does not have a
''meta::invoke'' method; it is not possible to call the global object
as a function.

== Synopsis ==

<p>The global object contains the following properties, functions,
types, and class definitions.

{{{
namespace __ES4__

__ES4__ namespace intrinsic = <LDOTS>
__ES4__ namespace iterator = <LDOTS>
__ES4__ namespace reflect = <LDOTS>
__ES4__ namespace meta = <LDOTS>

class Object <LDOTS>
class Function <LDOTS>
class Array <LDOTS>
class String <LDOTS>
class Boolean <LDOTS>
class Number <LDOTS>
class Date <LDOTS>
class RegExp <LDOTS>
class Error <LDOTS>
class EvalError <LDOTS>
class RangeError <LDOTS>
class ReferenceError <LDOTS>
class SyntaxError <LDOTS>
class TypeError <LDOTS>
class URIError <LDOTS>

__ES4__ class string <LDOTS>
__ES4__ class boolean
__ES4__ class double <LDOTS>
__ES4__ class decimal <LDOTS>
__ES4__ class Name <LDOTS>
__ES4__ class Namespace <LDOTS>
__ES4__ class Map.<K,V> <LDOTS>
__ES4__ class Vector.<T> <LDOTS>

__ES4__ type EnumerableId = <LDOTS>
__ES4__ type AnyNumber = <LDOTS>
__ES4__ type AnyString = <LDOTS>
__ES4__ type AnyBoolean = <LDOTS>
__ES4__ type Callable = <LDOTS>

intrinsic const function eval(s: string) <LDOTS>
intrinsic const function parseInt(s: string, r: double=0): AnyNumber <LDOTS>
intrinsic const function parseFloat(s: string): AnyNumber <LDOTS>
intrinsic const function isNaN(n: AnyNumber): boolean <LDOTS>
intrinsic const function isFinite(n: AnyNumber): boolean <LDOTS>
intrinsic const function isIntrinsic(n: AnyNumber): boolean <LDOTS>
intrinsic const function isInt(n: AnyNumber): boolean <LDOTS>
intrinsic const function isUint(n: AnyNumber): boolean <LDOTS>
intrinsic const function toInt(n: AnyNumber): double <LDOTS>
intrinsic const function toUint(n: AnyNumber): double <LDOTS>
intrinsic const function decodeURI(s: string): string <LDOTS>
intrinsic const function decodeURIComponent(s: string): string <LDOTS>
intrinsic const function encodeURI(s: string): string <LDOTS>
intrinsic const function encodeURIComponent(s: string): string <LDOTS>
intrinsic const function hashcode(x): double <LDOTS>

function eval(x) <LDOTS>
function parseInt(s, r=undefined) <LDOTS>
function parseFloat(s) <LDOTS>
function isNaN(x) <LDOTS>
function isFinite(x) <LDOTS>
function decodeURI(x) <LDOTS>
function decodeURIComponent(x) <LDOTS>
function encodeURI(x) <LDOTS>
function encodeURIComponent(x) <LDOTS>
__ES4__ function isInt(n: AnyNumber): boolean <LDOTS>
__ES4__ function isUint(n: AnyNumber): boolean <LDOTS>
__ES4__ function toInt(n: AnyNumber): double <LDOTS>
__ES4__ function toUint(n: AnyNumber): double <LDOTS>

const NaN: double = <LDOTS>
const Infinity: double = <LDOTS>
const undefined: undefined = <LDOTS>
const Math: helper::MathType = <LDOTS>
const __ECMASCRIPT_VERSION__: double = <LDOTS>
__ES4__ const global = <LDOTS>
}}}

== Namespace Properties on the Global Object ==

<COMP>The namespace properties are all new in the 4th Edition of this
Standard.

=== __ES4__ ===

<P> The namespace ''__ES4__'' is used to tag all names introduced in
the global object in the 4th Edition of this Standard, except for two:
''__ES4__'' and ''__ECMASCRIPT_VERSION__''.

<P> The namespace ''__ES4__'' is automatically opened by the
implementation for code that is to be treated as 4th Edition code, but
not for code that is to be treated as 3rd Edition code.

<COMP> The risk of polluting the name space for 3rd Edition code with
new names is deemed too great to always open the ''__ES4__'' name
space.

<p> The means by which an implementation determines whether to treat
code according to 3rd Edition or 4th Edition is outside the scope of
this Standard.

<NOTE> This standard makes recommendations for how mime types should
be used to tag script content in a web browser.  (See <XREF
target="appendix-mime-types">.)

=== intrinsic ===

<P> The namespace ''intrinsic'' is used to tag pre-defined types,
properties, and methods.  

<P> The namespace ''intrinsic'' is reserved by the language.  Except
in the case where a method tagged ''intrinsic'' overrides an intrinsic
method inherited from a pre-defined class, it is an error for user
code to introduce new bindings in the ''intrinsic'' namespace.

<P> The bindings in the ''intrinsic'' namespace are always constant
fixtures.

<NOTE> A //fixture// is a binding that is not deletable and which
takes precedence over dynamic names during lexical name lookup.

=== reflect ===

<P> The namespace ''reflect'' is used to tag pre-defined interfaces in
the reflection subsystem.

<P> The namespace ''reflect'' is reserved by the language.  It is an
error for user code to introduce new bindings in the ''reflect''
namespace.

=== meta ===

<P> The namespace ''meta'' is used to tag methods that participate in
the language's protocols for invocation and property access.

<P> The namespace ''meta'' is reserved by the language.  Except in the
case where a class definition uses it to tag (possibly static) methods
called ''invoke'', ''get'', ''set'', ''has'', or ''delete'', it is an
error for user code to introduce new bindings in the ''meta''
namespace.

=== iterator ===

<P> The namespace ''iterator'' is used for the iteration protocol,
which is defined elsewhere.  (See <XREF target="iterators">.)

<NOTE> Unlike the namespaces ''__ES4__'', ''intrinsic'', ''reflect'', and
''meta'', the namespace ''iterator'' is not reserved by the system.


== Value Properties on the Global Object ==

=== __ECMASCRIPT_VERSION__ ===

<P> The value of the constant property ''__ECMASCRIPT_VERSION__'' is
an integer denoting the version of this Standard to which the
implementation conforms.  For this 4th Edition of the Standard, the
value of ''__ECMASCRIPT_VERSION__'' is 4.

<COMP> This property is new in the 4th Edition of this Standard.  It
is one of two properties introduced in the 4th Edition of this
Standard that is not in the ''__ES4__'' namespace.  (The other is
''__ES4__''.)

=== NaN ===

<P> The value of the constant property ''NaN'' is **NaN** (see <XREF
target="nan-value">).

<SHORTIMPL>
{{{
const NaN : double = <LDOTS>
}}}

<COMP>''NaN'' was not constant in the 3rd Edition of this Standard.

=== Infinity ===

<P>The value of ''Infinity'' is +<INFINITY> (see <XREF target="infinity-value">).

<SHORTIMPL>
{{{
const Infinity : double = <LDOTS>
}}}

<COMP>''Infinity'' was not constant in the 3rd Edition of this Standard.

=== undefined ===

<P>The value of ''undefined'' is **undefined** (see <XREF target="undefined-value">).

<SHORTIMPL>
{{{
const undefined : undefined = <LDOTS>
}}}

<COMP>''undefined'' was not constant in the 3rd Edition of this Standard.

=== Math ===

<P>The value of ''Math'' is the Math object (see <XREF
target="math-object">). 

<SHORTIMPL>
{{{
const Math : helper::MathType = <LDOTS>
}}}

<COMP>''Math'' was not constant in the 3rd Edition of this Standard.

<P> The helper type ''MathType'' (see <XREF target="MathType">) is a
structural record type that includes a property for every intrinsic
method and public constant property defined on the Math object.

<NOTE> The type of ''Math'' impacts strict mode type checking.


=== global ===

<p>The value of ''global'' is the global object that contains the
property ''global''.

<NOTE> There may be multiple global objects in a program, and these
objects may share values or immutable state: for example, their
''isNaN'' properties may hold the same function object.  However, each
global object has separate mutable state, and a separate value for the
intrinsic ''global'' property.

<SHORTIMPL>
{{{
const global = <LDOTS>
}}}

<COMP>''global'' is new in the 4th Edition of this Standard.


== Function Properties of the Global Object ==

=== eval ===

<P> //It is likely that the description in this section needs to be
broken up and scattered over several parts of the final specification,
but for the time being it's best if everything is centralized here.
I've added more expository and background material than the spec
really ought to have; we'll clean this up by and by.   --lars//

==== Overview and background ====

<P> The global object has properties named ''eval'' and
''intrinsic::eval''.  Those properties initially hold the same value,
a function, and that function -- the ''eval'' function -- can be
called in all the ways that any other function in the language can be
called.  There are however some run-time restrictions (described
below) on when those calls are valid.

<P> In addition, there is an operator in the language that is also
known under the names ''eval'' and ''intrinsic::eval''.  The ''eval''
operator has access to the lexical environment of its context; it can
look up and introduce bindings in the environment of its context.

<P> Together, the ''eval'' function and the ''eval'' operator provide
run-time evaluation functionality that (a) is compatible with the
functionality mandated for ''eval'' by the 3rd Edition and (b) handles
all important known uses of ''eval'' on the web.

<P> The 3rd Edition only mandates the equivalent of the operator form
of the 4th Edition, yet it describes ''eval'' as a function that has
the ability to inspect and modify its caller's lexical environment.
In practice, an implementation that supports only the functionality
mandated by the 3rd Edition will not support the web well, and as a
consequence several implementations of ECMAScript in web browsers
provide ''eval'' as a true function that actually has the ability to
inspect and modify its caller's environment, no matter who the caller
of ''eval'' is and regardless of the name under which ''eval'' has
been called.

<P> In other words, the 3rd Edition form of ''eval'', implemented in
full generality, makes it generally impossible to know if any
particular scope contains a binding for any particular name, since any
function call in the scope may be a call to ''eval'', which may
introduce new names in the scope.

<P> As an illustration, the following program prints "20" in Mozilla 
Firefox, even though casual inspection of the program would lead one to
conclude that the ''x'' referenced in the body of ''g'' is the constant
binding in the outer scope:
{{{
   const x = 10;
   function g(f,s) {
       f(s);
       return x;
   }

   document.writeln(g(eval,"var x=20"));
}}}

<P> In conclusion, the primary reason for splitting the definition of
''eval'' into function and operator forms in the 4th Edition is in
order to be able to control the extent to which ''eval'' can introduce
new names in scopes, while at the same time remaining compatible with
existing programs.

<P> The secondary reason for splitting the definition of ''eval'' into
function and operator forms is that the behavior illustrated above
largely precludes some standard code generation strategies.  A typical
approach in lexically scoped languages is to translate variable
references at compile time to //(rib,offset)// pairs; at run-time,
scope object number //rib// (where the innermost is number zero) is
fetched and property number //offset// is fetched out of it.  That
approach is only possible if the environment is known at compile time.
If there is a chance that ''eval'' can introduce new names into a
scope at run-time then lookup in that scope must always be by name;
with an operator form of ''eval'' it is possible to know at compile
time whether a scope may be thus affected.

<P> Several other features and clarifications have been incorporated
into the 4th Edition in an attempt to constrain the effects of
''eval''.  While the splitting of ''eval'' into an operator form and a
function form makes it clearer when a non-global environment might
have new bindings introduced, it does not prevent such bindings from
being introduced.

<P> The additional features and clarifications are:
<UL>

<LI> If the version number passed as the second argument to ''eval''
     is greater than 3, then the program being evaluated is given a
     fresh variable object in which it can create bindings; as a
     consequence, no bindings can be introduced into the caller's
     environment (except by assignment to non-existent global
     variables).

<LI> ''eval'' is prevented from changing the DontDelete attribute on
      existing bindings when a binding form is evaluated.

<LI> The operator form of ''eval'' is disallowed inside classes.

<LI> The operator form of ''eval'' is disallowed in strict mode.
</UL> 

==== eval (program, version=<LDOTS>) ====

<DESC> The eval function and the eval operator (described fully below)
are invoked on a //program//, which is a value of any type, and a
//version//, which is intended to be a nonnegative integer (defaulting
to 3).

<P> If the //program// is a string then it must represent valid source
code according to the nonterminal //Program// (see <XREF target="Grammar">), with
the proviso that the keyword set recognized during lexical analysis is
determined by //version//, as follows.  Convert version to an integer
as with the ToInt32 operation.  If the converted value of //version//
is 3 or less then the keyword set is the set of reserved words in the
3rd Edition of this Standard (E262-3 section 7.5.2).  Otherwise, if
the converted value of //version// is //n// then the keyword set is
the set of reserved and contextually reserved words in the //n//th
Edition of this Standard.

<NOTE> Program arguments to ''eval'' that use e.g. ''let'' as an
identifier will continue to work in a 4th Edition implementation
(where ''let'' is a keyword) as long as no //version// is passed to
''eval'', or the value of the version passed is 3 or less.

<P> If the converted value of //version// is 4 or greater then the
evaluation takes place in a fresh variable object.

<NOTE> In other words, ''eval'' will be unable to introduce bindings
in its caller's variable object if //version// is 4 or greater.

<COMP> Unlike in the 3rd Edition of this Standard, ''eval'' is not
allowed to change a property from being DontDelete to being deletable.
That restriction belongs in the section on adding bindings to the
variable object (10.1.3 in 3rd Ed) and is only mentioned here for the
time being.

<RETN> If the //program// is a string then the result of compiling and
evaluating //program// as a //Program// is returned.  Otherwise,
//program// is returned unchanged.

<SHORTIMPL>
{{{
function eval( program, version=3 ) <LDOTS>
}}}

==== The ''eval'' operator ====

<P> //There are two possible designs for the operator form.  One is
that an expression of the form ''eval(s)'' is //always// taken as the
operator form, regardless of the binding of ''eval'' in the context of
the expression; the other is that an expression of that form //may//
be the operator form, and that it is the operator form only if the
binding of ''eval'' is the original, global binding.  Since the former
design would be incompatible with 3rd Edition, we use the latter.//

<P> It will always be lexically apparent when ''eval'' is //possibly//
being used as an operator, but in the general case it is not possible
to determine until run-time whether it is //actually// being used as
an operator.

<NOTE> For the intrinsic form of the operator it is possible to
determine this at compile time, in the absence of the use of ''with''
in the enclosing context.

<DESC> The operator form is //possibly// being used in an expression //E// if
//E// has the form of a //CallExpression// (including the parentheses
bracketing the arguments) and the //MemberExpression// that denotes
the function to be called has the form of the unqualified identifier
''eval'' or the qualified identifier ''intrinsic::eval''.  That is,
apart from any superflous parentheses, //E// has the form //M(P, ...)//.

<P> If the possible use of the operator form of ''eval'' appears in
any context inside a class, a **SyntaxError** is thrown.

<P> If the possible use of the operator form of ''eval'' appears in
any context inside block in which strict mode is in effect (even
inside a block that overrides strict mode by decreeing standard mode),
a **SyntaxError** is thrown.

<NOTE> The purpose of these restriction is partly to avoid
inconsistencies (in strict mode) and partly to signal that the use of
the ''eval'' operator is potentially harmful to program integrity.

<FIXME> A less restrictive, but probably equally safe, alternative
would be to allow ''eval'' to be used inside a class provided that a
version parameter was being passed and its value was a constant known
to be 4 or greater.

<P> If the //program// operand to ''eval'' contains definitions for
classes, interfaces, packages, namespaces, types, or units, then a
''SyntaxError'' is thrown (even if the use of the ''eval'' operator is
at the outer program's top level where these forms would normally be
allowed).

<FIXME> Should that be EvalError?

<FIXME> It seems it would not be entirely unreasonable to lift that
restriction if the //version// is greater than 3, but it's unclear as
yet what the problems might be with e.g. allowing classes to have
elaborate scope chains around them.

<RETN> The eval operator returns an ECMAScript value.

<IMPL> In the case that a possible use of the operator form is
detected, //M(P, ...)// is evaluated as follows.

<P> (The implementation of the ''eval'' operator is presented as
pseudo-code because it is not expressible in ECMAScript.  Eventually,
it may be presented as Standard ML code.)

{{{
  look up M in the environment yielding the value V
  if V is the pre-defined eval function and
     the binding object O holding V is an ES global object and
     the global object on the scope chain of V is O then
       invoke eval as follows:
         evaluate the P in order to yield argument value A
         if there are no A values, then 
           return undefined
         if the first A value is not a string, then 
           return the first A
         if there is a second A then let K=int(A), else let K=3
         evaluate the program denoted by the first A as follows:
           if K <= 3
             the scope chain is the lexical chain in effect at 
                 the point of invocation of M
             the variable object is the innermost variable object in effect
                 (which is to say that it excludes binding objects 
                 introduced for "let", "catch", named function expressions, 
                 and "switch type")
           else
             the scope chain is the lexical chain in effect at the point of
                 invocation of M, extended by a new variable object W
             the variable object is W
           fi
           the value of "this" is the global object O
           the keyword set is determined by K
  else
    evaluate the P in order to yield a list of arguments A
    invoke V as a function on the arguments A
  fi
}}}

<NOTE> The requirement that the global object of V be O precludes
sharing of ''eval'' functions among multiple global environments.  It
is possible that that requirement is not actually needed for
consistent operation.

==== The ''eval'' function ====

<P> If the operator form is not detected syntactically then ''eval''
is either being called as a function under a different name or it is
being invoked as a method on an object.  The implementation does not
need to handle this case syntactically; it is handled as a regular
function call.

<P> The following description applies to both the public ''eval''
function and the intrinsic ''eval'' function, both defined in the
global object.

<DESC> The global ''eval'' function evaluates its first argument as a
program in the global scope of the ''eval'' function.

<RETN> The global ''eval'' function returns the value computed by
the program that is evaluated, or its first argument if the first
argument is not a string.

<IMPL> The body of the pre-defined ''eval'' function //V// is
evaluated in the context of a list of argument values //A// as
follows.

<P> (The implementation of the ''eval'' function is presented as
pseudo-code because it is not expressible in ECMAScript.  Eventually,
it may be presented as ECMAScript code with the addition of "magic"
run-time system hooks.)

{{{
  if the "this" object O is an ES global object and
     the global object on the scope chain of V is O then
       if there are no A values, then 
         return undefined
       if the first A value is not a string, then 
         return the first A
       if there is a second A then let K=int(A), else let K=3
       evaluate the program denoted by the first A as follows:
         if K<=3 then
           the scope chain holds O only
           the variable object is O
         else
           the scope chain holds O extended by a new variable object W
           the variable object is W
         fi
         the value of "this" is O
         the keyword set is determined by K
  else
    throw EvalError
  fi
}}}

<NOTE> The requirement that the global object of V be O precludes
sharing of ''eval'' functions among multiple global environments.  It
is possible that that requirement is not actually needed for
consistent operation.


==== Restrictions on the use of the ''eval'' property  ====

<p> If the global ''eval'' property is assigned to, an ''EvalError''
exception may be thrown.


=== intrinsic::parseInt (s, r=<LDOTS>) ===

<DESC> The intrinsic ''parseInt'' function computes an integer value
dictated by interpretation of the contents of the string argument
//s// according to the specified radix //r// (which defaults to zero).
Leading whitespace in //s// is ignored.  If //r// is zero, the radix is
assumed to be 10 except when the number begins with the character
pairs 0x or 0X, in which case a radix of 16 is assumed.  Any radix-16
number may also optionally begin with the character pairs 0x or 0X.

<RETN> The intrinsic ''parseInt'' function returns a number.

<SHORTIMPL>
<INCLUDE file="Global.es" name="intrinsic const function parseInt">

<P> The helper function ''isDigitForRadix(c,r)'' computes whether
''c'' is a valid digit for the radix ''r'', see <XREF target="helper:isDigitForRadix">.

<P> The helper function ''isTrimmableSpace(c)'' computes whether
''c'' is a space character that can be trimmed off the beginning
of the string, see <XREF target="helper:isTrimmableSpace">.

<p>The informative function ''numericValue(s, r)'' computes the
numeric value of a radix-''r'' string ''s''.  If ''r'' is 10 and ''s''
contains more than 20 significant digits, every significant digit
after the 20th may be replaced by a 0 digit, at the option of the
implementation; and if ''r'' is not 2, 4, 8, 10, 16, or 32, then the
returned value may be an implementation-dependent approximation to the
mathematical integer value that is represented by ''s'' in radix-''r''
notation.

<COMP>In the 3rd Edition of this Standard, the ''parseInt'' function was
allowed to, though not encouraged to, interpret a string with a
leading ''0'' but no leading ''0x'' or ''0X'' as a base-8 number if
the radix was not supplied in the call or was supplied as zero.  This
is no longer allowed; the function must interpret such a number as a
base-10 number.

<NOTE>''parseInt'' may interpret only a leading portion of the string as an
integer value; it ignores any characters that cannot be interpreted as
part of the notation of an integer, and no indication is given that
any such characters were ignored.

<h4 id="helper:isDigitForRadix">isDigitForRadix </h4>

<INCLUDE file="Global.es" name="helper function isDigitForRadix">


=== parseInt ( s, r=<LDOTS> ) ===

<DESC>The ''parseInt'' function converts its first argument to
''string'' and its second argument to ''double'', and then calls its
intrinsic counterpart.

<RETN>The ''parseInt'' function returns a number.

<SHORTIMPL>
<INCLUDE file="Global.es" name="public function parseInt">


=== intrinsic::parseFloat (s) ===

<DESC>The intrinsic ''parseFloat'' function computes a number value
dictated by interpretation of the contents of the string argument //s// as a
decimal literal.

<RETN> The intrinsic ''parseFloat'' function returns a number.

<SHORTIMPL>
<INCLUDE file="Global.es" name="intrinsic const function parseFloat">

<NOTE>''parseFloat'' may interpret only a leading portion of //s// as a
number value; it ignores any characters that cannot be interpreted as
part of the notation of an decimal literal, and no indication is given
that any such characters were ignored.

=== parseFloat (s) ===

<DESC>The ''parseFloat'' function converts its argument to ''string'',
then calls its intrinsic counterpart.

<RETN>The ''parseFloat'' function returns a number.

<SHORTIMPL>
<INCLUDE file="Global.es" name="public function parseFloat">


=== intrinsic::isNaN (n) ===

<DESC>The intrinsic ''isNaN'' function tests whether a numeric value //n// is an
IEEE not-a-number value.

<RETN>The intrinsic ''isNaN'' function returns 
**true** if //n// is **NaN**, and otherwise returns **false**.

<SHORTIMPL>
<INCLUDE file="Global.es" name="intrinsic const function isNaN">

=== isNaN (x) ===

<DESC>The ''isNaN'' function converts its argument to a number, then
calls its intrinsic counterpart.

<RETN>The ''isNaN'' function returns **true** if //x// converted to a
number is **NaN**, and otherwise returns **false**.

<SHORTIMPL>
<INCLUDE file="Global.es" name="public function isNaN">


=== intrinsic::isFinite (n) ===

<DESC>The intrinsic ''isFinite'' function tests whether a numeric
value //n// is finite (neither not-a-number nor an infinity).

<RETN>The intrinsic ''isFinite'' function returns **true** if //n// is
finite, and otherwise returns **false**.

<SHORTIMPL>
<INCLUDE file="Global.es" name="intrinsic const function isFinite">


=== isFinite (x) ===

<DESC>The ''isFinite'' function converts its argument to a number,
then calls its intrinsic counterpart on the converted value.

<RETN>The ''isFinite'' function returns **true** if //x// converted to
a number is finite, and otherwise returns **false**.

<SHORTIMPL>
<INCLUDE file="Global.es" name="public function isFinite">


=== intrinsic::isIntegral (n) ===

<DESC>The intrinsic ''isIntegral'' function tests whether a numeric
value //n// is integral (a finite integer).

<RETN>The intrinsic ''isIntegral'' function returns **true** if //n// is
integral, and otherwise returns **false**.

<SHORTIMPL>
<INCLUDE file="Global.es" name="intrinsic const function isIntegral">

=== isIntegral (x) ===

<DESC>The ''isIntegral'' function converts its argument //x// to a number,
then calls the intrinsic ''isIntegral'' function on the converted value.

<RETN>The ''isIntegral'' function returns **true** if //x// converted
to a number is integral, and otherwise returns **false**.

<SHORTIMPL>
<INCLUDE file="Global.es" name="__ES4__ function isIntegral">

=== intrinsic::isInt (n) ===

<DESC>The intrinsic ''isInt'' function tests whether a numeric value
//n// is an ''int'' value (a finite integer in the range
-2<SUP>31</SUP> to 2<SUP>31</SUP>-1, inclusive).

<RETN>The intrinsic ''isInt'' function returns **true** if //n//
is an ''int'' value, and otherwise returns **false**.

<SHORTIMPL>
<INCLUDE file="Global.es" name="intrinsic const function isInt">

=== isInt (x) ===

<DESC>The ''isInt'' function converts its argument //x// to a number,
then calls the intrinsic ''isInt'' function on the converted value.

<RETN>The ''isInt'' function returns **true** if //x// converted
to a number is an ''int'' value, and otherwise returns **false**.

<SHORTIMPL>
<INCLUDE file="Global.es" name="__ES4__ function isInt">

=== intrinsic::isUint (n) ===

<DESC>The intrinsic ''isUint'' function tests whether the numeric
value //n// is a ''uint'' value (a finite integer in the range 0 to
2<SUP>32</SUP>-1, inclusive).

<RETN>The intrinsic ''isUint'' function returns **true** if //n//
is a ''uint'' value, and otherwise returns **false**.

<SHORTIMPL>
<INCLUDE file="Global.es" name="intrinsic const function isUint">

=== isUint (x) ===

<DESC>The ''isUint'' function converts its argument //x// to a number,
then calls the intrinsic ''isUint'' function on the converted value.

<RETN>The ''isUint'' function returns **true** if //x// converted
to a number is a ''uint'' value, and otherwise returns **false**.

<SHORTIMPL>
<INCLUDE file="Global.es" name="__ES4__ function isUint">

=== intrinsic::toInt (n) ===

<DESC>The intrinsic ''toInt'' function converts its argument //n// to an ''int'' value
using the ToInt32 algorithm (see <XREF target="ToInt32">).

<RETN>The intrinsic ''toInt'' function returns an ''int'' value.

<SHORTIMPL>
<INCLUDE file="Global.es" name="intrinsic const function toInt">

=== toInt (x) ===

<DESC>The ''toInt'' function converts its argument //x// to a number, then
calls the intrinsic ''toInt'' function on the converted value.

<RETN>The ''toInt'' function returns an ''int'' value.

<SHORTIMPL>
<INCLUDE file="Global.es" name="__ES4__ function toInt">

=== intrinsic::toUint (n) ===

<DESC>The intrinsic ''toUint'' function converts its argument //n// to a ''uint'' value
using the ToUint32 algorithm (see <XREF target="ToUint32">).

<RETN>The intrinsic ''toUint'' function returns a ''uint'' value.

<SHORTIMPL>
<INCLUDE file="Global.es" name="intrinsic const function toUint">

=== toUint (x) ===

<DESC>The ''toUint'' function converts its argument //x// to a number, then
calls the intrinsic ''toUint'' function on the converted value.

<RETN>The ''toUint'' function returns a ''uint'' value.

<SHORTIMPL>
<INCLUDE file="Global.es" name="__ES4__ function toUint">


=== URI Handling Function Properties ===

<p>Uniform Resource Identifiers, or URIs, are strings that identify
resources (e.g. web pages or files) and transport protocols by which
to access them (e.g. HTTP or FTP) on the Internet. The ECMAScript
language itself does not provide any support for using URIs except for
functions that encode and decode URIs as described in sections <XREF
target="decodeURI">, <XREF target="decodeURIComponent">, <XREF
target="encodeURI">, and <XREF target="encodeURIComponent">.

<NOTE>Many implementations of ECMAScript provide additional
functions and methods that manipulate web pages; these functions are
beyond the scope of this standard.

<p>A URI is composed of a sequence of components separated by component separators. The general form is:
<div class="indented">
//Scheme '':'' First ''/'' Second '';'' Third ''?'' Fourth//
</div>

<p>where the italicised names represent components and the ":", "/",
";" and "?" are reserved characters used as separators.  The
''encodeURI'' and ''decodeURI'' functions are intended to work with
complete URIs; they assume that any reserved characters in the URI are
intended to have special meaning and so are not encoded.  The
''encodeURIComponent'' and ''decodeURIComponent'' functions are
intended to work with the individual component parts of a URI; they
assume that any reserved characters represent text and so must be
encoded so that they are not interpreted as reserved characters when
the component is part of a complete URI.  The following lexical
grammar specifies the form of encoded URIs.

<div class="grammar">
<div class="nonterm">uri :::</div>
<div class="indented">uriCharacters<sub>opt</sub></div>

<div class="nonterm">uriCharacters :::</div>
<div class="indented">uriCharacter uriCharacters<sub>opt</sub></div>

<div class="nonterm">uriCharacter :::</div>
<div class="indented">uriReserved<br>
uriUnescaped<br>
uriEscaped</div>

<div class="nonterm">uriReserved ::: **one of**</div>
<div class="indented">''; / ? : @ & = + $ ,''</div>

<div class="nonterm">uriUnescaped :::</div>
<div class="indented">uriAlpha<br>
DecimalDigit<br>
uriMark</div>

<div class="nonterm">uriEscaped :::</div>
<div class="indented">% HexDigit HexDigit</div>

<div class="nonterm">uriAlpha ::: **one of**</div>
<div class="indented">''a b c d e f g h i j k l m n o p q r s t u v w x y z''<br>
''A B C D E F G H I J K L M N O P Q R S T U V W X Y Z''</div>

<div class="nonterm">uriMark ::: **one of**</div>
<div class="indented">''- _ . ! ~ * ' ( )''</div>
</div>

<FIXME> (Ticket #170.)  Upgrade to Unicode 5 in the following
sections, and upgrade to handling the entire (21-bit) Unicode
character set.

<p>When a character to be included in a URI is not listed above or is
not intended to have the special meaning sometimes given to the
reserved characters, that character must be encoded. The character is
first transformed into a sequence of octets using the UTF-8
transformation, with surrogate pairs first transformed from their
UCS-2 to UCS-4 encodings. (Note that for code points in the range
[0,127] this results in a single octet with the same value.)  The
resulting sequence of octets is then transformed into a string with
each octet represented by an escape sequence of the form "''%xx''".

<p>The encoding and escaping process is described by the helper
function ''encode'' taking two string arguments ''s'' and
''unescapedSet''.

<INCLUDE file="Global.es" name="helper function encode">
<INCLUDE file="Global.es" name="helper function twoHexDigits">

<p>The unescaping and decoding process is described by the helper
function ''decode'' taking two string arguments ''s'' and
''reservedSet''.

<INCLUDE file="Global.es" name="helper function decode">
<INCLUDE file="Global.es" name="helper function decodeHexEscape">

<p>The helper function ''isDigitForRadix'' was defined in section
<XREF target="helper:isDigitForRadix">.

<NOTE>The syntax of Uniform Resource Identifiers is given in
RFC2396.

<NOTE>A formal description and implementation of UTF-8 is
given in the Unicode Standard, Version 2.0, Appendix A.  In UTF-8,
characters are encoded using sequences of 1 to 6 octets. The only
octet of a "sequence" of one has the higher-order bit set to 0, the
remaining 7 bits being used to encode the character value. In a
sequence of n octets, n>1, the initial octet has the n higher-order
bits set to 1, followed by a bit set to 0. The remaining bits of that
octet contain bits from the value of the character to be encoded. The
following octets all have the higher-order bit set to 1 and the
following bit set to 0, leaving 6 bits in each to contain bits from
the character to be encoded. The possible UTF-8 encodings of
ECMAScript characters are:

<center>
<table border="1">
  <tr><th>Code Point Value</th><th>Representation</th>    <th>1st Octet</th><th>2nd Octet</th><th>3rd Octet</th><th>4th Octet</th></tr>
  <tr><td>0x0000 - 0x007F</td> <td>00000000 0zzzzzzz</td> <td>0zzzzzzz</td></tr>
  <tr><td>0x0080 - 0x07FF</td> <td>00000yyy yyzzzzzz</td> <td>110yyyyy</td> <td>10zzzzzz</td></tr>
  <tr><td>0x0800 - 0xD7FF</td> <td>xxxxyyyy yyzzzzzz</td> <td>1110xxxx</td> <td>10yyyyyy</td><td>10zzzzzz</td></tr>
  <tr><td>0xD800 - 0xDBFF<br>
          followed by<br>
          0xDC00 - 0xDFFF</td> <td>110110vv vvwwwwxx<br>
                                   followed by<br>
                                   110111yy yyzzzzzz</td> <td>11110uuu</td> <td>10uuwwww</td> <td>10xxyyyy</td> <td>10zzzzzz</td></tr>
  <tr><td>0xD800 - 0xDBFF<br>
      not followed by<br>
      0xDC00 - 0xDFFF</td>     <td>causes URIError</td></tr>
  <tr><td>0xDC00 - 0xDFFF</td> <td>causes URIError</td></tr>
  <tr><td>0xE000 - 0xFFFF</td> <td>xxxxyyyy yyzzzzzz</td> <td>1110xxxx</td> <td>10yyyyyy</td> <td>10zzzzzz</td></tr>
</table>
</center>

<p>Where
<div class="indented">uuuuu = vvvv + 1</div>
<p>to account for the addition of 0x10000 as in section 3.7,
Surrogates of the Unicode Standard version 2.0.

<p>The range of code point values 0xD800-0xDFFF is used to encode
surrogate pairs; the above transformation combines a UCS-2 surrogate
pair into a UCS-4 representation and encodes the resulting 21-bit
value in UTF-8. Decoding reconstructs the surrogate pair.

<p>The helper functions ''encode'' and ''decode'', defined above, use
the helper functions ''toUTF8'' and ''fromUTF8'' to convert code
points to UTF-8 sequences and to convert UTF-8 sequences to code
points, respectively.

<INCLUDE file="Global.es" name="helper function toUTF8">
<INCLUDE file="Global.es" name="helper function fromUTF8">

<p>Several helper strings are defined based on the grammar shown
previously:

<INCLUDE file="Global.es" name="helper const uriReserved">
<INCLUDE file="Global.es" name="helper const uriAlpha">
<INCLUDE file="Global.es" name="helper const uriDigit">
<INCLUDE file="Global.es" name="helper const uriMark">
<INCLUDE file="Global.es" name="helper const uriUnescaped">


==== intrinsic::decodeURI (encodedURI) ====

<DESC> The intrinsic ''decodeURI'' function computes a new version of
a URI in which each escape sequence and UTF-8 encoding of the sort
that might be introduced by the ''encodeURI'' function is replaced
with the character that it represents.  Escape sequences that could
not have been introduced by ''encodeURI'' are not replaced.

<RETN> The intrinsic ''decodeURI'' function returns a decoded string.

<SHORTIMPL>
<INCLUDE file="Global.es" name="intrinsic const function decodeURI">

<NOTE>The character "''#''" is not decoded from escape sequences even
though it is not a reserved URI character.

==== decodeURI (encodedURI) ====

<DESC>The ''decodeURI'' function converts its argument to ''string'', then
calls its intrinsic counterpart.

<RETN> The ''decodeURI'' function returns a decoded string.

<SHORTIMPL>
<INCLUDE file="Global.es" name="public function decodeURI">


==== intrinsic::decodeURIComponent (encodedURIComponent) ====

<DESC> The intrinsic ''decodeURIComponent'' function computes a new
version of a URI in which each escape sequence and UTF-8 encoding of
the sort that might be introduced by the ''encodeURIComponent''
function is replaced with the character that it represents.

<RETN> The intrinsic ''decodeURIComponent'' function returns a decoded string.

<SHORTIMPL>
<INCLUDE file="Global.es" name="intrinsic const function decodeURIComponent">

==== decodeURIComponent (encodedURIComponent) ====

<DESC>The ''decodeURIComponent'' function converts its argument to
''string'', then calls its intrinsic counterpart.

<RETN> The ''decodeURIComponent'' function returns a decoded string.

<SHORTIMPL>
<INCLUDE file="Global.es" name="public function decodeURIComponent">


==== intrinsic::encodeURI (uri) ====

<DESC> The intrinsic ''encodeURI'' function computes a new version of
a URI in which each instance of certain characters is replaced by one,
two, three, or four escape sequences representing the UTF-8 encoding of the
character.

<RETN> The intrinsic ''encodeURI'' function returns a encoded string.

<SHORTIMPL>
<INCLUDE file="Global.es" name="intrinsic const function encodeURI">

<NOTE>The character "''#''" is not encoded to an escape sequence
even though it is not a reserved or unescaped URI character.

==== encodeURI (uri) ====

<DESC>The ''encodeURI'' function converts its argument to string, then
calls its intrinsic counterpart.

<RETN> The ''encodeURI'' function returns a encoded string.

<SHORTIMPL>
<INCLUDE file="Global.es" name="public function encodeURI">


==== intrinsic::encodeURIComponent (uriComponent) ====

<DESC> The intrinsic ''encodeURIComponent'' function computes a new
version of a URI in which each instance of certain characters is
replaced by one, two, three, or four escape sequences representing the
UTF-8 encoding of the character.

<RETN> The intrinsic ''encodeURIComponent'' function returns a encoded string.

<SHORTIMPL>
<INCLUDE file="Global.es" name="intrinsic const function encodeURIComponent">

==== encodeURIComponent (uriComponent) ====

<DESC>The ''encodeURIComponent'' function converts its
argument to string, then calls its intrinsic counterpart.

<RETN> The ''encodeURIComponent'' function returns a encoded string.

<SHORTIMPL>
<INCLUDE file="Global.es" name="public function encodeURIComponent">


=== intrinsic::hashcode (x) ===

<!-- [[proposals:hashcodes]] -->

<DESC> The intrinsic ''hashcode'' function computes a numeric value
for its argument such that if two values ''v1'' and ''v2'' are equal
by the operator ''intrinsic::==='' then ''hashcode(v1)'' is
numerically equal to ''hashcode(v2)''.

<P> The hashcode of any value for which ''isNaN'' returns **true** is
zero.

<P> The hashcode computed for an object does not change over time.

<RETN> The intrinsic ''hashcode'' function returns a nonnegative integer
below 2<SUP>32</SUP>.

<SHORTIMPL>
<INCLUDE file="Global.es" name="intrinsic const function hashcode">

<P> The informative functions ''stringHash'', ''namespaceHash'',
''nameHash'', and ''objectHash'' compute hash values for strings,
namespaces, names, and arbitrary objects, respectively.  They can take
into account their arguments' immutable structure only.

<P> The implementation should strive to compute different hashcodes
for values that are not the same by ''intrinsic::==='', as the utility
of this function depends on that property.  (The user program should
be able to expect that the hashcodes of objects that are not the same
are different with high probability.)

<NOTE> A typical implementation of ''stringHash'' will make use of the
string's character sequence and its length.

<NOTE> A typical implementation of ''objectHash'' may make use of the
object's address in memory if the object, or it may maintain a
separate table mapping objects to hash codes.

<IMPLNOTE>The intrinsic ''hashcode'' function should not return
pointer values cast to integers, even in implementations that do not
use a moving garbage collector.  Exposing memory locations of objects
may make security vulnerabilities in the host environment
significantly worse.  Implementations -- in particular those which
read network input -- should return numbers unrelated to memory
addresses if possible, or at least use memory addresses subject to
some cryptographically strong one-way transformation, or sequence
numbers, cookies, or similar.


== Class and Interface Properties of the Global Object ==

<p>The class properties of the global object are defined in later sections of this Standard:
<ul>
  <li> The ''Object'' class is defined in section <XREF target="class Object">
  <li> The ''Function'' class is defined in section <XREF target="class Function">
  <li> The ''Name'' class is defined in section <XREF target="class Name">
  <li> The ''Namespace'' class is defined in section <XREF target="class Namespace">
  <li> The ''Array'' class is defined in section <XREF target="class Array">
  <li> The ''String'' and ''string'' classes are defined in sections <XREF target="class String"> and <XREF target="class string">, respectively.
  <li> The ''Boolean'' and ''boolean'' classes are defined in sections <XREF target="class Boolean"> and <XREF target="class boolean">, respectively.
  <li> The ''Number'', ''double'', and ''decimal'' classes are defined in sections <XREF target="class Number">, <XREF target="class double">, and <XREF target="class decimal">, respectively.
  <li> The ''Date'' class is defined in section <XREF target="class Date">
  <li> The ''RegExp'' class is defined in section <XREF target="class RegExp">
  <li> The ''Map'' class is defined in section <XREF target="class Map">
  <li> The ''Vector'' class is defined in section <XREF target="class Vector">
  <li> The ''Error'' class and its subclasses ''EvalError'', ''RangeError'', ''ReferenceError'', ''SyntaxError'', ''TypeError'', and ''URIError'' are defined in sections <XREF target="class Error">, <XREF target="class EvalError">, <XREF target="class RangeError">, <XREF target="class ReferenceError">,  <XREF target="class SyntaxError">, <XREF target="class TypeError">, and <XREF target="class URIError">, respectively.
</ul>


== Type Properties on the Global Object ==

=== EnumerableId ===

<p>The type ''EnumerableId'' is a union type of all the nominal types
that are treated as property names by the iteration protocol and the
pre-defined objects:

{{{
__ES4__ type EnumerableId = (int|uint|string|Name);
}}}

<FIXME> Removed ''int'' and ''uint'' from this type if/when we agree that
that's the right thing.


=== AnyNumber ===

<p>The type ''AnyNumber'' is a union type of all the nominal
types that are treated as numbers by the language:

{{{
__ES4__ type AnyNumber = (double|decimal|Number);
}}}

=== AnyString ===

<p>The type ''AnyString'' is a union type of all the nominal
types that are treated as strings by the language:

{{{
__ES4__ type AnyString = (string|String);
}}}

=== AnyBoolean ===

<p>The type ''AnyBoolean'' is a union type of all the nominal
types that are treated as booleans by the language:

{{{
__ES4__ type AnyBoolean = (boolean|Boolean);
}}}

=== Callable ===

<P> The type ''Callable'' is a record type describing any object that
can be called as a function:

{{{
__ES4__ type Callable = { meta::invoke: * }
}}}

<!-- End of global.html -->
