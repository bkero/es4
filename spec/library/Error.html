<!-- The Error class and its subclasses -->

= Error classes =

<pre>
FILE:                       spec/library/Error.html
DRAFT STATUS:               DRAFT 1 - ROUGH - 2007-09-10
REVIEWED AGAINST ES3:       NO
REVIEWED AGAINST ERRATA:    NO
REVIEWED AGAINST BASE DOC:  NO
REVIEWED AGAINST PROPOSALS: NO
REVIEWED AGAINST CODE:      NO
</pre>

<P> ECMAScript provides a hierarchy of standard native error classes
rooted at the class ''Error'' (see <XREF target="class Error">).

<P> The ECMAScript implementation throws a new instance of one of
the native error classes when it detects certain run-time errors.  The
conditions under which run-time errors are detected are explained
throughout this Standard.  The description of each of the native error
objects contains a summary of the conditions under which an instance
of that particular error class is thrown.

<P> The class ''Error'' serves as the base class for all the classes
describing standard errors thrown by the ECMAScript implementation:
''EvalError'', ''RangeError'', ''ReferenceError'', ''SyntaxError'',
''TypeError'', and ''URIError''.
(See <XREF target="class EvalError">, <XREF target="class RangeError">,
<XREF target="class ReferenceError">, <XREF target="class SyntaxError">,
<XREF target="class TypeError">, <XREF target="class URIError">.)

<P> The class ''Error'' as well as all its native subclasses are
non-final and dynamic and may be subclassed by user-defined exception
classes.

<P> All the built-in subclasses of ''Error'' share the same structure.


<H1 id="class Error"> The class ''Error'' </h1>

<P> The class ''Error'' is a dynamic non-final subclass of ''Object''.
Instances of ''Error'' are not thrown by the implementation; rather,
''Error'' is intended to serve as a base class for other error classes
whose instances represent specific classes of run-time errors.

== Synopsis ==

<P> The class ''Error'' provides the following interface:

{{{
dynamic class Error extends Object 
{
    <SIGNATURE file="Error.es" name="function Error">
    <SIGNATURE file="Error.es" name="meta static function invoke">
    
    static const length = 1
    
    <SIGNATURE file="Error.es" name="override intrinsic function toString">
}
}}}

<P> The ''Error'' prototype object provides these direct properties:

{{{
    toString: function () <LDOTS> ,
    name:     "Error" ,
    message:  <LDOTS> ,
}}}

== Methods on the ''Error'' class ==

=== new Error (message) ===

<DESC> When the ''Error'' constructor is called as part of a
''new&nbsp;Error'' expression it initialises the newly created object:
If //message// is not **undefined**, the dynamic ''message'' property
of the newly constructed ''Error'' object is set to ''string(//message//)''.

<SHORTIMPL>
<INCLUDE file="Error.es" name="function Error">

=== Error (message) ===

<DESC> When the ''Error'' class object is called as a function, it
creates and initialises a new ''Error'' object by invoking the
''Error'' constructor.

<RETN> The ''Error'' class object called as a function returns a new
''Error'' object.

<SHORTIMPL>
<INCLUDE file="Error.es" name="meta static function invoke">


== Methods on ''Error'' instances ==

=== intrinsic::toString( ) ===

<DESC> The intrinsic ''toString'' method converts the ''Error'' object
to an implementation-defined string.

<RETN> A ''string'' object.

<IMPL> The intrinsic ''toString'' method is implementation-dependent.


== Methods on the ''Error'' prototype object ==

=== toString ( ) ===

<DESC> The prototype ''toString'' method calls the intrinsic ''toString'' method.

<RETN> The prototype ''toString'' method returns a ''string'' object.

<SHORTIMPL>
<INCLUDE file="Error.es" name="prototype function toString">

== Value properties on the ''Error'' prototype object ==

=== message ===

<P> The initial value of the ''message'' prototype property is an
implementation-defined string.


<!----------------------------------------------------------------------->

<H1 id="class EvalError"> The class ''EvalError'' </H1>

<P> The implementation throws a new ''EvalError'' instance when it
detects that the global function ''eval'' was used in a way that is
incompatible with its definition.  See XX.XX.

<FIXME> Clean up the section references when we reach final draft.

== Synopsis ==

<P> The ''EvalError'' class provides this interface:

{{{
dynamic class EvalError extends Error
{
    <SIGNATURE file="EvalError.es" name="function EvalError">
    <SIGNATURE file="EvalError.es" name="meta static function invoke">
    
    static const length = 1
}
}}}

<P> The ''EvalError'' prototype object provides these direct properties:
{{{
    name:    "EvalError" ,
    message: <LDOTS> ,
}}}

== Methods on the ''EvalError'' class ==

=== new EvalError (message) ===

<DESC> When the ''EvalError'' constructor is called as part of a
''new&nbsp;EvalError'' expression it initialises the newly created
object by delegating to the ''Error'' constructor.

<SHORTIMPL>
<INCLUDE file="EvalError.es" name="function EvalError">


=== EvalError (message) ===

<DESC> When the ''EvalError'' class object is called as a function, it
creates and initialises a new ''EvalError'' object by invoking the
''EvalError'' constructor.

<RETN> The ''EvalError'' class object called as a function returns a
new ''EvalError'' object.

<SHORTIMPL>
<INCLUDE file="EvalError.es" name="meta static function invoke">


== Value properties on the ''EvalError'' prototype object ==

=== message ===

<P> The initial value of ''message'' prototype property is an implementation-defined string.


<!----------------------------------------------------------------------->

<H1 id="class RangeError"> The class ''RangeError'' </H1>

<P> The implementation throws a new ''RangeError'' instance when it
detects that a numeric value has exceeded the allowable range. See
15.4.2.2, 15.4.5.1, 15.7.4.5, 15.7.4.6, and 15.7.4.7.

<FIXME> Clean up the section references when we reach final draft.

== Synopsis ==

<P> The ''RangeError'' class provides this interface:

{{{
dynamic class RangeError extends Error
{
    <SIGNATURE file="RangeError.es" name="function RangeError">
    <SIGNATURE file="RangeError.es" name="meta static function invoke">
    
    static const length = 1
}
}}}

<P> The ''RangeError'' prototype object provides these direct properties:
{{{
    name:    "RangeError" ,
    message: <LDOTS> ,
}}}

== Methods on the ''RangeError'' class ==

=== new RangeError (message) ===

<DESC> When the ''RangeError'' constructor is called as part of a
''new&nbsp;RangeError'' expression it initialises the newly created
object by delegating to the ''Error'' constructor.

<SHORTIMPL>
<INCLUDE file="RangeError.es" name="function RangeError">


=== RangeError (message) ===

<DESC> When the ''RangeError'' class object is called as a function, it
creates and initialises a new ''RangeError'' object by invoking the
''RangeError'' constructor.

<RETN> The ''RangeError'' class object called as a function returns a
new ''RangeError'' object.

<SHORTIMPL>
<INCLUDE file="RangeError.es" name="meta static function invoke">


== Value properties on the ''RangeError'' prototype object ==

=== message ===

<P> The initial value of ''message'' prototype property is an implementation-defined string.


<!----------------------------------------------------------------------->

<H1 id="class ReferenceError"> The class ''ReferenceError'' </H1>

<P> The implementation throws a new ''ReferenceError'' instance when it
detects an invalid reference value. See 8.7.1, and 8.7.2.

<FIXME> Clean up the section references when we reach final draft.

== Synopsis ==

{{{
dynamic class ReferenceError extends Error
{
    <SIGNATURE file="ReferenceError.es" name="function ReferenceError">
    <SIGNATURE file="ReferenceError.es" name="meta static function invoke">
    
    static const length = 1
}
}}}

<P> The ''ReferenceError'' prototype object provides these direct properties:
{{{
    name:    "ReferenceError" ,
    message: <LDOTS> ,
}}}

== Methods on the ''ReferenceError'' class ==

=== new ReferenceError (message) ===

<DESC> When the ''ReferenceError'' constructor is called as part of a
''new&nbsp;ReferenceError'' expression it initialises the newly created
object by delegating to the ''Error'' constructor.

<SHORTIMPL>
<INCLUDE file="ReferenceError.es" name="function ReferenceError">


=== ReferenceError (message) ===

<DESC> When the ''ReferenceError'' class object is called as a function, it
creates and initialises a new ''ReferenceError'' object by invoking the
''ReferenceError'' constructor.

<RETN> The ''ReferenceError'' class object called as a function returns a
new ''ReferenceError'' object.

<SHORTIMPL>
<INCLUDE file="ReferenceError.es" name="meta static function invoke">


== Value properties on the ''ReferenceError'' prototype object ==

=== message ===

<P> The initial value of ''message'' prototype property is an implementation-defined string.


<!----------------------------------------------------------------------->

<H1 id="class SyntaxError"> The class ''SyntaxError'' </H1>

<P> The implementation throws a new ''SyntaxError'' instance when a
parsing error has occurred. See 15.1.2.1, 15.3.2.1, 15.10.2.5,
15.10.2.9, 15.10.2.15, 15.10.2.19, and 15.10.4.1.

<FIXME> Clean up the section references when we reach final draft.

== Synopsis ==

{{{
dynamic class SyntaxError extends Error
{
    <SIGNATURE file="SyntaxError.es" name="function SyntaxError">
    <SIGNATURE file="SyntaxError.es" name="meta static function invoke">
    
    static const length = 1
}
}}}

<P> The ''SyntaxError'' prototype object provides these direct properties:
{{{
    name:    "SyntaxError" ,
    message: <LDOTS> ,
}}}

== Methods on the ''SyntaxError'' class ==

=== new SyntaxError (message) ===

<DESC> When the ''SyntaxError'' constructor is called as part of a
''new&nbsp;SyntaxError'' expression it initialises the newly created
object by delegating to the ''Error'' constructor.

<SHORTIMPL>
<INCLUDE file="SyntaxError.es" name="function SyntaxError">


=== SyntaxError (message) ===

<DESC> When the ''SyntaxError'' class object is called as a function, it
creates and initialises a new ''SyntaxError'' object by invoking the
''SyntaxError'' constructor.

<RETN> The ''SyntaxError'' class object called as a function returns a
new ''SyntaxError'' object.

<SHORTIMPL>
<INCLUDE file="SyntaxError.es" name="meta static function invoke">


== Value properties on the ''SyntaxError'' prototype object ==

=== message ===

<P> The initial value of ''message'' prototype property is an implementation-defined string.


<!----------------------------------------------------------------------->

<h1 id="class TypeError"> The class ''TypeError'' </H1>

<P> The implementation throws a new ''TypeError'' instance when it has
detected that the actual type of an operand is different than the
expected type. See 8.6.2, 8.6.2.6, 9.9, 11.2.2, 11.2.3, 11.8.6,
11.8.7, 15.3.4.2, 15.3.4.3, 15.3.4.4, 15.3.5.3, 15.4.4.2, 15.4.4.3,
15.5.4.2, 15.5.4.3, 15.6.4, 15.6.4.2, 15.6.4.3, 15.7.4, 15.7.4.2,
15.7.4.4, 15.9.5, 15.9.5.9, 15.9.5.27, 15.10.4.1, and 15.10.6.

<FIXME> Clean up the section references when we reach final draft.

== Synopsis ==

{{{
dynamic class TypeError extends Error
{
    <SIGNATURE file="TypeError.es" name="function TypeError">
    <SIGNATURE file="TypeError.es" name="meta static function invoke">
    
    static const length = 1
}
}}}

<P> The ''TypeError'' prototype object provides these direct properties:
{{{
    name:    "TypeError" ,
    message: <LDOTS> ,
}}}

== Methods on the ''TypeError'' class ==

=== new TypeError (message) ===

<DESC> When the ''TypeError'' constructor is called as part of a
''new&nbsp;TypeError'' expression it initialises the newly created
object by delegating to the ''Error'' constructor.

<SHORTIMPL>
<INCLUDE file="TypeError.es" name="function TypeError">


=== TypeError (message) ===

<DESC> When the ''TypeError'' class object is called as a function, it
creates and initialises a new ''TypeError'' object by invoking the
''TypeError'' constructor.

<RETN> The ''TypeError'' class object called as a function returns a
new ''TypeError'' object.

<SHORTIMPL>
<INCLUDE file="TypeError.es" name="meta static function invoke">


== Value properties on the ''TypeError'' prototype object ==

=== message ===

<P> The initial value of ''message'' prototype property is an implementation-defined string.


<!----------------------------------------------------------------------->

<H1 id="class URIError"> The class ''URIError'' </H1>

<P> The implementation throws a new ''URIError'' when one of the global
URI handling functions was used in a way that is incompatible with its
definition. See 15.1.3.

<FIXME> Clean up the section references when we reach final draft.

== Synopsis ==

{{{
dynamic class URIError extends Error
{
    <SIGNATURE file="URIError.es" name="function URIError">
    <SIGNATURE file="URIError.es" name="meta static function invoke">
    
    static const length = 1
}
}}}

<P> The ''URIError'' prototype object provides these direct properties:
{{{
    name:    "URIError" ,
    message: <LDOTS> ,
}}}

== Methods on the ''URIError'' class ==

=== new URIError (message) ===

<DESC> When the ''URIError'' constructor is called as part of a
''new&nbsp;URIError'' expression it initialises the newly created
object by delegating to the ''Error'' constructor.

<SHORTIMPL>
<INCLUDE file="URIError.es" name="function URIError">


=== URIError (message) ===

<DESC> When the ''URIError'' class object is called as a function, it
creates and initialises a new ''URIError'' object by invoking the
''URIError'' constructor.

<RETN> The ''URIError'' class object called as a function returns a
new ''URIError'' object.

<SHORTIMPL>
<INCLUDE file="URIError.es" name="meta static function invoke">


== Value properties on the ''URIError'' prototype object ==

=== message ===

<P> The initial value of ''message'' prototype property is an implementation-defined string.

<!-- End of Error.html -->
