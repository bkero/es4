= Array Objects =

<p>Array objects give special treatment to a certain class of property
names.  A property name //P// (in the form of a string value) is an
array index if and only if ''ToString(ToUint32(//P//))'' is equal to
//P// and ''ToUint32(//P//)'' is not equal to 2<sup>32</sup>-1.

<FIXME>For ES4 we need a better definition of a property name than
something based on a string, but for arrays it will do for now.

<p>Every Array object has a ''length'' property whose value is always
a nonnegative integer less than 2<sup>32</sup>.  The value of the
''length'' property is numerically greater than the name of every
property whose name is an array index; whenever a property of an Array
object is created or changed, other properties are adjusted as
necessary to maintain this invariant.  Specifically, whenever a
property is added whose name is an array index, the ''length''
property is changed, if necessary, to be one more than the numeric
value of that array index; and whenever the ''length'' property is
changed, every property whose name is an array index whose value is
not smaller than the new length is automatically deleted.  This
constraint applies only to properties of the Array object itself and
is unaffected by ''length'' or array index properties that may be
inherited from its prototype.

<P>The set of //array elements// held by an object are those
properties of the object that are named by nonnegative unsigned
integers numerically less than the object's ''length'' property.  (If
the object has no ''length'' property then its value is assumed to be
zero, and the object has no array elements.)


<P>The Array class has the following interface:

{{{
dynamic class Array extends Object
{
    function Array(...args) <LDOTS>

    <SIGNATURE file="Array.es" name="meta static function invoke"> <LDOTS>

    <SIGNATURE file="Array.es" name="static function concat"> <LDOTS>
    <SIGNATURE file="Array.es" name="static function every"> <LDOTS>
    <SIGNATURE file="Array.es" name="static function filter"> <LDOTS>
    <SIGNATURE file="Array.es" name="static function forEach"> <LDOTS>
    <SIGNATURE file="Array.es" name="static function indexOf"> <LDOTS>
    <SIGNATURE file="Array.es" name="static function join"> <LDOTS>
    <SIGNATURE file="Array.es" name="static function lastIndexOf"> <LDOTS>
    <SIGNATURE file="Array.es" name="static function map"> <LDOTS>
    <SIGNATURE file="Array.es" name="static function pop"> <LDOTS>
    <SIGNATURE file="Array.es" name="static function push"> <LDOTS>
    <SIGNATURE file="Array.es" name="static function reverse"> <LDOTS>
    <SIGNATURE file="Array.es" name="static function shift"> <LDOTS>
    <SIGNATURE file="Array.es" name="static function slice"> <LDOTS>
    <SIGNATURE file="Array.es" name="static function some"> <LDOTS>
    <SIGNATURE file="Array.es" name="static function sort"> <LDOTS>
    <SIGNATURE file="Array.es" name="static function splice"> <LDOTS>
    <SIGNATURE file="Array.es" name="static function unshift"> <LDOTS>

    static const length: uint = 1
    static const prototype: Object = <LDOTS>

    <SIGNATURE file="Array.es" name="intrinsic function concat"> <LDOTS>
    <SIGNATURE file="Array.es" name="intrinsic function every"> <LDOTS>
    <SIGNATURE file="Array.es" name="intrinsic function filter"> <LDOTS>
    <SIGNATURE file="Array.es" name="intrinsic function forEach"> <LDOTS>
    <SIGNATURE file="Array.es" name="intrinsic function indexOf"> <LDOTS>
    <SIGNATURE file="Array.es" name="intrinsic function join"> <LDOTS>
    <SIGNATURE file="Array.es" name="intrinsic function lastIndexOf"> <LDOTS>
    <SIGNATURE file="Array.es" name="intrinsic function map"> <LDOTS>
    <SIGNATURE file="Array.es" name="intrinsic function pop"> <LDOTS>
    <SIGNATURE file="Array.es" name="intrinsic function push"> <LDOTS>
    <SIGNATURE file="Array.es" name="intrinsic function reverse"> <LDOTS>
    <SIGNATURE file="Array.es" name="intrinsic function shift"> <LDOTS>
    <SIGNATURE file="Array.es" name="intrinsic function slice"> <LDOTS>
    <SIGNATURE file="Array.es" name="intrinsic function some"> <LDOTS>
    <SIGNATURE file="Array.es" name="intrinsic function sort"> <LDOTS>
    <SIGNATURE file="Array.es" name="intrinsic function splice"> <LDOTS>
    <SIGNATURE file="Array.es" name="intrinsic function unshift"> <LDOTS>

    function get length(): uint <LDOTS>
    function set length(len: uint): void <LDOTS>
}
}}}


== The Array Constructor Called as a Function ==

<P>When ''Array'' is called as a function rather than as a constructor,
it creates and initialises a new Array object. Thus the function call
''Array(<LDOTS>)'' is equivalent to the object creation expression new
''Array(<LDOTS>)'' with the same arguments.

=== Array ( ...items ) ===

<P>When the ''Array'' class is invoked as a function the following steps
are taken:

<INCLUDE file="Array.es" name="meta static function invoke">


== The Array Constructor ==

When ''Array'' is called as part of a new expression, it is a
constructor: it initialises the newly created object.

=== new Array ( ...items ) ===

<p>The [[Prototype]] property of the newly constructed object is set
to the original Array prototype object, the one that is the initial
value of ''Array.prototype'' (section <XREF target="Array.prototype">).

<p>The [[Class]] property of the newly constructed object is set to
''"Array"''.

<P>The newly constructed object is initialized with a ''length'' property and
array elements in the following manner:

<INCLUDE file="Array.es" name="function Array">


== Methods on the Array Class ==

<P>The Array class provides a number of methods for manipulating array
elements.  These methods are intentionally <em>generic</em>; they do
not require that their //object// argument be an Array object.
Therefore they can be applied to other kinds of objects as well.
Whether the generic Array methods can be applied successfully to a
host object is implementation-dependent.

<COMP>The methods on the Array class are all new in 4th edition.


=== Array.concat ( object, ...items ) ===

<P>When the ''concat'' method is called with an //object// and zero or
more additional arguments //items//, it returns a new Array containing
the array elements of //object// followed by the array elements of
each //item// in order.

<INCLUDE file="Array.es" name="static function concat">
<INCLUDE file="Array.es" name="helper static function concat">

<P>The helper ''concat'' method is also used by the intrinsic and
prototype variants of ''concat''.

=== Array.every ( object, checker, thisObj=null ) ===

<P>When the ''every'' method is called with an //object//, a function
//checker//, and optionally an object //thisObj//, it calls
//checker// on every array element in //object// in increasing
numerical index order, returning **false** as soon as //checker//
returns a false value, otherwise returning **true** if all the calls
return true values.

<P>//Checker// is called with three arguments: the property value, the
property index, and //object// itself.  The //thisObj// is used as the
''this'' object in the call.

<INCLUDE file="Array.es" name="static function every">

=== Array.filter ( object, checker, thisObj=null ) ===

<P>When the ''filter'' method is called with an //object//, a
function //checker//, and optionally an object //thisObj//, it calls
//checker// on every array element in //object// in increasing
numerical index order, collecting all the elements for which
//checker// returns a true value.

<P>//Checker// is called with three arguments: the property value, the
property index, and //object// itself.  The //thisObj// is used as the
''this'' object in the call.

<P>The ''filter'' method returns a new Array object containing the
elements that were collected, in the order they were collected.

<INCLUDE file="Array.es" name="static function filter">

=== Array.forEach ( object, eacher, thisObj=null ) ===

<P>When the ''forEach'' method is called with an //object//, a
function //eacher//, and optionally an object //thisObj//, it calls
//eacher// on every array element in //object// in increasing
numerical index order.  The return value of //eacher//, if any, is
discarded.

<P>//Eacher// is called with three arguments: the property value, the
property index, and //object// itself.  The //thisObj// is used as the
''this'' object in the call.

<P>The ''forEach'' method does not return a value.

<INCLUDE file="Array.es" name="static function forEach">

=== Array.indexOf ( object, value, from=0 ) ===

<P>When the ''indexOf'' method is called with an //object//, a
//value//, and optionally a starting index //from//, it compares the
//value// to each array element in //object// in increasing numerical
index order, returning the array index the first time //value// is
equal to an element.

<P>//From// provides the starting index value; it is rounded toward
zero before use.  If //from// is negative, it is treated as
''//object//.length+//from//''.

<INCLUDE file="Array.es" name="static function indexOf">

=== Array.join ( object, separator="," ) ===

<P>The array elements of //object// are converted to strings, and
these strings are then concatenated, separated by occurrences of
//separator//.

<INCLUDE file="Array.es" name="static function join">

=== Array.lastIndexOf ( object, value, from=NaN ) ===

<P>When the ''lastIndexOf'' method is called with an //object//, a
//value//, and optionally a starting index //from//, it compares the
//value// to each array element in //object// in decreasing numerical
index order, returning the array index the first time //value// is
equal to an element.

<P>//From// provides the starting index value; it is rounded toward
zero before use.  If //from// is negative, it is treated as
''//object//.length+//from//''.

<INCLUDE file="Array.es" name="static function lastIndexOf">

=== Array.map ( object, mapper [ , thisObj ] ) ===

<P>When the ''map'' method is called with an //object//, a function
//mapper//, and optionally an object //thisObj//, it calls //mapper//
on every array element in //object// in increasing numerical index
order.

<P>//Mapper// is called with three arguments: the property value, the
property index, and //object// itself.  The //thisObj// is used as the
''this'' object in the call (defaulting to the global object if it is
**null**).

<P>The ''map'' method returns a new Array object where the array
element at index //i// is the value returned from the call to
//mapper// on //object[i]//.

<INCLUDE file="Array.es" name="static function map">

=== Array.pop ( object ) ===

<P>The last array element of //object// is removed from //object// and
returned.

<INCLUDE file="Array.es" name="static function pop">

=== Array.push ( object, ...items ) ===

<P>The //items// are appended to the end of the array elements of
//object//, in the order in which they appear.  The new ''length''
propety of the object is returned as the result of the call.

<p>When the ''push'' method is called with an //object// and zero or more
arguments //item1//, //item2//, etc., the following steps are taken:

<INCLUDE file="Array.es" name="static function push">
<INCLUDE file="Array.es" name="helper static function push">

<P>The helper ''push'' method is also used by the intrinsic and
prototype variants of ''push''.

=== Array.reverse ( object ) ===

<P>The array elements of //object// are rearranged so as to reverse
their order.  //Object// is returned as the result of the call.

<INCLUDE file="Array.es" name="static function reverse">

=== Array.shift ( object ) ===

<P>The array element called ''0'' in //object// is removed from
//object// and returned.

<INCLUDE file="Array.es" name="static function shift">

=== Array.slice ( object, start, end ) ===

<P>The ''slice'' method takes three arguments, an //object//,
//start//, and //end//, and returns an array containing the array
elements of //object// from element //start// up to, but not
including, element //end// (or through the end of the array elements
if //end// is undefined).  If //start// is negative, it is treated as
''//object//.length+//start//''.  If //end// is negative, it is
treated as ''//object//.length+//end//''.  The following steps are
taken:

<INCLUDE file="Array.es" name="static function slice">
<INCLUDE file="Array.es" name="helper static function clamp">

=== Array.some ( object, checker [ , thisObj ] ) ===

<P>When the ''some'' method is called with an //object//, a function
//checker//, and optionally an object //thisObj//, it calls
//checker// on every array element in //object// in increasing
numerical index order, returning **true** as soon as //checker//
returns a true value, otherwise returning **false** if all the calls
return false values.

<P>//Checker// is called with three arguments: the property value, the
property index, and the object itself.  The //thisObj// is used as the
''this'' object in the call.

<INCLUDE file="Array.es" name="static function some">

=== Array.sort (object, comparefn) ===

<P>The array elements of //object// are sorted.  The sort is not
necessarily stable (that is, elements that compare equal do not
necessarily remain in their original order). If //comparefn// is not
**undefined**, it should be a function that accepts two arguments
//x// and //y// and returns a negative value if //x <LT> y//, zero if
//x = y//, or a positive value if //x <GT> y//.

<p>If //comparefn// is not **undefined** and is not a consistent
comparison function for the array elements of //object// (see below),
the behaviour of ''sort'' is implementation-defined.  Let //len// be
''uint(object.length)''.  If there exist integers //i// and //j//
and an object //P// such that all of the conditions below are
satisfied then the behaviour of ''sort'' is implementation-defined:

<FIXME>Probably use ''uint(x)'' rather than ''ToUint32(x)'' throughout.

<FIXME>The use of ''ToString'' is not suitable for ES4 (though it is
correct).  See comments at the top of the Array section.

<ul>
<li> //0 <LEQ> i <LT> len//
<li> //0 <LEQ> j <LT> len//
<li> //object// does not have a property with name ''ToString(//i//)''
<li> //P// is obtained by following one or more [[Prototype]] properties starting at this
<li> //P// has a property with name ''ToString(//j//)''
</ul>

<p>Otherwise the following steps are taken.

<OL>
<LI> Let //M// be the result of calling the [[Get]] method of //object// with argument ''"length"''.
<LI> Let //L// be the result of ''ToUint32(//M//)''.
<LI> Perform an implementation-dependent sequence of calls to the [[Get]] , [[Put]], and [[Delete]] methods of 
//object// and to //SortCompare// (described below), where the first argument for each call to [[Get]], [[Put]], or
[[Delete]] is a nonnegative integer less than //L// and where the arguments for calls to //SortCompare// are
results of previous calls to the [[Get]] method.
<LI> Return //object//.
</OL>

<P>The returned object must have the following two properties.

<ul> <li> There must be some mathematical permutation <PI> of the
nonnegative integers less than //L//, such that for every nonnegative
integer //j// less than //L//, if property //old[j]// existed, then
//new[<PI>(j)]// is exactly the same value as //old[j]//, but if
property //old[j]// did not exist, then //new[<PI>(j)]// does not
exist.  <li> Then for all nonnegative integers //j// and //k//, each
less than //L//, if //SortCompare(j,k) < 0// (see //SortCompare//
below), then //<PI>(j) < <PI>(k)//.  </ul>

<P>Here the notation //old[j]// is used to refer to the hypothetical
result of calling the [[Get]] method of this object with argument
//j// before this function is executed, and the notation //new[j]// to
refer to the hypothetical result of calling the [[Get]] method of this
object with argument //j// after this function has been executed.

<P>A function //comparefn// is a consistent comparison function for a set of values //S// if all of the requirements below are
met for all values //a//, //b//, and //c// (possibly the same value) in the set //S//: The notation //a &lt;CF b// means
//comparefn(a,b) <LT> 0//; //a =CF b// means //comparefn(a,b) = 0// (of either sign); and //a >CF b// means //comparefn(a,b) > 0//.

<UL>
<LI> Calling //comparefn(a,b)// always returns the same value //v// when given a specific pair of values //a// and //b// as its
two arguments. Furthermore, //v// has type //Number//, and //v// is not **NaN**. Note that this implies that exactly one of
//a &lt;CF b//, //a =CF b//, and //a >CF b// will be true for a given pair of //a// and //b//.
<LI> //a =CF a// (reflexivity)
<LI> If //a =CF b//, then //b =CF a// (symmetry)
<LI> If //a =CF b// and //b =CF c//, then //a =CF c// (transitivity of //=CF//)
<LI> If //a &lt;CF b// and //b &lt;CF c//, then //a &lt;CF c// (transitivity of //&lt;CF//)
<LI> If //a >CF b// and //b >CF c//, then //a >CF c// (transitivity of //>CF//)
</UL>

<NOTE> The above conditions are necessary and sufficient to ensure that //comparefn// divides the set //S// into equivalence classes
and that these equivalence classes are totally ordered.

<P>When the //SortCompare// operator is called with two arguments //j// and //k//, the following steps are taken:

<INCLUDE file="Array.es" name="helper function sortCompare">

<NOTE> Because non-existent property values always compare greater
than **undefined** property values, and **undefined** always compares
greater than any other value, **undefined** property values always
sort to the end of the result, followed by non-existent property
values.

=== Array.splice ( object, start, deleteCount, ...items ) ===

<P>When the ''splice'' method is called with three or more arguments
//object//, //start//, //deleteCount// and (optionally) some
//items//, the //deleteCount// array elements of the object starting
at array index //start// are replaced by the //items//.  The following
steps are taken:

<INCLUDE file="Array.es" name="static function splice">
<INCLUDE file="Array.es" name="helper static function splice">

<P>The helper ''clamp'' function was defined earlier (see <XREF target="Array.slice">).

=== Array.unshift ( object, ...items ) ===

<P>The //items// are inserted as new array elements at the start of
the //object//, such that their order within the array elements of
//object// is the same as the order in which they appear in the
argument list.

<P>When the unshift method is called with an object and zero or more
//items//, the following steps are taken:

<INCLUDE file="Array.es" name="static function unshift">
<INCLUDE file="Array.es" name="helper static function unshift">


== Properties of the Array Class ==

<p>The value of the internal [[Prototype]] property of the Array
constructor is the Function prototype object (section <XREF
target="Function.prototype">).

<p>Besides the internal properties and the ''length'' property (whose
value is 1), the Array constructor has the following properties:

=== Array.prototype ===

<P>The initial value of ''Array.prototype'' is the Array prototype
object (section <XREF target="Array.prototype">).


== Properties of the Array Prototype Object ==

<P>The value of the internal [[Prototype]] property of the Array
prototype object is the Object prototype object (section <XREF
target="Object.prototype">).

<p>The Array prototype object is itself an array; its [[Class]] is
''"Array"'', and it has a ''length'' property (whose initial value is
+0) and the special internal [[Put]] method described in section
<XREF target="Array.[[Put]]">.

<NOTE>The Array prototype object does not have a ''valueOf'' property
of its own; however, it inherits the ''valueOf'' property from the
Object prototype Object.


=== Array.prototype.constructor ===

<P>The initial value of ''Array.prototype.constructor'' is the
built-in Array constructor.

=== Array.prototype.toString ( ) ===

<P>The result of calling this function is the same as if the built-in
''join'' method were invoked for this object with no argument.

<INCLUDE file="Array.es" name="prototype function toString">

=== Array.prototype.toLocaleString ( ) ===

<P>The elements of this Array are converted to strings using their
''toLocaleString'' methods, and these strings are then concatenated,
separated by occurrences of a separator string that has been derived
in an implementation-defined locale-specific way.  The result of
calling this function is intended to be analogous to the result of
''toString'', except that the result of this function is intended to
be locale-specific.

<p>The result is calculated as follows:

<INCLUDE file="Array.es" name="prototype function toLocaleString">

<NOTE>The first parameter to this function is likely to be used in a
future version of this standard; it is recommended that
implementations do not use this parameter position for anything else.

=== Generic Methods on the Array Prototype Object ===

<P>These methods delegate to their static counterparts, and like their
counterparts, they are generic: they can be transferred to other
objects for use as methods.  Whether these methods can be applied
successfully to a host object is implementation-dependent.

<INCLUDE file="Array.es" name="prototype function concat">
<INCLUDE file="Array.es" name="prototype function every">
<INCLUDE file="Array.es" name="prototype function filter">
<INCLUDE file="Array.es" name="prototype function forEach">
<INCLUDE file="Array.es" name="prototype function indexOf">
<INCLUDE file="Array.es" name="prototype function join">
<INCLUDE file="Array.es" name="prototype function lastIndexOf">
<INCLUDE file="Array.es" name="prototype function map">
<INCLUDE file="Array.es" name="prototype function pop">
<INCLUDE file="Array.es" name="prototype function push">
<INCLUDE file="Array.es" name="prototype function reverse">
<INCLUDE file="Array.es" name="prototype function shift">
<INCLUDE file="Array.es" name="prototype function slice">
<INCLUDE file="Array.es" name="prototype function some">
<INCLUDE file="Array.es" name="prototype function sort">
<INCLUDE file="Array.es" name="prototype function splice">
<INCLUDE file="Array.es" name="prototype function unshift">

<COMP>In the 3rd Edition of this Standard some of the functions on the
Array prototype object had ''length'' properties that did not reflect
those functions' signatures.  In the 4th Edition of this Standard, all
functions on the Array prototype object have ''length'' properties
that follow the general rule stated in section <XREF
target="function-semantics">.


== Properties of Array Instances ==

<P>Array instances inherit properties from the Array prototype object
and also have the following properties.

=== length ===

<P>The ''length'' property of this Array object is always numerically
greater than the name of every property whose name is an array index.


== Method Properties of Array Instances ==

=== Intrinsic methods ===

<P>The intrinsic methods on Array instances delegate to their static
counterparts.  Unlike their static and prototype counterparts, these
methods are bound by their instance and they are not generic.

<INCLUDE file="Array.es" name="override intrinsic function toString">
<INCLUDE file="Array.es" name="override intrinsic function toLocaleString">
<INCLUDE file="Array.es" name="intrinsic function concat">
<INCLUDE file="Array.es" name="intrinsic function every">
<INCLUDE file="Array.es" name="intrinsic function filter">
<INCLUDE file="Array.es" name="intrinsic function forEach">
<INCLUDE file="Array.es" name="intrinsic function indexOf">
<INCLUDE file="Array.es" name="intrinsic function join">
<INCLUDE file="Array.es" name="intrinsic function lastIndexOf">
<INCLUDE file="Array.es" name="intrinsic function map">
<INCLUDE file="Array.es" name="intrinsic function pop">
<INCLUDE file="Array.es" name="intrinsic function push">
<INCLUDE file="Array.es" name="intrinsic function reverse">
<INCLUDE file="Array.es" name="intrinsic function shift">
<INCLUDE file="Array.es" name="intrinsic function slice">
<INCLUDE file="Array.es" name="intrinsic function some">
<INCLUDE file="Array.es" name="intrinsic function sort">
<INCLUDE file="Array.es" name="intrinsic function splice">
<INCLUDE file="Array.es" name="intrinsic function unshift">

=== %%[[Put]]%% (P, V) ===

<P>Array objects use a variation of the [[Put]] method used for other
native ECMAScript objects (section 8.6.2.2).

<P>Assume A is an Array object and P is a string.

<FIXME>P may be not-a-string in ES4.

<P>When the [[Put]] method of A is called with property P and value V, the following steps are taken:

<OL>
<LI> Call the [[CanPut]] method of A with name P.
<LI> If Result(1) is false, return.
<LI> If A doesn't have a property with name P, go to step 7.
<LI> If P is "length", go to step 12.
<LI> Set the value of property P of A to V.
<LI> Go to step 8.
<LI> Create a property with name P, set its value to V and give it empty attributes.
<LI> If P is not an array index, return.
<LI> If ToUint32(P) is less than the value of the length property of A, then return.
<LI> Change (or set) the value of the length property of A to ToUint32(P)+1.
<LI> Return.
<LI> Compute ToUint32(V).
<LI> If Result(12) is not equal to ToNumber(V), throw a RangeError exception.
<LI> For every integer k that is less than the value of the length property of A but not less than Result(12), if A
itself has a property (not an inherited property) named ToString(k), then delete that property.
<LI> Set the value of property P of A to Result(12).
<LI> Return.
</OL>

