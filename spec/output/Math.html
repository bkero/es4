<html>
<head>
<title>The class "Math"</title>
<style>
/* -*- indent-tabs-mode: nil -*- */
.fixme { font-size: smaller; padding-left: 1em; color: red }
.note { font-size: smaller; padding-left: 1em }
.part { font-size: 24pt }
.grammar { font-style: italic }
.indented { padding-left: 3em }
.nonterm { padding-top: 1em }
.xref { border: thin solid red; }
.section { margin-bottom: -1em; font-family: sans-serif; font-size: smaller }
.implsection { margin-bottom: -1em; padding-bottom: 0.3em; font-family: sans-serif; font-size: smaller }
.literal { font-style: normal; font-weight: bold }
H1,H2,H3,H4,H5,H6 { font-family: sans-serif }
H1 { font-size: 14pt }
H2 { font-size: 12pt }
H3 { font-size: 11pt }
H4 { font-size: 10pt }

P code { font-size: 10pt }
code { font-style: normal; font-weight: normal }

pre { font-size: 9pt }

body { counter-reset: chapter section subsection subsubsection subsubsubsection;
       font-size: 10pt; 
       margin: 0.75in }

table { font-size: inherit;
        width: 70%;
        margin: 2em; 
        border: 1px solid lightgrey; }

th { background: lightgrey; }

td { padding: 1em; }

.pcounter:before {
    content: counter(para); 
}

.pcounter {
    position: absolute; left: 0.5in;
    counter-increment: para
}

H1:before {
    padding-right: 1em;
    content: counter(chapter) "  ";
    counter-increment: chapter }

H1 {
    counter-reset: section para;
}

H2:before {
    padding-right: 1em;
    content: counter(chapter) "." counter(section) "  ";
    counter-increment: section }

H2 {
    counter-reset: subsection para;
}

H3:before {
    padding-right: 1em;
    content: counter(chapter) "." counter(section) "." counter(subsection) "  ";
    counter-increment: subsection }

H3 {
    counter-reset: subsubsection para;
}

H4:before {
    padding-right: 1em;
    content: counter(chapter) "." counter(section) "." counter(subsection) "." counter(subsubsection) "  ";
    counter-increment: subsubsection }

H4 {
    counter-reset: para;
}

H5:before {
    padding-right: 1em;
    content: counter(chapter) "." counter(section) "." counter(subsection) "." counter(subsubsection) "." counter(subsubsubsection) "  ";
    counter-increment: subsubsubsection }

H5 {
    counter-reset: para;
}

</style>
</head>

<body>
<H1 id="Math object"> The <code>Math</code> Object </H1>

<PRE>
FILE:                       spec/library/Math.html
DRAFT STATUS:               DRAFT 1 - ROUGH - 2008-06-25
REVIEWED AGAINST ES3:       NO
REVIEWED AGAINST ERRATA:    NO
REVIEWED AGAINST PROPOSALS: NO
REVIEWED AGAINST CODE:      NO
</PRE>

<P><span class="pcounter"></span> The global <code>Math</code> object is a single object that has some named
properties, some of which are functions.  The <code>Math</code> object is the
only instance of an internal helper class called <code>Math</code>.

<P><span class="pcounter"></span> The <code>Math</code> object acts as a container for built-in
mathematics-related functions and constants.


<h2>Synopsis</h2>

<P><span class="pcounter"></span> For convenience of notation the definition of the Math object uses
the helper type name <code>PrimitiveNumber</code>.

<PRE>
helper type PrimitiveNumber = (double|decimal);
</PRE>

<P><span class="pcounter"></span> The intrinsic methods on the math object are restricted to
arguments of the type <code>PrimitiveNumber</code>.

<P><span class="pcounter"></span> The <code>Math</code> object provides the following interface:

<PRE>
helper dynamic final class Math extends Object
{
    intrinsic function abs(x: helper::PrimitiveNumber): helper::PrimitiveNumber &#x0085
    intrinsic function acos(x: helper::PrimitiveNumber): helper::PrimitiveNumber &#x0085
    intrinsic function atan(x: helper::PrimitiveNumber): helper::PrimitiveNumber &#x0085
    intrinsic function atan2(y: helper::PrimitiveNumber, x: helper::PrimitiveNumber): helper::PrimitiveNumber &#x0085
    intrinsic function ceil(x: helper::PrimitiveNumber): helper::PrimitiveNumber &#x0085
    intrinsic function cos(x: helper::PrimitiveNumber): helper::PrimitiveNumber &#x0085
    intrinsic function exp(x: helper::PrimitiveNumber): helper::PrimitiveNumber &#x0085
    intrinsic function floor(x: helper::PrimitiveNumber): helper::PrimitiveNumber &#x0085
    intrinsic function log(x: helper::PrimitiveNumber): helper::PrimitiveNumber &#x0085
    intrinsic function max(x: helper::PrimitiveNumber, y: helper::PrimitiveNumber): helper::PrimitiveNumber &#x0085
    intrinsic function min(x: helper::PrimitiveNumber, y: helper::PrimitiveNumber): helper::PrimitiveNumber &#x0085
    intrinsic function pow(x: helper::PrimitiveNumber, y: helper::PrimitiveNumber): helper::PrimitiveNumber &#x0085
    intrinsic function random(): double &#x0085
    intrinsic function round(x: helper::PrimitiveNumber): helper::PrimitiveNumber &#x0085
    intrinsic function sin(x: helper::PrimitiveNumber): helper::PrimitiveNumber &#x0085
    intrinsic function sqrt(x: helper::PrimitiveNumber): helper::PrimitiveNumber &#x0085
    intrinsic function tan(x: helper::PrimitiveNumber): helper::PrimitiveNumber &#x0085

    const E: double = double.E
    const LN10: double = double.LN10
    const LN2: double = double.LN2
    const LOG2E: double = double.LOG2E
    const LOG10E: double = double.LOG10E
    const PI: double = double.PI
    const SQRT1_2: double = double.SQRT1_2
    const SQRT2: double = double.SQRT2
}
</PRE>

<P><span class="pcounter"></span> The constant values <code>E</code>, <code>LN10</code>, <code>LN2</code>, <code>LOG2E</code>,
<code>LOG10E</code>, <code>PI</code>, <code>SQRT1_2</code>, and <code>SQRT2</code> in the <code>Math</code> class
are of type <code>double</code> for compatibility with 3rd Edition.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  New code may find it more convenient to access these constant
values through the <code>double</code> or <code>decimal</code> classes, as appropriate,
to obtain values with the best precision for the particular type.

<P><span class="pcounter"></span> The <code>Math</code> object additionally provides the following dynamic
function properties.  These functions are not restricted in the types
of arguments they accept, but convert all their arguments to a
primitive number.

<PRE>
    abs:    function (x) &#x0085; ,
    acos:   function (x) &#x0085; ,
    asin:   function (x) &#x0085; ,
    atan:   function (x) &#x0085; ,
    atan2:  function (y,x) &#x0085; ,
    ceil:   function (x) &#x0085; ,
    cos:    function (x) &#x0085; ,
    exp:    function (x) &#x0085; ,
    floor:  function (x) &#x0085; ,
    log:    function (x) &#x0085; ,
    max:    function (...xs) &#x0085; ,
    min:    function (...xs) &#x0085; ,
    pow:    function (x,y) &#x0085; ,
    random: function () &#x0085; ,
    round:  function (x) &#x0085; ,
    sin:    function (x) &#x0085; ,
    sqrt:   function (x) &#x0085; ,
    tan:    function (x) &#x0085;
</PRE>

<P><span class="pcounter"></span> The <code>[[Prototype]]</code> object of the <code>Math</code> object does not contain a
<code>constructor</code> property.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The constraint on <code>constructor</code> is for backward compatibility
and is also necessary to insure that the math object is a singleton
object.  But note that <code>Math.constructor</code> is still defined, it is
accessible through the prototype chain and is <code>Object.constructor</code>.


<h2>Primitive operations on numbers</h2>

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #189.) Describe the following helper and informative
functions here: isPositive, isPositiveZero, isNegativeZero,
isOddInteger.


<h2>Intrinsic function properties of the Math object</h2>

<P><span class="pcounter"></span> In the function descriptions below, the symbols NaN, -0, +0, -&#x221E;
and +&#x221E; refer to the number values described in 8.5.

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  Clean up the cross-reference later.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The behaviour of the functions <code>acos</code>, <code>asin</code>, <code>atan</code>,
<code>atan2</code>, <code>cos</code>, <code>exp</code>, <code>log</code>, <code>pow</code>, <code>sin</code>, and <code>sqrt</code>
is not precisely specified here except to require specific results for
certain argument values that represent boundary cases of interest. For
other argument values, these functions are intended to compute
approximations to the results of familiar mathematical functions, but
some latitude is allowed in the choice of approximation
algorithms. The general intent is that an implementer should be able
to use the same mathematical library for ECMAScript on a given
hardware platform that is available to C programmers on that platform.

<P class="note"> Although the choice of algorithms is left to the
implementation, it is recommended (but not specified by this standard)
that implementations use the approximation algorithms for IEEE 754
arithmetic contained in fdlibm, the freely distributable mathematical
library from Sun Microsystems (<code>fdlibm-comment@sunpro.eng.sun.com</code>).
This specification also requires specific results for certain argument
values that represent boundary cases of interest.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The functions defined in this section preserve the
representation of the argument(s) in the result where this is
reasonable.  All functions map <code>double</code> and <code>decimal</code> arguments to
<code>double</code> and <code>decimal</code> results, respectively.


<h3>intrinsic::abs&nbsp;(x)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span>The intrinsic <code>abs</code> function computes the absolute value of
the number <i>x</i>, which has the same magnitude as <i>x</i> but has
positive sign.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span>The intrinsic <code>abs</code> function returns the absolute value of
<i>x</i>.  The representation of the result is the same as the
representation of <i>x</i>.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span>
<PRE>
intrinsic function abs(x: <em>PrimitiveNumber</em>): <em>PrimitiveNumber</em> {
    switch type (x) {
    case (n: double) {
        if (isNaN(n)) return n;
        if (x == 0) return 0;
        return n &#60; 0 ? -n : n;
    }
    case (n: decimal) {
        if (isNaN(n)) return n;
        if (x == 0m) return 0m;
        return n &#60; 0m ? -n : n;
    }
    }
}
</PRE>


<h3>intrinsic::acos&nbsp;(x)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>acos</code> function computes an
implementation-dependent approximation to the arc cosine of the number
<i>x</i>.  The result is expressed in radians and ranges from +0 to +&#x03C0;.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>acos</code> function returns a floating-point number.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function acos(x: <em>PrimitiveNumber</em>): <em>PrimitiveNumber</em> {
    switch type (x) {
    case (n: double) {
        if (isNaN(n) || n > 1 || n &#60; -1) return NaN;
        if (n == 1) return 0;
        return <em>acosDouble</em>(n);
    }
    case (n: decimal) {
        if (isNaN(n) || n > 1m || n &#60; 1m) return decimal.NaN;
        if (n == 1m) return 0m;
        return <em>acosDecimal</em>(n);
    }
    }
}
</PRE>

<P><span class="pcounter"></span> The informative functions <code>acosDouble</code> and <code>acosDecimal</code>
implement representation-preserving approximate computation of the arc
cosine of their argument.

<PRE>
informative function acosDouble(x: double): double &#x0085
informative function acosDecimal(x: decimal): decimal &#x0085
</PRE>


<h3>intrinsic::asin&nbsp;(x)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>asin</code> function computes an
implementation-dependent approximation to the arc sine of the number
<i>x</i>.  The result is expressed in radians and ranges from -&#x03C0;/2 to
+&#x03C0;/2.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>asin</code> function returns a floating-point number.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function asin(x: <em>PrimitiveNumber</em>): <em>PrimitiveNumber</em> {
    switch type (x) {
    case (n: double) {
        if (isNaN(n) || n > 1 || n &#60; -1) return NaN;
        if (n == 0) return n;
        return <em>asinDouble</em>(n);
    }
    case (n: decimal) {
        if (isNaN(n) || n > 1m || n &#60; 1m) return decimal.NaN;
        if (n == 0m) return n;
        return <em>asinDecimal</em>(n);
    }
    }
}
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp; The intrinsic <code>asin</code> function preserves the sign of <i>x</i> if x is 0.

<P><span class="pcounter"></span> The informative functions <code>asinDouble</code> and <code>asinDecimal</code>
implement representation-preserving approximate computation of the arc
sine of their argument.

<PRE>
informative function asinDouble(x: double): double &#x0085
informative function asinDecimal(x: decimal): decimal &#x0085
</PRE>


<h3>intrinsic::atan&nbsp;(x)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>atan</code> function computes an
implementation-dependent approximation to the arc tangent of the
number <i>x</i>.  The result is expressed in radians and ranges from
-&#x03C0;/2 to +&#x03C0;/2.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>atan</code> function returns a floating-point number.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function atan(x: <em>PrimitiveNumber</em>): <em>PrimitiveNumber</em> {
    switch type (x) {
    case (n: double) {
        if (isNaN(n) || n == 0) return n;
        if (!isFinite(n))
            return copysign(double.PI / 2, n);
        return <em>atanDouble</em>(n);
    }
    case (n: decimal) {
        if (isNaN(n) || n == 0m) return n;
        if (!isFinite(n))
            return copysign(decimal.PI / 2m, n);
        return <em>atanDecimal</em>(n);
    }
    }
}
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp; The intrinsic <code>atan</code> function preserves the sign of <i>x</i> if x is 0.

<P><span class="pcounter"></span> The informative functions <code>atanDouble</code> and <code>atanDecimal</code>
implement representation-preserving approximate computation of the arc
tangent of their argument.

<PRE>
informative function atanDouble(x: double): double &#x0085
informative function atanDecimal(x: decimal): decimal &#x0085
</PRE>

<h3>intrinsic::atan2&nbsp;(y,&nbsp;x)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>atan2</code> function computes an
implementation-dependent approximation to the arc tangent of the
quotient <i>y/x</i> of the numbers <i>y</i> and <i>x</i>, where the signs of
<i>y</i> and <i>x</i> are used to determine the quadrant of the result.
Note that it is intentional and traditional for the two-argument arc
tangent function that the argument named <i>y</i> be first and the
argument named <i>x</i> be second. The result is expressed in radians and
ranges from -&#x03C0; to +&#x03C0;.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>atan2</code> function returns a floating-point
number.  The result is <code>decimal</code> of <i>y</i> or <i>x</i> is <code>decimal</code>,
otherwise <code>double</code>.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function atan2(y: <em>PrimitiveNumber</em>, x: <em>PrimitiveNumber</em>): <em>PrimitiveNumber</em> {
    if (y is decimal && !(x is decimal))
        x = decimal(x);
    else if (x is decimal && !(y is decimal))
        y = decimal(y);

    let Type = (x is double) ? double : decimal;

    if (isNaN(x) || isNaN(y))
        return Type.NaN;
    if (y > 0 && x == 0)
        return Type.PI/2;
    if (<em>isPositiveZero</em>(y))
        return <em>isPositive</em>(x) ? Type(+0) : Type.PI;
    if (<em>isNegativeZero</em>(y))
        return <em>isPositive</em>(x) ? Type(-0) : -Type.PI;
    if (y &#60; 0 && x == 0)
        return -Type.PI/2;
    if (y != 0 && isFinite(y) && !isFinite(x) && x > 0)
        return Type(copysign(0, y));
    if (y != 0 && isFinite(y) && !isFinite(x) && x &#60; 0)
        return copysign(Type.PI, y);
    if (!isFinite(y) && isFinite(x))
        return copysign(Type.PI/2, y);
    if (!isFinite(y) && !isFinite(x))
        return copysign(x > 0 ? Type.PI/4 : 3*Type.PI/4, y);

    if (Type == double)
        return <em>atan2Double</em>(y, x);
    return <em>atan2Decimal</em>(y, x);
}
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  An implementation is free to produce approximations for all
computations involving <code>PI</code> in the preceding algorithm.

<P><span class="pcounter"></span> The informative functions <code>atan2Double</code> and <code>atan2Decimal</code>
implement representation-preserving approximate computation of the arc
tangent of the quotient of their arguments.

<PRE>
informative function atan2Double(y: double, x: double): double &#x0085
informative function atan2Decimal(y: decimal, x: decimal): decimal &#x0085
</PRE>


<h3>intrinsic::ceil&nbsp;(x)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>ceil</code> function computes the smallest (closest
to -&#x221E;) number value that is not less than <i>x</i> and is equal to
a mathematical integer. If <i>x</i> is already an integer, the result is
<i>x</i>.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The value of <code>Math.ceil(<i>x</i>)</code> is the same as the value of
<code>-Math.floor(-<i>x</i>)</code>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>ceil</code> function returns a number in the same
representation as <i>x</i>.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function ceil(x: <em>PrimitiveNumber</em>): <em>PrimitiveNumber</em> {
    switch type (x) {
    case (n: double) {
        if (!isFinite(n) || n == 0) return n;
        if (-1 &#60; n && n &#60; 0) return -0;
        return <em>ceilDouble</em>(n);
    }
    case (n: decimal) {
        if (!isFinite(n) || n == 0m) return n;
        if (-1m &#60; n && n &#60; 0m) return -0m;
        return <em>ceilDecimal</em>(n);
    }
    }
}
</PRE>

<P><span class="pcounter"></span> The informative functions <code>ceilDouble</code> and <code>ceilDecimal</code>
implement representation-preserving computation of the ceiling of
their argument.

<PRE>
informative function ceilDouble(x: double): double &#x0085
informative function ceilDecimal(x: decimal): decimal &#x0085
</PRE>


<h3>intrinsic::cos&nbsp;(x)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>cos</code> method computes an
implementation-dependent approximation to the cosine of the number
<i>x</i>.  The argument is expressed in radians.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>cos</code> function returns a floating-point number.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function cos(x: <em>PrimitiveNumber</em>): <em>PrimitiveNumber</em> {
    switch type (x) {
    case (n: double) {
        if (!isFinite(n)) return NaN;
        if (n == 0) return 1;
        return <em>cosDouble</em>(n);
    }
    case (n: decimal) {
        if (!isFinite(n)) return decimal.NaN;
        if (n == 0m) return 1m;
        return <em>cosDecimal</em>(n);
    }
    }
}
</PRE>

<P><span class="pcounter"></span> The informative functions <code>cosDouble</code> and <code>cosDecimal</code>
implement representation-preserving approximate computation of the cosine
of their argument.

<PRE>
informative function cosDouble(x: double): double &#x0085
informative function cosDecimal(x: decimal): decimal &#x0085
</PRE>

<h3>intrinsic::exp&nbsp;(x)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>exp</code> function computes an
implementation-dependent approximation to the exponential function of
the number <i>x</i> (<i>e<SUP>x</SUP></i>, where <i>e</i> is the base of the
natural logarithms).

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>exp</code> function returns a floating-point number.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function exp(x: <em>PrimitiveNumber</em>): <em>PrimitiveNumber</em> {
    switch type (x) {
    case (n: double) {
        if (isNaN(n)) return n;
        if (n == 0) return 1d;
        if (n == Infinity) return Infinity;
        if (n == -Infinity) return 0;
        return <em>expDouble</em>(n);
    }
    case (n: decimal) {
        if (isNaN(n)) return n;
        if (n == 0m) return 1m;
        if (n == decimal.POSITIVE_INFINITY) return decimal.POSITIVE_INFINITY;
        if (n == decimal.NEGATIVE_INFINITY) return 0m;
        return <em>expDecimal</em>(n);
    }
    }
}
</PRE>

<P><span class="pcounter"></span> The informative functions <code>expDouble</code> and <code>expDecimal</code>
implement representation-preserving approximate computation of the
exponential function of their argument.

<PRE>
informative function expDouble(x: double): double &#x0085
informative function expDecimal(x: decimal): decimal &#x0085
</PRE>

<h3>intrinsic::floor&nbsp;(x)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>floor</code> function computes the greatest (closest
to +&#x221E;) number value that is not greater than <i>x</i> and is equal
to a mathematical integer. If <i>x</i> is already an integer, the result
is <i>x</i>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>floor</code> function returns a number in the same
representation as <i>x</i>.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function floor(x: <em>PrimitiveNumber</em>): <em>PrimitiveNumber</em> {
    switch type (x) {
    case (n: double) {
        if (!isFinite(n) || n == 0) return n;
        if (0 &#60; n && n &#60; 1) return +0;
        return <em>floorDouble</em>(n);
    }
    case (n: decimal) {
        if (!isFinite(n) || n == 0m) return n;
        if (0m &#60; n && n &#60; 1m) return +0m;
        return <em>floorDecimal</em>(n);
    }
    }
}
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The value of <code>Math.floor(<i>x</i>)</code> is the same as the value of
<code>-Math.ceil(-<i>x</i>)</code>.

<P><span class="pcounter"></span> The informative functions <code>floorDouble</code> and <code>floorDecimal</code>
implement representation-preserving computation of the floor of their
argument.

<PRE>
informative function floorDouble(x: double): double &#x0085
informative function floorDecimal(x: decimal): decimal &#x0085
</PRE>


<h3>intrinsic::log&nbsp;(x)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>log</code> function computes an
implementation-dependent approximation to the natural logarithm of the
number <i>x</i>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>log</code> function returns a floating-point number.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function log(x: <em>PrimitiveNumber</em>): <em>PrimitiveNumber</em> {
    switch type (x) {
    case (n: double) {
        if (isNaN(n) || n &#60; 0) return NaN;
        if (n == 0) return -Infinity;
        if (n == 1) return +0;
        if (n == Infinity) return n;
        return <em>logDouble</em>(n);
    }
    case (n: decimal) {
        if (isNaN(n) || n &#60; 0m) return decimal.NaN;
        if (n == 0m) return decimal.NEGATIVE_INFINITY;
        if (n == 1m) return +0m;
        if (n == decimal.POSITIVE_INFINITY) return n;
        return <em>logDecimal</em>(n);
    }
    }
}
</PRE>

<P><span class="pcounter"></span> The informative functions <code>logDouble</code> and <code>logDecimal</code>
implement representation-preserving approximate computation of the
natural logarithm of their argument.

<PRE>
informative function logDouble(x: double): double &#x0085
informative function logDecimal(x: decimal): decimal &#x0085
</PRE>


<h3>intrinsic::max&nbsp;(x,&nbsp;y)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>max</code> method selects the numerically largest
(closest to +&#x221E;) value among <i>x</i> and <i>y</i>.  +0 is
considered larger than -0.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>max</code> method returns either <i>x</i> or <i>y</i>.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function max(x: <em>PrimitiveNumber</em>, y: <em>PrimitiveNumber</em>): <em>PrimitiveNumber</em> {
    if (isNaN(x)) return x;
    if (isNaN(y)) return y;
    if (x > y) return x;
    if (y > x) return y;
    if (x != 0) return x;

    let x_sign = sign(x),
        y_sign = sign(y);
    if (x_sign > y_sign) return x;
    if (y_sign > x_sign) return y;
    return x;
}
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  If <i>x</i> and <i>y</i> are numerically equal (and of the same sign
if they are both 0) then the implementation is free to return either
one of them.

<h3>intrinsic::min&nbsp;(x,&nbsp;y)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>min</code> method selects the numerically smallest
(closest to -&#x221E;) number among <i>x</i> and <i>y</i>.  -0 is
considered smaller than +0.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>min</code> method returns either <i>x</i> or <i>y</i>.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function min(x: <em>PrimitiveNumber</em>, y: <em>PrimitiveNumber</em>): <em>PrimitiveNumber</em> {
    if (isNaN(x)) return x;
    if (isNaN(y)) return y;
    if (x &#60; y) return x;
    if (y &#60; x) return y;
    if (x != 0) return x;

    let x_sign = sign(x),
        y_sign = sign(y);
    if (x_sign &#60; y_sign) return x;
    if (y_sign &#60; x_sign) return y;
    return x;
}
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  If <i>x</i> and <i>y</i> are numerically equal (and of the same sign
if they are both 0) then the implementation is free to return either
one of them.

<h3>intrinsic::pow&nbsp;(x,&nbsp;y)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>pow</code> function computes an
implementation-dependent approximation to the result of raising <i>x</i>
to the power <i>y</i>.

<P><span class="pcounter"></span> The intrinsic <code>pow</code> function produces a result in the
representation of <i>x</i>.  

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>pow</code> function returns a number.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function pow(x: <em>PrimitiveNumber</em>, y: <em>PrimitiveNumber</em>): <em>PrimitiveNumber</em> {
    if (x is decimal && !(y is decimal))
        y = decimal(y);
    else if (y is decimal && !(x is decimal))
        x = decimal(x);

    let Type = (x is double) ? double : decimal;

    if (isNaN(y)) return Type.NaN;
    if (y == 0) return Type(1);
    if (isNaN(x) && y != 0) return Type.NaN;
    if (abs(x) > 1 && y == Infinity) return Type.POSITIVE_INFINITY;
    if (abs(x) > 1 && y == -Infinity) return Type(+0);
    if (abs(x) == 1 && y == Infinity) return Type.NaN;
    if (abs(x) == 1 && y == -Infinity) return Type.NaN;
    if (abs(x) &#60; 1 && y == Infinity) return Type(+0);
    if (abs(x) &#60; 1 && y == -Infinity) return Type.POSITIVE_INFINITY;
    if (x == Infinity && y > 0) return Type.POSITIVE_INFINITY;
    if (x == Infinity && y &#60; 0) return Type(+0);
    if (x == -Infinity && y > 0 && <em>isOddInteger</em>(y)) return Type.NEGATIVE_INFINITY;
    if (x == -Infinity && y > 0 && !<em>isOddInteger</em>(y)) return Type.POSITIVE_INFINITY;
    if (x == -Infinity && y &#60; 0 && <em>isOddInteger</em>(y)) return Type(-0);
    if (x == -Infinity && y &#60; 0 && !<em>isOddInteger</em>(y)) return Type(+0);
    if (x == 0 && y > 0) return Type(+0);
    if (x == 0 && y &#60; 0) return Type.POSITIVE_INFINITY;
    if (<em>isNegativeZero</em>(x) && y > 0 && <em>isOddInteger</em>(y)) return Type(-0);
    if (<em>isNegativeZero</em>(x) && y > 0 && !<em>isOddInteger</em>(y)) return Type(+0);
    if (<em>isNegativeZero</em>(x) && y &#60; 0 && <em>isOddInteger</em>(y)) return Type.NEGATIVE_INFINITY;
    if (<em>isNegativeZero</em>(x) && y &#60; 0 && !<em>isOddInteger</em>(y)) return Type.POSITIVE_INFINITY;
    if (x &#60; 0 && isFinite(x) && isFinite(y) && !isIntegral(y)) return Type.NaN;

    if (Type == double)
        return <em>powDouble</em>(x, y);
    return <em>powDecimal</em>(x, y);
}
</PRE>


<P><span class="pcounter"></span> The informative functions <code>powDouble</code> and <code>powDecimal</code>
implement representation-dependent computation of the value <i>x<SUP>y</SUP></i>.

<PRE>
informative function powDouble(x: double, y: double): double &#x0085
informative function powDecimal(x: decimal, y: decimal): decimal &#x0085
</PRE>

<h3>intrinsic::random&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>random</code> function computes a <code>double</code> value
with positive sign, greater than or equal to 0 but less than 1, chosen
randomly or pseudo randomly with approximately uniform distribution
over that range, using an implementation-dependent algorithm or
strategy. This function takes no arguments.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>random</code> function returns a <code>double</code>.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span> The intrinsic <code>random</code> function is implementation-dependent.

<h3>intrinsic::round&nbsp;(x)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>round</code> function computes the number value that
is closest to <i>x</i> and is equal to a mathematical integer. If two
integer number values are equally close to <i>x</i>, then the result is the
number value that is closer to +&#x221E;. If <i>x</i> is already an integer,
the result is <i>x</i>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>round</code> function returns a number, the representation
of which is always the same as the representation of the input <i>x</i>.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function round(x: <em>PrimitiveNumber</em>): <em>PrimitiveNumber</em> {
    switch type (x) {
    case (n: double) {
        if (!isFinite(n) || n == 0) return n;
        if (0 &#60; n && n &#60; 0.5) return +0;
        if (-0.5 &#60; n && n &#60; 0) return -0;
        return <em>roundDouble</em>(n);
    }
    case (n: decimal) {
        if (!isFinite(n) || n == 0m) return n;
        if (0m &#60; n && n &#60; 0.5m) return +0m;
        if (-0.5m &#60; n && n &#60; 0m) return -0m;
        return <em>roundDecimal</em>(n);
    }
    }
}
</PRE>

<P><span class="pcounter"></span> The informative functions <code>roundDouble</code> and <code>roundDecimal</code>
implement representation-preserving computation of the rounded value
of their argument.

<PRE>
informative function roundDouble(x: double):double &#x0085
informative function roundDecimal(x: decimal):decimal &#x0085
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp; 
The intrinsic <code>round</code> function preserves the sign of <i>x</i> if <i>x</i> is 0.

<p class="note"><b>NOTE</b>&nbsp;&nbsp; 
<code>Math.round(3.5)</code> returns 4, but <code>Math.round(-3.5)</code> returns -3.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The value of <code>Math.round(<i>x</i>)</code> is the same as the value of
<code>Math.floor(<i>x</i>+0.5)</code>, except when <i>x</i> is -0 or is less than 0
but greater than or equal to -0.5; for these cases
<code>Math.round(<i>x</i>)</code> returns -0, but <code>Math.floor(<i>x</i>+0.5)</code>
returns +0.


<h3>intrinsic::sin&nbsp;(x)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>sin</code> function computes an
implementation-dependent approximation to the sine of the number
<i>x</i>.  The argument is expressed in radians.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>sin</code> function returns a floating-point number.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function sin(x: <em>PrimitiveNumber</em>): <em>PrimitiveNumber</em> {
    switch type (x) {
    case (n: double) {
        if (!isFinite(n)) return NaN;
        if (n == 0) return n;
        return <em>sinDouble</em>(n);
    }
    case (n: decimal) {
        if (!isFinite(n)) return decimal.NaN;
        if (n == 0m) return n;
        return <em>sinDecimal</em>(n);
    }
    }
}
</PRE>

<P><span class="pcounter"></span> The informative functions <code>sinDouble</code> and <code>sinDecimal</code>
implement representation-preserving approximate computation of the sine
of their argument.

<PRE>
informative function sinDouble(x: double):double &#x0085
informative function sinDecimal(x: decimal):decimal &#x0085
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp; 
The intrinsic <code>sin</code> function preserves the sign of <i>x</i> if <i>x</i> is 0.


<h3>intrinsic::sqrt&nbsp;(x)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>sqrt</code> method computes an
implementation-dependent approximation to the square root of the
number <i>x</i>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>sqrt</code> method returns a number.  The
representation of the result is the same as the representation of
<i>x</i>.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function sqrt(x: <em>PrimitiveNumber</em>): <em>PrimitiveNumber</em> {
    switch type (x) {
    case (n: double) {
        if (isNaN(n) || n &#60; 0) return NaN;
        if (n == 0 || n == Infinity) return n;
        return <em>sqrtDouble</em>(n);
    }
    case (n: decimal) {
        if (isNaN(n) || n &#60; 0m) return decimal.NaN;
        if (n == 0m || n == decimal.POSITIVE_INFINITY) return n;
        return <em>sqrtDecimal</em>(n);
    }
    }
}
</PRE>


<h3>intrinsic::tan&nbsp;(x)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>tan</code> function computes an
implementation-dependent approximation to the tangent of <i>x</i>.  The
argument is expressed in radians.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>tan</code> function returns a floating-point number.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function sin(x: <em>PrimitiveNumber</em>): <em>PrimitiveNumber</em> {
    switch type (x) {
    case (n: double) {
        if (!isFinite(n)) return NaN;
        if (n == 0) return n;
        return <em>sinDouble</em>(n);
    }
    case (n: decimal) {
        if (!isFinite(n)) return decimal.NaN;
        if (n == 0m) return n;
        return <em>sinDecimal</em>(n);
    }
    }
}
</PRE>

<P><span class="pcounter"></span> The informative functions <code>tanDouble</code> and <code>tanDecimal</code>
implement representation-preserving approximate computation of the tangent
of their argument.

<PRE>
informative function tanDouble(x: double):double &#x0085
informative function tanDecimal(x: decimal):decimal &#x0085
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp; 
The intrinsic <code>tan</code> function preserves the sign of <i>x</i> if <i>x</i> is 0.


<h2>Other function properties of the Math object</h2>

<P><span class="pcounter"></span> Every function listed in this section applies the <code>toPrimitiveNumber</code>
function to each of its arguments (in left-to-right order if there is
more than one) and then performs a computation on the resulting number
value(s) by invoking the corresponding intrinsic method.

<PRE>
Math.public::abs =
    function (x) Math.abs(<em>toPrimitiveNumber</em>(x));
</PRE>
<PRE>
Math.public::acos =
    function (x) Math.acos(<em>toPrimitiveNumber</em>(x));
</PRE>
<PRE>
Math.public::asin =
    function (x) Math.asin(<em>toPrimitiveNumber</em>(x));
</PRE>
<PRE>
Math.public::atan =
    function (x) Math.atan(<em>toPrimitiveNumber</em>(x));
</PRE>
<PRE>
Math.public::atan2 =
    function (y,x)
        Math.atan2(<em>toPrimitiveNumber</em>(y), <em>toPrimitiveNumber</em>(x));
</PRE>
<PRE>
Math.public::ceil =
    function (x) Math.ceil(<em>toPrimitiveNumber</em>(x));
</PRE>
<PRE>
Math.public::cos =
    function (x) Math.cos(<em>toPrimitiveNumber</em>(x));
</PRE>
<PRE>
Math.public::exp =
    function (x) Math.exp(<em>toPrimitiveNumber</em>(x));
</PRE>
<PRE>
Math.public::floor =
    function (x) Math.floor(<em>toPrimitiveNumber</em>(x));
</PRE>
<PRE>
Math.public::log =
    function (x) Math.log(<em>toPrimitiveNumber</em>(x));
</PRE>
<PRE>
Math.public::pow =
    function (x, y)
        Math.pow(<em>toPrimitiveNumber</em>(x), <em>toPrimitiveNumber</em>(y));
</PRE>
<PRE>
Math.public::random =
    function () Math.random();
</PRE>
<PRE>
Math.public::round =
    function (x) Math.round(<em>toPrimitiveNumber</em>(x));
</PRE>
<PRE>
Math.public::sin =
    function (x) Math.sin(<em>toPrimitiveNumber</em>(x));
</PRE>
<PRE>
Math.public::sqrt =
    function (x) Math.sqrt(<em>toPrimitiveNumber</em>(x));
</PRE>
<PRE>
Math.public::tan =
    function (x) Math.atan(<em>toPrimitiveNumber</em>(x));
</PRE>

<P><span class="pcounter"></span> The <code>max</code> and <code>min</code> functions are more general than their
corresponding intrinsic methods: they accept zero or more arguments
and apply their corresponding intrinsic methods to the current result
and the next argument, in left-to-right order.

<PRE>
Math.public::max =
    function max(...xs) {
        if (xs.length == 0)
            return -Infinity;
        let result = <em>toPrimitiveNumber</em>(xs[0]);
        for ( let i=1 ; i &#60; xs.length; ++i ) {
            result = Math.max(result, <em>toPrimitiveNumber</em>(xs[i]));
            if (isNaN(result))
                break;
        }
        return result;
    };
</PRE>
<PRE>
Math.public::min =
    function min(...xs) {
        if (xs.length == 0)
            return Infinity;
        let result = <em>toPrimitiveNumber</em>(xs[0]);
        for ( let i=1 ; i &#60; xs.length; ++i ) {
            result = Math.min(result, <em>toPrimitiveNumber</em>(xs[i]));
            if (isNaN(result))
                break;
        }
        return result;
    };
</PRE>




</body>
</html>
