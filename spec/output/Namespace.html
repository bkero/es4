<html>
<head>
<title>The class "Namespace"</title>
<style>
/* -*- indent-tabs-mode: nil -*- */
.fixme { font-size: smaller; padding-left: 1em; color: red }
.note { font-size: smaller; padding-left: 1em }
.part { font-size: 24pt }
.grammar { font-style: italic }
.indented { padding-left: 3em }
.nonterm { padding-top: 1em }
.xref { border: thin solid red; }
.section { margin-bottom: -1em; font-family: sans-serif; font-size: smaller }
.implsection { margin-bottom: -1em; padding-bottom: 0.3em; font-family: sans-serif; font-size: smaller }
.literal { font-style: normal; font-weight: bold }
H1,H2,H3,H4,H5,H6 { font-family: sans-serif }
H1 { font-size: 14pt }
H2 { font-size: 12pt }
H3 { font-size: 11pt }
H4 { font-size: 10pt }

P code { font-size: 10pt }
code { font-style: normal; font-weight: normal }

pre { font-size: 10pt }

body { counter-reset: chapter section subsection subsubsection;
       font-size: 11pt; 
       margin: 0.75in }

table { font-size: inherit }

.pcounter:before {
    content: counter(para); 
}

.pcounter {
    position: absolute; left: 0.5in;
    counter-increment: para
}

H1:before {
    padding-right: 1em;
    content: counter(chapter) "  ";
    counter-increment: chapter }

H1 {
    counter-reset: section para;
}

H2:before {
    padding-right: 1em;
    content: counter(chapter) "." counter(section) "  ";
    counter-increment: section }

H2 {
    counter-reset: subsection para;
}

H3:before {
    padding-right: 1em;
    content: counter(chapter) "." counter(section) "." counter(subsection) "  ";
    counter-increment: subsection }

H3 {
    counter-reset: subsubsection para;
}

H4:before {
    padding-right: 1em;
    content: counter(chapter) "." counter(section) "." counter(subsection) "." counter(subsubsection) "  ";
    counter-increment: subsubsection }

H4 {
    counter-reset: para;
}

</style>
</head>

<body>
<H1 id="class Namespace"> The class <code>Namespace</code> </H1>

<HR>
<pre>
FILE:                       spec/library/Namespace.html
DRAFT STATUS:               DRAFT 2 - 2008-03-14
SOURCES:                    REFERENCES [1], [2]
REVIEWED AGAINST ES3:       N/A
REVIEWED AGAINST ERRATA:    N/A
REVIEWED AGAINST BASE DOC:  YES
REVIEWED AGAINST PROPOSALS: N/A
REVIEWED AGAINST CODE:      YES
IMPLEMENTATION STATUS:      ES4 RI


CHANGES SINCE DRAFT 1 (2008-03-05)

  * Presentation: added an explicit "extends Object" clause

  * Namespaces are explicitly designated non-nullable with a
    system-provided default value.

  * The behavior of the 'toString' method has been tightly
    specified to allow Namespace objects to be compared
    predictably.


OPEN ISSUES

  * Namespaces are defined here as non-nullable with a default value
    that is the "compatibility namespace" noNS.  This has not been
    discussed extensively in the WG.

  * Namespace objects in ES4 are more opaque than the Namespace
    objects in the base document and in E4X, both of which expose
    "prefix" and "name" properties.  ES4 is not supporting E4X, and
    the base document was probably influenced by E4X, so this
    may not be a big deal, but it should be discussed.


REFERENCES

[1] Section 4.2.10.4 of the base document: http:&#x2f;&#x2f;wiki.ecmascript.org/lib/exe/fetch.php?id=resources%3Aresources&cache=cache&media=resources:as3lang.doc
[2] builtins/Namespace.es in the ES4 RI
[3] Language definition, section on Names (forthcoming).
</pre>
<HR>

<P><span class="pcounter"></span> The class <code>Namespace</code> is a final, non-dynamic, non-nullable,
direct subclass of <code>Object</code>.  It reflects a namespace as an opaque
datum.

<P><span class="pcounter"></span> The default value for properties of type <code>Namespace</code> is the
object representing the compatibility namespace, <code>noNS</code> (see 
<span class="xref">Language:Names</span>).

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  Namespaces are created as a result of the evaluation of the
<code>namespace</code> pragma, which defines a new namespace and creates a
binding for it.  Namespaces are reflected as <code>Namespace</code> objects
when namespace bindings are referenced in expressions.

<p class="note"><b>NOTE</b>&nbsp;&nbsp; A <code>Namespace</code> object can be created with an explicit name by
providing the name as a string in the <code>namespace</code> pragma.

<p class="note"><b>COMPATIBILITY NOTE</b>&nbsp;&nbsp;  The <code>Namespace</code> class is new in the 4th Edition of this
Standard.

<h2>Synopsis</h2>

<P><span class="pcounter"></span> The class <code>Namespace</code> provides the following interface:

<PRE>
__ES4__ final class Namespace extends Object
{
    intrinsic function toString(): string &#x0085;
}
</PRE>

<P><span class="pcounter"></span> The <code>Namespace</code> prototype object provides the following direct
properties:

<PRE>
    toString: function () &#x0085;
</PRE>

<h2>Operators</h2>

<P><span class="pcounter"></span> The operators <code>==</code> and <code>===</code> compare as equal two non-opaque
<code>Namespace</code> objects that are separately created from the same string;
similarly, the operators <code>!=</code> and <code>!==</code> compare as not equal two
<code>Namespace</code> objects that are separately created from dissimilar strings.


<h2>Methods on the <code>Namespace</code> class object</h2>

<P><span class="pcounter"></span> There are no methods on the <code>Namespace</code> class object.  In
particular, the class <code>Namespace</code> does not have a publicly
accessible constructor.


<h2>Methods on <code>Namespace</code> instances</h2>

<h3>intrinsic::toString()</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toString</code> method converts the <code>Namespace</code>
object to a string.  If the <code>Namespace</code> object was created with an
explicit name then the string contains that name as a substring.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>toString</code> method returns an implementation-defined
string.  

<P><span class="pcounter"></span> Suppose the intrinsic <code>toString</code> method is invoked on two
namespaces <i>N1</i> and <i>N2</i> yielding strings <i>T1</i> and <i>T2</i>,
respectively.  <i>T1</i> and <i>T2</i> are equal if and only if <i>N1</i> is
equal to <i>N2</i> (by <code>===</code> or <code>==</code>).

<P><span class="pcounter"></span> Suppose the intrinsic <code>toString</code> method is invoked on two
different non-opaque namespaces <i>N1</i> and <i>N2</i> created from strings
<i>S1</i> and <i>S2</i>, yielding strings <i>T1</i> and <i>T2</i>, respectively.
<i>T1</i> and <i>T2</i> have the same relationship (determined by the
relational operators) as <i>S1</i> and <i>S2</i>.

<h2>Methods on the <code>Namespace</code> prototype object</h2>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The methods on the <code>Namespace</code> prototype object delegate to
their corresponding intrinsic methods.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The methods on the <code>Namespace</code> prototype object return what
their corresponding intrinsic methods return.

<P class="implsection"><b>Implementation</b>
<PRE>
prototype function toString(this:Namespace)
    this.intrinsic::toString()
</PRE>


</body>
</html>
