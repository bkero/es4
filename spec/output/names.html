<html>
<head>
<title>Names</title>
<style>
/* -*- indent-tabs-mode: nil -*- */
.fixme { font-size: smaller; padding-left: 1em; color: red }
.note { font-size: smaller; padding-left: 1em }
.part { font-size: 24pt }
.grammar { font-style: italic }
.indented { padding-left: 3em }
.nonterm { padding-top: 1em }
.xref { border: thin solid red; }
.section { margin-bottom: -1em; font-family: sans-serif; font-size: smaller }
.implsection { margin-bottom: -1em; padding-bottom: 0.3em; font-family: sans-serif; font-size: smaller }
.literal { font-style: normal; font-weight: bold }
H1,H2,H3,H4,H5,H6 { font-family: sans-serif }
H1 { font-size: 14pt }
H2 { font-size: 12pt }
H3 { font-size: 11pt }
H4 { font-size: 10pt }

P code { font-size: 10pt }
code { font-style: normal; font-weight: normal }

pre { font-size: 9pt }

body { counter-reset: chapter section subsection subsubsection subsubsubsection;
       font-size: 10pt; 
       margin: 0.75in }

table { font-size: inherit;
        width: 70%;
        margin: 2em; 
        border: 1px solid lightgrey; }

th { background: lightgrey; }

td { padding: 1em; }

.pcounter:before {
    content: counter(para); 
}

.pcounter {
    position: absolute; left: 0.5in;
    counter-increment: para
}

H1:before {
    padding-right: 1em;
    content: counter(chapter) "  ";
    counter-increment: chapter }

H1 {
    counter-reset: section para;
}

H2:before {
    padding-right: 1em;
    content: counter(chapter) "." counter(section) "  ";
    counter-increment: section }

H2 {
    counter-reset: subsection para;
}

H3:before {
    padding-right: 1em;
    content: counter(chapter) "." counter(section) "." counter(subsection) "  ";
    counter-increment: subsection }

H3 {
    counter-reset: subsubsection para;
}

H4:before {
    padding-right: 1em;
    content: counter(chapter) "." counter(section) "." counter(subsection) "." counter(subsubsection) "  ";
    counter-increment: subsubsection }

H4 {
    counter-reset: para;
}

H5:before {
    padding-right: 1em;
    content: counter(chapter) "." counter(section) "." counter(subsection) "." counter(subsubsection) "." counter(subsubsubsection) "  ";
    counter-increment: subsubsubsection }

H5 {
    counter-reset: para;
}

</style>
</head>

<body>
<h1>Names</h1>



<P><span class="pcounter"></span> Names in ECMAScript are constants that are comprised of a namespace
value and an identifier.

<P><span class="pcounter"></span> Names denote types, namespaces, and locations (properties bound in
objects and scopes).  The denotation of a name depends on the context
of the name's use: When a name is used in a type annotation context it
denotes a type; when it is used in a qualifier context it denotes a
namespace; and in all other contexts it denotes a location.

<P><span class="pcounter"></span> <i>Unqualified names</i> are expressed as simple identifiers, for
example <code>encodeURI</code>.  <i>Qualified names</i> are expressed as pairs of
namespace expressions and simple identifiers, for example
<code>intrinsic::substring</code> or <code>"org.w3.dom"::DOMNode</code>.

<P><span class="pcounter"></span> Unqualified names are subject to <i>name resolution</i>: every
unqualified name must resolve to a unique qualified name.  Names that
denote types and namespaces are resolved at definition time, while
names that denote locations are resolved (repeatedly) at evaluation
time.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  In a qualified name such as <code>intrinsic::substring</code> the
leftmost identifier, <code>intrinsic</code>, is itself unqualified and subject
to definition-time resolution.

<P><span class="pcounter"></span> Name resolution makes use of the <i>open namespaces</i> that
implicitly qualify any unqualified name.  In every compilation unit
the open namespaces starts out being comprised of the <b>public</b> and
<b>internal</b> namespaces.  The program can open additional namespaces
by means of the <code>use&nbsp;namespace</code> pragma.

<P><span class="pcounter"></span> Name resolution is performed differently depending on whether the
name is a <i>lexical reference</i> (for example, the variable reference
<code>encodeURI</code>) or a <i>property reference</i> on an object (for example,
the reference <code>s.substring</code>).

<P><span class="pcounter"></span> In the case of a lexical reference a name is resolved as a
reference to a name <i>bound</i> in the <i>scope</i> of the reference; each
entry in the chain formed by active scope objects binds names to which
the reference may resolve, with resolutions in scopes closer to the
point of reference (in "inner scopes") preferred over those in scopes
further away (in "outer scopes").

<P><span class="pcounter"></span> In the case of a property reference a name is resolved as a
reference to a property on a specific object; each entry in the chain
formed by the object and its prototype objects in order provides named
properties to which the reference may resolve, with resolutions in
objects closer to the original object preferred over those further out
in the prototype chain.

<P><span class="pcounter"></span> A reference may be found to be ambiguous.  The resolution
algorithm incorporates several forms of disambiguation, described
later, but some references are inherently ambiguous.  Such references
cause errors to be signalled at definition or evaluation time.

<P><span class="pcounter"></span> Names that denote types, namespaces, and locations are resolved by
the same algorithm.  Suppose an unqualified name that denotes a type
or namespace is resolved to a particular type or namespace definition
in a particular scope.  Then the same unqualified name denoting a
location will be resolved unambiguously to an immutable location that
holds a value that represents the type or namespace, if resolution
takes place in the same scope as for the first name.  A <i>reservation
mechanism</i> ensures that names that are resolved at definition time
cannot become ambiguous at evaluation time by the introduction of new
bindings.


<h2>Name Values</h2>

<P><span class="pcounter"></span>A name is a constant value comprised of a namespace value and an
identifier.

<P class="implsection"><b>Semantics</b> <P><span class="pcounter"></span>
<PRE>
<b>type</b> NAME = { ns: NAMESPACE, id: IDENTIFIER }
</PRE>

<P><span class="pcounter"></span>An identifier is a character string.

<P class="implsection"><b>Semantics</b> <P><span class="pcounter"></span>
<PRE>
<b>type</b> IDENTIFIER = Ustring.STRING
</PRE>

<P><span class="pcounter"></span>A namespace value is an immutable object.  A namespace is
<i>transparent</i> or <i>opaque</i>.  A transparent namespace contains a
character string that identifies the namespace; two transparent
namespaces are equal if and only if their contained strings are equal.
An opaque namespace contains an unforgeable system-generated value
that identifies the namespace; two opaque namespaces are equal if and
only if their contained identifier values are the same object.

<P class="implsection"><b>Semantics</b> <P><span class="pcounter"></span>
<PRE>
<b>datatype</b> NAMESPACE =
         TransparentNamespace <b>of</b> Ustring.STRING
       <b>|</b> OpaqueNamespace <b>of</b> OPAQUE_NAMESPACE_IDENTIFIER
</PRE>
<PRE>
<b>type</b> OPAQUE_NAMESPACE_IDENTIFIER = &#x0085;
</PRE>
<PRE>
<b>fun</b> compareNamespaces (n1: NAMESPACE, n2: NAMESPACE) : bool =
    <b>case</b> (n1, n2) <b>of</b>
        (Ast.TransparentNamespace s1, Ast.TransparentNamespace s2) <b>=></b> s1 = s2
      <b>|</b> (Ast.OpaqueNamespace i1, Ast.OpaqueNamespace i2) <b>=></b> i1 = i2
      <b>|</b> _ <b>=></b> false
</PRE>



<h2>The namespace <u>public</u></h2>

<P><span class="pcounter"></span> The namespace known as <b>public</b> is the transparent namespace
whose identifying string is the empty string.

<P class="implsection"><b>Semantics</b> <P><span class="pcounter"></span>
<PRE>
<b>val</b> publicNS = Ast.TransparentNamespace Ustring.empty
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The <b>public</b> namespace is distinguished in several ways.  The
names of properties added dynamically to objects are qualified by
<b>public</b> by default, so all properties created by 3rd Edition code
running on a 4th Edition implementation are <b>public</b>, and <b>public</b>
is sometimes called "the compatibility namespace" for that reason.
The default namespace qualifier that is applied to declarations in
every scope is <b>public</b>, so absent other qualification every
property on every object and every lexically bound name is in the
<b>public</b> namespace.


<h2>Prototype chain</h2>

<P><span class="pcounter"></span>Every object has a distinguished value called its <i>prototype</i>
(see section Object prototype in Values).

<P><span class="pcounter"></span>If the prototype value of an object is another object, then the
prototype value is called an object's <i>prototype object</i>, and 
the connection between the initial object and its prototype object
is called a <i>prototype link</i>.

<P><span class="pcounter"></span>The <i>prototype chain</i> is the list of objects formed by following
prototype links from an object. The prototype chain of an object
begins with the object itself, and ends with the first object having a
null or undefined prototype value.

<P><span class="pcounter"></span>When a name is to be resolved against an object, if resolution
initially fails because the object does not contain a property
matching the name, then resolution continues along the object's
prototype chain.

<h2>Scopes and visibility</h2>

<P><span class="pcounter"></span> Defining and binding forms introduce names into a program.  These
names can be referenced by name expressions that occur within the
<i>scope</i> of the binding.  The scope of a binding is primarily
determined textually (ECMAScript is primarily <i>lexically scoped</i>)
and depends also on the defining or binding form that introduced the
binding.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  For example, the scope of a <code>var</code> binding inside a block
statement is the entire body of the function or program containing the
block, whereas the scope of a <code>let</code> binding inside a block statement
is that block statement.

<P><span class="pcounter"></span> Scopes nest textually, and a name that is bound in one scope may
be <i>shadowed</i> in an inner scope by a binding of the same name in the
inner scope; name expressions in the inner scope will not be able to
access the outer binding.

<P><span class="pcounter"></span> In this Specification, the nesting of scopes is modelled as a
list of ribs in the definition phase and a list of objects during evaluation.
Both environments are generically called the <i>scope chain</i>. Which kind
of list is being referred to will be clear from the context in which the 
term is used.

<P><span class="pcounter"></span> Each scope holds a table of named bindings in that scope. Ribs hold
a table of fixture bindings and objects hold a table of property bindings.
Every time a new scope is entered the scope chain is extended with a new 
rib or object, and at every point in the program one particular scope chain
is in effect.

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  What's a fixture? Is it defined somewhere?

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  Exhibit the definition-time and evaluation-time structures
for scope chains here.

<P><span class="pcounter"></span> Some objects that appear on evaluation-time scope chains are
dynamically extensible, in effect providing a form of dynamic scope.
For example, class objects appear on the scope chain of class and
instance methods, and properties can be added to and removed from
class objects; these properties then become visible and invisible to
the methods.

<P><span class="pcounter"></span> In order for ECMAScript to have a lexically scoped flavor,
bindings that are textually visible (<i>lexical bindings</i>) are usually
preferred over dynamically added bindings (<i>dynamic bindings</i>)
during name resolution.  See the section "Name Resolution" below.

<h2>Name Expressions</h2>

<P><span class="pcounter"></span> There are two kinds of name expressions, the unqualified name
(such as <code>encodeURI</code>) and the namespace-qualified name (such as
<code>intrinsic::subtring</code> or <code>"org.w3.dom"::DOMNode</code>).  Name
resolution transforms name expressions into name values.

<P class="implsection"><b>Semantics</b> <P><span class="pcounter"></span>
<PRE>
<b>and</b> NAME_EXPRESSION =
    QualifiedName <b>of</b> { namespace: NAMESPACE_EXPRESSION,
                       identifier: IDENTIFIER }
  <b>|</b> UnqualifiedName <b>of</b> { identifier: IDENTIFIER,
                         openNamespaces: OPEN_NAMESPACES }
</PRE>

<P><span class="pcounter"></span> A qualified name expression is comprised of a namespace expression
and an identifier.  The former is either a literal namespace value
(resulting from using a string as a namespace qualifier) or a name
expression denoting a namespace binding.

<P class="implsection"><b>Semantics</b> <P><span class="pcounter"></span>
<PRE>
<b>and</b> NAMESPACE_EXPRESSION =
    Namespace <b>of</b> NAMESPACE
  <b>|</b> NamespaceName <b>of</b> NAME_EXPRESSION
</PRE>

<P><span class="pcounter"></span> An unqualified name expression is comprised of the namespaces that
are open at the point where the name expression occurs in the source
text and and identifier.  The open namespaces will be used to resolve
the name: an unqualified name matches any binding or property that has
the same identifier and a namespace value from among the open
namespaces.

<P><span class="pcounter"></span> The open namespaces are represented as a list of sets of namespace
values.  Each set contains namespace values that are given the same
priority during name resolution.  The list holds sets in priority
order.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  A new set is added to the list every time a new lexical scope
is entered, and the innermost (highest priority) set is extended by
the <code>use&nbsp;namespace</code> pragma.  An unqualified name expression
retains a reference to the open namespaces data structure as it appears
at the point where the expression occurs.

<P class="note"> The two lowest priority sets are singleton sets
holding the <b>public</b> and <b>internal</b> namespaces, respectively.  The
namespace <b>internal</b> is specific to each compilation unit.

<P class="implsection"><b>Semantics</b> <P><span class="pcounter"></span>
<PRE>
<b>type</b> NAMESPACE_SET = NAMESPACE list
</PRE>
<PRE>
<b>type</b> OPEN_NAMESPACES = NAMESPACE_SET list
</PRE>



<P><span class="pcounter"></span> The first element on an <code>OPEN_NAMESPACES</code> list is the highest
priority element.


<h2>Reference Expressions</h2>

<P><span class="pcounter"></span> Name expressions are incorporated into <i>reference expressions</i>
that provide context to the name expressions.  Name expressions that
reference names bound in a scope, such as <code>encodeURI</code> and
<code>intrinsic::substring</code>, are contained in <code>LexicalReference</code> nodes.

<P><span class="pcounter"></span> Name expressions that reference properties on objects, such as
<code>s.intrinsic::substring</code>, are contained in <code>ObjectNameReference</code>
nodes, which contain both the object expression (<code>s</code>, in the
example) and the name (<code>intrinsic::substring</code>).

<P><span class="pcounter"></span> Finally, the node <code>ObjectIndexReference</code> represents names that
are computed at evaluatin time, such as <code>s[e]</code>.

<P class="implsection"><b>Semantics</b> <P><span class="pcounter"></span>
<PRE>
datatype EXPRESSION =
         LexicalReference of { name: NAME_EXPRESSION }
       | ObjectNameReference of { object: EXPRESSION,
                                  name: NAME_EXPRESSION }
       | ObjectIndexReference of { object: EXPRESSION,
                                   index: EXPRESSION }
       &#x0085;
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  An <code>ObjectIndexReference</code> is evaluated by evaluating its
<code>index</code> operand to a <code>Name</code> object and then treating that value
the same as a resolved qualified name.  Index operands that do not
evaluate to <code>Name</code> objects are converted to <code>string</code>, and a
<code>Name</code> object is formed from the string and the <b>public</b>
namespace.


<h2>Name Resolution</h2>

<h3>Overview</h3>

<P><span class="pcounter"></span> The purpose of name resolution is to take an unresolved name and a
list of objects and return an unambiguous name (consisting of a
namespace value and an identifier) and an object that contains a
property with that name.  The objects are searched in order, and the
first object to contain a property with the name is selected.

<P><span class="pcounter"></span> There are three complications.  First, the search is performed
differently for object chains (an object and its prototypes) and scope
chains.  An object chain is searched in a single pass and each
object's fixed and dynamic properties are considered when the object
is searched.  A scope chain, on the other hand, is searched in two
passes, with the first pass considering mainly fixed properties and
the second pass considering also dynamic properties.  (The search ends
as soon as an object matching the name is found, so the second pass
may never be run.)  Thus fixed properties in outer scopes shadow
dynamic properties in inner scopes.  However, for reasons of
compatibility with ES3, the first pass searches both dynamic and fixed
properties in scopes that are introduced by the <code>with</code> statement or
in scopes that have been extended by the <code>eval</code> operator evaluating
a <code>function</code> or <code>var</code> directive.

<P><span class="pcounter"></span>(The motivation for the preference for fixed bindings in scopes is
to retain the lexically scoped flavor of ECMAScript.  Some of the
objects on the scope chain--class objects and instance objects--are
dynamically extensible, and allowing dynamic properties to shadow
static properties would make programs harder to understand, and it
would make them slower, as it would be hard to perform early binding.)

<P><span class="pcounter"></span> The second complication appears with the need for disambiguation.
When an unqualified name is resolved the resolution is performed in
the context of the namespaces that were open at the point of
reference.  Thus the search of any one object may find multiple
bindings that match the name, up to one binding per open namespace.
Instead of making this an error, the name resolver disambiguates by
trying to select the most desirable of those namespaces.  Selection is
performed by filtering the applicable namespaces until we are left
with one.  (If we have more than one then the name is deemed
ambiguous.)

<P><span class="pcounter"></span> We first select those namespaces among the matching namespaces
that are in use by the least specific class of the object that
contains the name.  For example, if <code><b>C</b></code> is a subclass of <code><b>B</b></code> and
<code><b>B</b></code> is a subclass of <code><b>A</b></code>, and our name <code><b>n</b></code> matched <code><b>ns1::n</b></code>,
<code><b>ns2::n</b></code>, and <code><b>ns3::n</b></code>, and <code><b>ns1::n</b></code> and <code><b>ns2::n</b></code> were defined
in <code><b>B</b></code> and <code><b>ns3::n</b></code> was defined in <code><b>C</b></code>, then we'd be left with just
<code><b>ns1</b></code> and <code><b>ns2</b></code>.

<P><span class="pcounter"></span> We then filter by namespace priority.  The open namespaces are
organized in a prioritized list of namespace sets.  If one of the
matching names has a namespace that is from a set with a higher
priority than all the other matching names, then that's the namespace
we want.  So if the referencing context of <code><b>n</b></code> opened <code><b>ns2</b></code> in a
scope nested inside the one that opened <code><b>ns1</b></code>, then we are left with
just <code><b>ns2</b></code> -- and a single binding, <code><b>ns2::n</b></code>.

<P><span class="pcounter"></span> (The motivation for disambiguation is simple: disambiguation
allows more programs to run.  Furthermore, since the priority or
namespaces during disambiguation is under the control of the
programmer, the programmer can rely on disambiguation to control which
names that are found.)

<P><span class="pcounter"></span> The third complication is that some names are required to be
resolved successfully at definition time -- names that denote
namespaces and types.  (We require that in order to make names and
types constant, which generally simplifies the language and makes
programs more easily comprehensible.)  The consequence of that is that
namespace and type references are illegal inside scopes introduced by
<code>with</code> or scopes that may be extended by the <code>eval</code> operator,
because those scopes make definition time resolution impossible --
their contents are unknown.  Such programs result in a syntax error
being signalled.  (It is possible to ease that restriction
in various ways but we have not done so.)

<P><span class="pcounter"></span> However, we also require that type and namespace names that are
resolved at definition time must resolve to the same bindings that
they would resolve to if they were to be resolved at evaluation time.
(We require that because it simplifies the user's model of the
language: equal names in the same scope have the same meaning,
provided they resolve at all.)  The consequence of that is that the
language must provide protection against ambiguities that can be
introduced at a later time.  If a name is resolved at definition time
to a global binding then compilation units loaded later may introduce
new global bindings that will make the resolved binding ambiguous.
For example, consider the following program.

<PRE>
namespace NS1
namespace NS2
NS1 type T
use namespace NS1, namespace NS2

   ... var x: T
</PRE>

<P><span class="pcounter"></span> The reference to <code>T</code> in the type annotation is resolved uniquely
at definition time to <code>NS1::T</code>.  Then another compilation unit is
loaded:

<PRE>
NS2 type T
</PRE>

<P><span class="pcounter"></span> Since the global environment is "flat"--code in earlier
compilation units see bindings introduced by later compilation
units--the reference to <code>T</code> from the first program is now ambiguous.

<P><span class="pcounter"></span> ES4 protects against this eventuality by <i>reserving</i> global
names that are resolved at definition time.  When <code>T</code> is resolved in
the first program and found to be in <code>NS1</code>, the name <code>NS2::T</code> is
reserved: it is made off-limits to later programs.  As a consequence,
the second program above would not be loaded, because the introduction
of <code>NS2::T</code> would be an error.

<P><span class="pcounter"></span> Names are reserved in namespaces at the same or higher priority
level as the namespace that the name was resolved to, so in the
example above neither <code>public::T</code> nor <code>internal::T</code> would become
reserved, as those namespaces are at lower priority levels than
<code>NS1</code> and <code>NS2</code>.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  Top-level "use&nbsp;namespace" pragmas are given a higher
priority level than names originating "outside" the compilation unit,
as is the case for <code>public</code> and <code>internal</code>.


<h3>Definition-Time Resolution of Namespace and Type Expressions</h3>

<P><span class="pcounter"></span> The definition time scope chain is modelled as a list of <code>RIB</code>
data structures, defined elsewhere.  A rib maps names to fixture
bindings that result from defining and binding forms (<code>var</code>,
<code>function</code>, <code>type</code>, <code>class</code>, <code>interface</code>, <code>namespace</code>, and
others).  Ribs have no dynamic properties.

<P><span class="pcounter"></span> Definition time resolution resolves name expressions that denote
namespaces and types, and performs reservation of global names if
necessary.

<P><span class="pcounter"></span> The following algorithm resolves a name expression to a specific
name and fixture in the list of ribs.

<P class="implsection"><b>Semantics</b> <P><span class="pcounter"></span>
<PRE>
<b>and</b> resolveNameExpr (ribs : Ast.RIBS)
                    (ne   : Ast.NAME_EXPRESSION)
    : (Ast.RIBS * Ast.NAME * Ast.FIXTURE) =

    <b>case</b> ne <b>of</b>
        Ast.QualifiedName { namespace, identifier }
        <b>=></b> resolveQualifiedName ribs identifier namespace

      <b>|</b> Ast.UnqualifiedName { identifier, openNamespaces, ... }
        <b>=></b> case (resolveUnqualifiedName ribs identifier openNamespaces) <b>of</b>

            NONE
            <b>=></b> error ["unresolved name ", LogErr.nameExpr ne]

          <b>|</b> SOME ([], _)
            <b>=></b> error ["unresolved name ", LogErr.nameExpr ne]

          <b>|</b> SOME ([rib], name)
            <b>=></b> ( reserveNames name openNamespaces ;
                 ([rib], name, getFixture rib (Ast.PropName name)) )

          <b>|</b> SOME (ribs, name)
            <b>=></b> (ribs, name, getFixture (hd ribs) (Ast.PropName name))
</PRE>


<h4>Qualified Name Expressions</h4>

<P><span class="pcounter"></span> A qualified name expression is resolved by resolving the namespace
part and then returning the tail of the list of ribs such that the
first rib on the tail contains a binding for the name.

<P class="implsection"><b>Semantics</b> <P><span class="pcounter"></span>
<PRE>
<b>fun</b> resolveQualifiedName (ribs          : Ast.RIBS)
                         (identifier    : IDENTIFIER)
                         (namespaceExpr : Ast.NAMESPACE_EXPRESSION)
    : (Ast.RIBS * NAME * Ast.FIXTURE) =
    <b>let</b>
        <b>val</b> ns = resolveNamespaceExpr ribs namespaceExpr
        <b>val</b> name = { ns = ns, id = identifier }
        <b>fun</b> search (r::rs) = <b>if</b> hasFixture r (Ast.PropName name) <b>then</b>
                                 (r::rs)
                             <b>else</b>
                                 search rs
          <b>|</b> search [] = []
    <b>in</b>
        <b>case</b> (search ribs) <b>of</b>
            []
            <b>=></b> error ["qualified name not present <b>in</b> ribs: ", LogErr.name name]

          <b>|</b> ribs'
            <b>=></b> (ribs', name, getFixture (hd ribs') (Ast.PropName name))
    <b>end</b>
</PRE>

<h4>Unqualified Name Expressions</h4>

<P><span class="pcounter"></span> An unqualified name expression is resolved according to the full
algorithm outlined above.  It returns the tail of the list of ribs
such that the first rib on the tail contains a binding for the name.

<P class="implsection"><b>Semantics</b> <P><span class="pcounter"></span>
<PRE>
<b>and</b> resolveUnqualifiedName (ribs           : Ast.RIBS)
                           (identifier     : IDENTIFIER)
                           (openNamespaces : OPEN_NAMESPACES)
    : (Ast.RIBS * NAME) option =
    <b>let</b>
        <b>val</b> namespaces = List.concat (openNamespaces)
        <b>val</b> matches = ribListSearch (ribs, namespaces, identifier)
    <b>in</b>
        <b>case</b> matches <b>of</b>
            NONE
            <b>=></b> NONE

          <b>|</b> SOME (ribs, [namespace])
            <b>=></b> SOME (ribs, {ns=namespace, id=identifier})

          <b>|</b> SOME (ribs, namespaces)
            <b>=></b> case selectNamespaces (identifier,
                                      namespaces,
                                      [],
                                      openNamespaces) <b>of</b>

                   [namespace]
                   <b>=></b> SOME (ribs, {ns=namespace, id=identifier})

                 <b>|</b> ns::nss
                   <b>=></b> error ["ambiguous reference: ", Ustring.toAscii identifier]
    <b>end</b>
</PRE>
<PRE>
<b>fun</b> ribListSearch ([], _, _) = NONE

  <b>|</b> ribListSearch (ribs       : Ast.RIBS,
                   namespaces : NAMESPACE_SET,
                   identifier : IDENTIFIER)
    : (Ast.RIBS * NAMESPACE_SET) option =
    <b>case</b> ribSearch (hd ribs, namespaces, identifier) <b>of</b>
        NONE
        <b>=></b> ribListSearch (tl ribs, namespaces, identifier)

      <b>|</b> SOME (_, m)
        <b>=></b> SOME (ribs, m)
</PRE>
<PRE>
<b>fun</b> ribSearch (rib        : Ast.RIB,
               namespaces : NAMESPACE_SET,
               identifier : IDENTIFIER)
    : (Ast.RIB * NAMESPACE_SET) option =
    <b>case</b> List.filter (<b>fn</b> ns <b>=></b>
                         hasFixture rib (Ast.PropName {ns=ns, id=identifier}))
                     namespaces <b>of</b>
        [] <b>=></b> NONE
      <b>|</b> m  <b>=></b> SOME (rib, m)
</PRE>

<h4>Reserving Names</h4>

<P><span class="pcounter"></span> Statically resolved names must keep their meaning at runtime and
therefore cannot be shadowed or be made ambiguous by the later
introduction of names.  Therefore we reserve the set of names that
would cause such conflicts at runtime.

<P><span class="pcounter"></span> Given a name and a list of sets of open namespaces, the following
algorithm computes a set of names consisting of the identifier and
each of the open namespaces with an equal or higher priority than the
given namespace.

<P class="implsection"><b>Semantics</b> <P><span class="pcounter"></span>
<PRE>
<b>and</b> reserveNames (name)
                 (openNamespaces)
    = &#x0085;
</PRE>


<h3>Evaluation-time Resolution of Lexical References</h3>

<P><span class="pcounter"></span> The evaluation time scope chain is modelled as a list of arbitrary
objects.  A scope object maps names to properties (both fixtures and
dynamic properties).  Apart from scope objects introduced by the
<code>with</code> statement, the evaluation time scope chain mirrors the
definition time scope chain.

<P><span class="pcounter"></span> The following algorithm resolves a name expression to an object
and the name of a property on that object.

<P class="implsection"><b>Semantics</b> <P><span class="pcounter"></span>
<PRE>
<b>and</b> resolveLexicalReference (regs            : REGS)
                            (nameExpression  : NAME_EXPRESSION)
                            (errorIfNotFound : bool)
    : (OBJ * NAME) =
    <b>let</b>
        <b>val</b> {scope, ...} = regs
    <b>in</b>
        <b>case</b> nameExpression <b>of</b>

            QualifiedName {identifier, namespace}
            <b>=></b> resolveQualifiedLexicalReference regs identifier namespace

          <b>|</b> UnqualifiedName { identifier, openNamespaces, ... }
            <b>=></b> resolveUnqualifiedLexicalReference regs identifier openNamespaces
    <b>end</b>
</PRE>

<h4>Qualified Lexical References</h4>

<P><span class="pcounter"></span> To resolve a qualified lexical reference we evaluate its namespace
expression (it must yield a namespace value) and then look up the name
comprised of the namespace value and the qualified reference's
identifier.  If a binding is not found then we return the global
object, otherwise the object that contained the binding.

<P class="implsection"><b>Semantics</b> <P><span class="pcounter"></span>
<PRE>
<b>and</b> resolveQualifiedLexicalReference (regs          : REGS)
                                     (identifier    : IDENTIFIER)
                                     (namespaceExpr : NAMESPACE_EXPRESSION)
    : (OBJ * NAME) =
    <b>let</b>
        <b>val</b> {scope, global, ...} = regs
        <b>val</b> namespace = evalNamespaceExpr regs namespaceExpr
        <b>val</b> result = searchScopeChain (regs, SOME scope, identifier, [namespace])
    <b>in</b>
        <b>case</b> result <b>of</b>
            NONE
            <b>=></b> (global, {ns=publicNS, id=identifier})

          <b>|</b> SOME (object, namespaces)
            <b>=></b> (object, {ns=namespace, id=identifier})
    <b>end</b>
</PRE>

<h4>Unqualified Lexical References</h4>

<P><span class="pcounter"></span> To resolve an unqualified lexical reference we make use of the
full algorithm outlined above, finding the first object that maches
the unqualified name in all open namespaces and then disambiguating
the set of resulting namespaces.

<P class="implsection"><b>Semantics</b> <P><span class="pcounter"></span>
<PRE>
<b>and</b> resolveUnqualifiedLexicalReference (regs           : REGS)
                                       (identifier     : IDENTIFIER)
                                       (openNamespaces : OPEN_NAMESPACES)
    : (OBJ * NAME) =
    <b>let</b>
        <b>val</b> {scope, global, ...} = regs
        <b>val</b> namespaces = List.concat openNamespaces
        <b>val</b> result = searchScopeChain (regs, SOME scope, identifier, namespaces)
    <b>in</b>
        <b>case</b> result <b>of</b>
            NONE
            <b>=></b> (global, {ns=publicNS, id=identifier})

          <b>|</b> SOME (object, namespaces)
            <b>=></b> let
                   <b>val</b> classRibs = [getRib regs object]
                   <b>val</b> result = Fixture.selectNamespaces (identifier,
                                                          namespaces,
                                                          classRibs,
                                                          openNamespaces)
               <b>in</b>
                   <b>case</b> result <b>of</b>
                       [namespace]
                       <b>=></b> (object, {ns=namespace, id=identifier})

                     <b>|</b> _
                       <b>=></b> error regs ["ambiguous reference"]
               <b>end</b>
    <b>end</b>
</PRE>

<h4>Resolve on a Scope Chain</h4>

<P><span class="pcounter"></span> To find an object matching an identifier and a set of namespaces
in a scope chain.

[CHANGE] remove second lookup pass

<P class="implsection"><b>Semantics</b> <P><span class="pcounter"></span>
<PRE>
<b>and</b> searchScopeChain (regs, NONE, _, _) = NONE

  <b>|</b> searchScopeChain (regs       : REGS,
                      SOME scope : SCOPE option,
                      identifier : IDENTIFIER,
                      namespaces : NAMESPACE_SET)
    : (OBJECT * NAMESPACE_SET) option =
    <b>let</b>
        <b>val</b> matches = searchScope (regs, scope, namespaces, identifier)
        <b>val</b> Scope { parent, ... } = scope
    <b>in</b>
        <b>case</b> matches <b>of</b>
            NONE
            <b>=></b> searchScopeChain (regs, parent, identifier, namespaces)

          <b>|</b> _
            <b>=></b> matches
    <b>end</b>
</PRE>
<PRE>
<b>fun</b> searchScope (regs       : REGS,
                 scope      : SCOPE,
                 namespaces : NAMESPACE_SET,
                 identifier : IDENTIFIER)
    : (OBJECT * NAMESPACE_SET) option =
    <b>let</b>
        <b>val</b> (object, kind) = getScopeObjectAndKind (scope)
    <b>in</b>
        <b>case</b> kind <b>of</b>
            (WithScope <b>|</b> EvalScope <b>|</b> GlobalScope)  (* FIXME EvalScope is unused *)
            <b>=></b> searchObject (regs, SOME object, NONE, identifier, namespaces, false)

          <b>|</b> (InstanceScope class)
            <b>=></b> searchObject (regs, SOME object, SOME class, identifier, namespaces, true)

          <b>|</b> _
            <b>=></b> searchObject (regs, SOME object, NONE, identifier, namespaces, true)
    <b>end</b>
</PRE>

<h3>Evaluation-Time Resolution of Object References</h3>

<P><span class="pcounter"></span> Object references are resolved along the prototype chain of the
object.  Both fixed and dynamic properties are searched in each
object, in a single pass over the prototype chain.

<P><span class="pcounter"></span> <code>ObjectIndexReference</code> expressions represent computed lookup.
The index expression is computed; if it evaluates to a <code>Name</code> object
then it is used as is, otherwise the value is converted to <code>string</code>
and qualified with the <code>public</code> namespace.

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  The following algorithm does not yet handle <code>Name</code> objects.

<P class="implsection"><b>Semantics</b> <P><span class="pcounter"></span>
<PRE>
<b>and</b> resolveObjectReference (regs:REGS)
                           (ObjectNameReference { object, name, ... }: EXPRESSION)
    : (OBJ option * (OBJ * NAME)) =
    <b>let</b>
        <b>val</b> obj = evalObjectExpr regs object
    <b>in</b>
        <b>case</b> name <b>of</b>
            UnqualifiedName { identifier, openNamespaces, ... }
            <b>=></b> (SOME obj, resolveUnqualifiedObjectReference regs obj identifier openNamespaces)

          <b>|</b> QualifiedName { namespace, identifier }
            <b>=></b> (SOME obj, resolveQualifiedObjectReference regs obj identifier namespace)
    <b>end</b>

  <b>|</b> resolveObjectReference regs
                           (ObjectIndexReference {object, index, ...}) =
    <b>let</b>
        <b>val</b> obj = evalObjectExpr regs object
        <b>val</b> idx = evalExpr regs index
        <b>val</b> identifier = toUstring regs idx
        (* FIXME <b>if</b> its an Name, <b>then</b> don't convert *)
        <b>val</b> namespace = Namespace publicNS
    <b>in</b>
        (SOME obj, resolveQualifiedObjectReference regs obj identifier namespace)
    <b>end</b>
</PRE>

<h4>Qualified Object References</h4>

<P><span class="pcounter"></span>Here we describe how an identifier and a namespace expression is resolved to
a name of a binding on a specfic object.

<P><span class="pcounter"></span> To resolve a qualified object reference we evaluate its namespace
expression (it must yield a namespace value) and then simply return
the object value and the evaluated name.

<P class="implsection"><b>Semantics</b> <P><span class="pcounter"></span>
<PRE>
<b>and</b> resolveQualifiedObjectReference (regs: REGS)
                                    (object: OBJ)
                                    (identifier: IDENTIFIER)
                                    (namespaceExpr: NAMESPACE_EXPRESSION)
    : (OBJ * NAME) =
    <b>let</b>
        <b>val</b> namespaces = [evalNamespaceExpr regs namespaceExpr]
        <b>val</b> openNamespaces = []
    <b>in</b>
        resolveOnObject regs object identifier namespaces openNamespaces
    <b>end</b>
</PRE>

<h4>Unqualified Object References</h4>

<P><span class="pcounter"></span> To resolve an unqualified object reference we make use of the
full algorithm outlined above, finding the first object that maches
the unqualified name in all open namespaces and then disambiguating
the set of resulting namespaces.

<P class="implsection"><b>Semantics</b> <P><span class="pcounter"></span>
<PRE>
<b>and</b> resolveUnqualifiedObjectReference (regs: REGS)
                                      (object: OBJ)
                                      (identifier: IDENTIFIER)
                                      (openNamespaces: OPEN_NAMESPACES)
    : (OBJ * NAME) =
    <b>let</b>
        <b>val</b> namespaces = List.concat openNamespaces
    <b>in</b>
        resolveOnObject regs object identifier namespaces openNamespaces
    <b>end</b>
</PRE>

<h4>Resolve Name on an Object</h4>

<P class="implsection"><b>Semantics</b> <P><span class="pcounter"></span>
<PRE>
<b>and</b> resolveOnObject (regs:REGS)
                    (object:OBJ)
                    (identifier:IDENTIFIER)
                    (namespaces:NAMESPACE_SET)
                    (openNamespaces: OPEN_NAMESPACES)
    : (OBJ * NAME) =
    <b>let</b>
        <b>val</b> result = searchObject (regs, SOME object, NONE, identifier, namespaces, false)
    <b>in</b>
        <b>case</b> result <b>of</b>
            NONE <b>=></b> (object, {ns=publicNS, id=identifier})
          <b>|</b> SOME (object, namespaces) <b>=></b>
            selectNamespacesByInstanceRibs regs object identifier namespaces openNamespaces
    <b>end</b>
</PRE>

<h3>Common Name Resolution Algorithms</h3>

<P><span class="pcounter"></span> The following algorithms are common to the preceding resolver
algorithms.

<h4>Single Object Search</h4>

<P><span class="pcounter"></span> Given an object, an identifier and a set of namespaces, this
algorithm searches for a matching property name in the object and the
object's prototype chain.

<P class="implsection"><b>Semantics</b> <P><span class="pcounter"></span>
<PRE>
<b>fun</b> searchObject (_, NONE, _, _, _, _) = NONE

  <b>|</b> searchObject (regs        : REGS,
                  SOME object : OBJECT option,
                  class       : Ast.CLASS option,
                  identifier  : IDENTIFIER,
                  namespaces  : NAMESPACE_SET,
                  fixedOnly   : bool)
    : (OBJECT * NAMESPACE_SET) option =
    <b>let</b>
        <b>val</b> matches = getBindingNamespaces (regs,
                                            object,
                                            class,
                                            identifier,
                                            namespaces,
                                            fixedOnly)
    <b>in</b>
        <b>case</b> matches <b>of</b>
            []
            <b>=></b> if fixedOnly <b>then</b>
                   NONE
               <b>else</b>
                   searchObject (regs,
                                 getPrototypeObject (object),
                                 NONE,
                                 identifier,
                                 namespaces,
                                 fixedOnly)

          <b>|</b> _
            <b>=></b> SOME (object, matches)
    <b>end</b>
</PRE>

<h4>Disambiguation by Filtering</h4>

<P><span class="pcounter"></span> Given an identifier, a list of namespaces, a list of classes, a
list of open namespaces, the following algorithm coordinates the
filtering of the set of namespaces: according to the order that the
namespaces appear in bindings in the given classes first, and in the
priority given by the list of open namespaces second.

<P class="implsection"><b>Semantics</b> <P><span class="pcounter"></span>
<PRE>
<b>fun</b> selectNamespaces (identifier     : IDENTIFIER,
                      namespaces     : NAMESPACE_SET,
                      instanceRibs   : Ast.RIBS,
                      openNamespaces : OPEN_NAMESPACES)
    : NAMESPACE_SET =
    <b>let</b>
        <b>val</b> openNamespaceSet = List.concat (openNamespaces)
    <b>in</b>
        <b>case</b> namespaces <b>of</b>

            _ :: []
            <b>=></b> namespaces

          <b>|</b> _ <b>=></b>
            <b>let</b>
                <b>val</b> matches' =
                    selectNamespacesByClass (instanceRibs,
                                             openNamespaceSet,
                                             identifier)
            <b>in</b>
                <b>case</b> matches' <b>of</b>
                    []
                    <b>=></b> raise (LogErr.NameError "internal error")

                  <b>|</b> [_]
                    <b>=></b> matches'

                  <b>|</b> _ <b>=></b>
                    <b>let</b>
                        <b>val</b> matches'' =
                            selectNamespacesByOpenNamespaces (openNamespaces,
                                                              namespaces)
                    <b>in</b>
                        <b>case</b> matches'' <b>of</b>

                            []
                            <b>=></b> raise (LogErr.NameError "internal error")

                          <b>|</b> _
                            <b>=></b> matches''
                    <b>end</b>
            <b>end</b>
    <b>end</b>
</PRE>

<h5>Class Base Namespace Filtering</h5>

<P><span class="pcounter"></span> Given a list of classes, an identifier and a set of namespaces,
the following algorithm selects the namespaces used on the most
generic class of that list. This step is necessary to avoid object
integrity issues that arise when a derived class introduces a binding
with the same identifier and a different namespace in the open
namespaces.

<P><span class="pcounter"></span> <b>Informal description</b>: Search a class for any instance fixture
name bindings that are named by the provided identifier and any of the
namespaces in the provided set. Collect the set of matching namespaces
used in all such bindings. If the set of matching namespaces is
nonempty, return it. Otherwise repeat the process on the next instance
rib.  If all the classes in the list are searched and no matching
namespaces are found, return the empty set.

<P class="implsection"><b>Semantics</b> <P><span class="pcounter"></span>
<PRE>
<b>fun</b> selectNamespacesByClass ([], namespaces, _) = namespaces

 <b>|</b>  selectNamespacesByClass (instanceRibs : Ast.RIBS,
                             namespaces   : NAMESPACE_SET,
                             identifier   : IDENTIFIER)
    : NAMESPACE list =
    <b>let</b>
        <b>val</b> rib = hd instanceRibs
        <b>val</b> bindingNamespaces =
            getInstanceBindingNamespaces (rib, identifier, namespaces)
        <b>val</b> matches =
            intersectNamespaces (bindingNamespaces, namespaces)
    <b>in</b>
        <b>case</b> matches <b>of</b>

            []
            <b>=></b> selectNamespacesByClass (tl instanceRibs,
                                        namespaces,
                                        identifier)

          <b>|</b> _
            <b>=></b> matches
    <b>end</b>
</PRE>

<h5>Open Namespace Based Namespace Filtering</h5>

<P><span class="pcounter"></span> Given a list of sets of open namespaces (ordered from most
recently opened to least recently opened) and a set of matching
namespaces, this algorithm returns a subset of the matching set that
occurs entirely within a single open namespace set.

<P><span class="pcounter"></span> <b>Informal description</b>: intersect the head of the provided open
namespace list with the provided set of namespaces. If that
intersection is nonempty, return it. Otherwise repeat the process with
the tail of the open namespace list. If the end of the list of open
namespace sets is reached without producing a nonempty intersection,
return an empty set.

<P class="implsection"><b>Semantics</b> <P><span class="pcounter"></span>
<PRE>
<b>fun</b> selectNamespacesByOpenNamespaces ([], _) = []

 <b>|</b>  selectNamespacesByOpenNamespaces (namespacesList : NAMESPACE_SET list,
                                      namespaces     : NAMESPACE_SET)
    : NAMESPACE list =
    <b>let</b>
        <b>val</b> matches = intersectNamespaces (hd namespacesList, namespaces)
    <b>in</b>
        <b>case</b> matches <b>of</b>

            []
            <b>=></b> selectNamespacesByOpenNamespaces (tl namespacesList, namespaces)

          <b>|</b> _
            <b>=></b> matches
    <b>end</b>
</PRE>



</body>
</html>
