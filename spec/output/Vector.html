<html>
<head>
<title>The class "Vector"</title>
<style>
/* -*- indent-tabs-mode: nil -*- */
.fixme { font-size: smaller; padding-left: 1em; color: red }
.note { font-size: smaller; padding-left: 1em }
.part { font-size: 24pt }
.grammar { font-style: italic }
.indented { padding-left: 3em }
.nonterm { padding-top: 1em }
.xref { border: thin solid red; }
.section { margin-bottom: -1em; font-family: sans-serif; font-size: smaller }
.implsection { margin-bottom: -1em; padding-bottom: 0.3em; font-family: sans-serif; font-size: smaller }
.literal { font-style: normal; font-weight: bold }
H1,H2,H3,H4,H5,H6 { font-family: sans-serif }
H1 { font-size: 14pt }
H2 { font-size: 12pt }
H3 { font-size: 11pt }
H4 { font-size: 10pt }

P code { font-size: 10pt }
code { font-style: normal; font-weight: normal }

pre { font-size: 10pt }

body { counter-reset: chapter section subsection subsubsection;
       font-size: 11pt; 
       margin: 0.75in }

table { font-size: inherit }

.pcounter:before {
    content: counter(para); 
}

.pcounter {
    position: absolute; left: 0.5in;
    counter-increment: para
}

H1:before {
    padding-right: 1em;
    content: counter(chapter) "  ";
    counter-increment: chapter }

H1 {
    counter-reset: section para;
}

H2:before {
    padding-right: 1em;
    content: counter(chapter) "." counter(section) "  ";
    counter-increment: section }

H2 {
    counter-reset: subsection para;
}

H3:before {
    padding-right: 1em;
    content: counter(chapter) "." counter(section) "." counter(subsection) "  ";
    counter-increment: subsection }

H3 {
    counter-reset: subsubsection para;
}

H4:before {
    padding-right: 1em;
    content: counter(chapter) "." counter(section) "." counter(subsection) "." counter(subsubsection) "  ";
    counter-increment: subsubsection }

H4 {
    counter-reset: para;
}

</style>
</head>

<body>
<H1 id="class Vector"> The class <code>Vector</code> </H1>

<hr>
<pre>
FILE:                       spec/library/Vector.html
DRAFT STATUS:               DRAFT 1 - ROUGH - 2008-03-03
IMPLEMENTATION STATUS:      ES4 RI
REVIEWED AGAINST ES3:       N/A
REVIEWED AGAINST ERRATA:    N/A
REVIEWED AGAINST BASE DOC:  N/A
REVIEWED AGAINST PROPOSALS: NO
REVIEWED AGAINST CODE:      NO

CHANGES SINCE DRAFT 1 (2008-03-03)

  * Presentation: added an explicit "extends Object" clause.


KNOWN DISCREPANCIES AGAINST PROPOSALS

  * Proposals call for a method 'setSlice' supposedly specified in
    JS1.8.  But the JS1.8 docs do not define it.


OPEN ISSUES

  * Should 'filter', 'map', and 'slice' return a vector whose 'fixed'
    property is true if the 'fixed' property of the vector they were
    generated from is true?


NOTES

  * The proposal uses the phrase "default value appropriate to the
    base type T" in a few places.  This is the value 0 for numeric
    types; the empty string for string types; false for boolean types;
    undefined for the undefined type; and null for all other types.
    A function that takes a type object and computes the correct
    default value is expressible in ES4 and may be incorporated
    into the library spec later.

  * No namespaces are explicitly opened in the scope surrounding the
    definition of Vector.  If the normative fragments do not show an
    explicit qualification on a name then the name referenced is the
    public one.

  * As a general rule, when invoking methods on objects passed as
    arguments, the Vector methods (like other methods in the library)
    invoke public methods on the received objects.  For example, the
    'toLocaleString' method is careful to call the public
    'toLocaleString' method on its arguments, and 'every', 'filter',
    'forEach', 'map', and so on call the public 'call' methods on
    their function arguments.

</pre>
<hr>


<P><span class="pcounter"></span> The class <code>Vector</code> is a parameterized, dynamic, direct subclass
of <code>Object</code>.  It represents dense, typed, 0-based, one-dimensional
arrays with bounds checking and optionally fixed length.

<P><span class="pcounter"></span> The class <code>Vector</code> provides two benefits.  One is optimization:
the restrictions placed on the class---denseness and a predefined
iteration order---make it possible for ECMAScript implementations to
implement it particularly efficiently.  The other is error checking:
<code>Vector</code> provides stronger type checking and bounds checking than
<code>Array</code>.

<p class="note"><b>COMPATIBILITY NOTE</b>&nbsp;&nbsp;  The class <code>Vector</code> is new in the 4th Edition of this
Standard.

<P><span class="pcounter"></span> The class <code>Vector</code> provides a method suite that is largely
compatible with the class <code>Array</code>.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  It is likely that many current uses of <code>Array</code> can be
switched over to <code>Vector</code> without much work, and programs that can
be switched will receive the benefits of stronger type and bounds
checking.

<P><span class="pcounter"></span> The type parameter of the <code>Vector</code> is called its <i>base type</i>.

<P><span class="pcounter"></span> As the <code>Vector</code> class is dynamic, new properties can be added to
its instances but any property whose name is a number (an instance of
any class in the union type <code>AnyNumber</code>) is handled specially.
These properties are called <i>indexed properties</i>.

<P><span class="pcounter"></span> Only indexed properties named by nonnegative integers less than
the value of the property <code>length</code> are defined, and only indexed
properties named by nonnegative integers less than 2<SUP>32</SUP>-1
can be defined.

<P><span class="pcounter"></span> Any attempt to read an undefined indexed property results in a
<b>RangeError</b> exception being thrown.

<P><span class="pcounter"></span> Any attempt to write an undefined indexed property results in a
<b>RangeError</b> being thrown unless the index is equal to the current
value of <code>length</code>, the current value of <code>length</code> is not
2<SUP>32</SUP>-1, and the value of the property <code>fixed</code> is not
<b>true</b>.

<P><span class="pcounter"></span> The property <code>fixed</code> is a flag that determines whether the
vector has fixed length or not.  Any attempt to update the value of
<code>length</code> fails if the <code>fixed</code> property has the value <b>true</b>.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  If <code>v</code> is a <code>Vector</code> then reading and writing <code>v[3.14]</code>
or <code>v[-3]</code> will always fail, though reading and writing
<code>v["3.14"]</code> or <code>v["-3"]</code> will succeed.  

<P class="note"> This behavior deviates from the 3rd Edition, where
strings and numbers are interchangeable as property names.  But that's
no longer quite true in 4th Edition anyway, which has have namespaces
and <code>Name</code> objects.

<P class="note">Most attempts to set or get properties that are named
by numbers that are not valid array indices are probably errors,
especially if the object is an Array.  Most attempts to read beyond
the end of an Array are probably errors.  And in a number of cases,
attempts to write beyond the end of an Array are probably errors too.
The <code>Vector</code> class makes it possible to discover these errors.

<P><span class="pcounter"></span> All indexed properties named by nonnegative integers less than
<code>length</code> are always defined.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  As a consequence, a <code>Vector</code> does not have "holes" in its
index range in the way an <code>Array</code> does.

<h2>Synopsis</h2>

<P><span class="pcounter"></span> The class <code>Vector</code> provides the following interface:

<PRE><span class="pcounter"></span>__ES4__ dynamic class Vector.&#60;T> extends Object
{
    public function Vector(length: double=0, fixed: boolean=false) &#x0085
    static meta function invoke(object) &#x0085

    static const length = 2;

    override intrinsic function toString() &#x0085
    override intrinsic function toLocaleString() &#x0085
    intrinsic function concat(...items): Vector.&#60;T> &#x0085
    intrinsic function every(checker: Checker, thisObj: Object=null): boolean &#x0085
    intrinsic function filter(checker: Checker, thisObj: Object=null): Vector.&#60;T> &#x0085
    intrinsic function forEach(eacher: Eacher, thisObj: Object=null): void &#x0085
    intrinsic function indexOf(value: T, from: AnyNumber=0): AnyNumber &#x0085
    intrinsic function join(separator: string=","): string &#x0085
    intrinsic function lastIndexOf(value: T, from: AnyNumber=Infinity): AnyNumber &#x0085
    intrinsic function map(mapper:Mapper, thisObj:Object=null) &#x0085
    intrinsic function pop(): T &#x0085
    intrinsic function push(...items): double &#x0085
    intrinsic function reduce(reducer/*: function*/, initialValue:(T|None)=NONE ): T &#x0085
    intrinsic function reduceRight(reducer/*: function*/, initialValue:(T|None)=NONE ): T &#x0085
    intrinsic function reverse(): Vector.&#60;T> &#x0085
    intrinsic function shift(): T &#x0085
    intrinsic function slice(start: AnyNumber=0, end: AnyNumber=Infinity, step: AnyNumber=1): Vector.&#60;T> &#x0085
    intrinsic function some(checker: Checker, thisObj: Object=null): boolean &#x0085
    intrinsic function sort(comparefn: function(T, T): AnyNumber): Vector.&#60;T> &#x0085
    intrinsic function splice(start: AnyNumber, deleteCount: AnyNumber, ...items): Vector.&#60;T> &#x0085
    intrinsic function unshift(...items): double &#x0085

    iterator function get(deep: boolean = false) : iterator::IteratorType.&#60;uint> &#x0085
    iterator function getKeys(deep: boolean = false) : iterator::IteratorType.&#60;uint> &#x0085
    iterator function getValues(deep: boolean = false) : iterator::IteratorType.&#60;T> &#x0085
    iterator function getItems(deep: boolean = false) : iterator::IteratorType.&#60;[uint,T]> &#x0085

    public var fixed: boolean &#x0085

    public final function get length() &#x0085
    public final function set length(len: AnyNumber) &#x0085

    meta final function get(name): T &#x0085
    meta final function set(name, v): void &#x0085
    meta final function has(name) &#x0085
    meta final function delete(name) &#x0085
}
</PRE>

<P><span class="pcounter"></span> The types <code>Checker</code>, <code>Eacher</code>, and <code>Mapper</code> are as for the <code>Array</code> class
(see <span class="xref">class Array</span>).

<P><span class="pcounter"></span> The <code>Vector</code> prototype object provides these direct properties:

<PRE><span class="pcounter"></span>    toString:       function () &#x0085;
    toLocaleString: function () &#x0085;
    concat:         function (...items) &#x0085;
    every:          function (checker, thisObj) &#x0085;
    filter:         function (checker, thisObj) &#x0085;
    forEach:        function (eacher, thisObj) &#x0085;
    indexOf:        function (value, from) &#x0085;
    join:           function (separator) &#x0085;
    lastIndexOf:    function (value, from) &#x0085;
    map:            function (mapper, thisObj) &#x0085;
    pop:            function () &#x0085;
    push:           function (...items) &#x0085;
    reduce:         function (callback, initialValue) &#x0085;
    reduceRight:    function (callback, initialValue) &#x0085;
    reverse:        function () &#x0085;
    shift:          function () &#x0085;
    slice:          function (start, end) &#x0085;
    some:           function (checker, thisObj) &#x0085;
    sort:           function (comparefn) &#x0085;
    splice:         function (start, deleteCount, ...items) &#x0085;
    unshift:        function (...items) &#x0085;
</PRE>


<h2>Methods on the <code>Vector</code> class object</h2>

<h3>new&nbsp;Vector.&lt;T&gt;&nbsp;(&nbsp;length=&#x0085;,&nbsp;fixed=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The <code>Vector</code> constructor initializes a new <code>Vector</code> object.

<P><span class="pcounter"></span> <i>Length</i> is the inital value of the <code>length</code> property.  Its
default value is zero.  Every indexed element of the new vector below
<i>length</i> is initialized to a default value that is appropriate to
the base type <code>T</code>.

<P><span class="pcounter"></span> <i>Fixed</i> is the initial value of the <code>fixed</code> property.  Its
default value is <b>false</b>.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span> The <code>Vector</code> constructor is implementation-defined.


<h3>Vector(&nbsp;object&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> When the <code>Vector</code> class object is called as a function, it
creates a new variable-length <code>Vector</code> object of type <code>*</code>, giving
it the initial length of the <code>length</code> property of <i>object</i> and
initial element values extracted from <i>object</i> between indices <code>0</code>
and <i>object</i><code>.length</code>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>Vector</code> class object called as a function returns a new
<code>Vector</code> object.

<P class="implsection"><b>Implementation</b>
<PRE><span class="pcounter"></span>static meta function invoke(object) {
    if (object is Vector.&#60;*>)
        return object;
    let length = intrinsic::toUint(object.length);
    let result = new Vector.&#60;*>(length);
    for ( let i=0 ; i &#60; length ; i++ )
        result[i] = object[i];
    return result;
}
</PRE>


<h2>Methods on <code>Vector</code> instances</h2>

<h3>intrinsic::toString&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toString</code> method converts the vector to a <code>string</code>.
It has the same effect as if the <code>join</code> method were invoked for this
object with no argument.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>toString</code> method returns a <code>string</code>.

<P class="implsection"><b>Implementation</b>
<PRE><span class="pcounter"></span>override intrinsic function toString()
    intrinsic::join();
</PRE>

<h3>intrinsic::toLocaleString&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toLocaleString</code> method converts the <code>Vector</code>
to a string in the following manner.

<P><span class="pcounter"></span>Elements of this <code>Vector</code> are converted to strings using their
public <code>toLocaleString</code> methods, and these strings are then
concatenated, separated by occurrences of a separator string that has
been derived in an implementation-defined locale-specific way.  The
result of calling this function is intended to be analogous to the
result of <code>toString</code>, except that the result of this function is
intended to be locale-specific.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>toLocaleString</code> method returns a <code>string</code>.

<P class="implsection"><b>Implementation</b>
<PRE><span class="pcounter"></span>override intrinsic function toLocaleString() {
    let limit = length;
    let separator = informative::localeSpecificSeparatorString();
    let s = "";
    let i = 0;

    while (true) {
        let x = this[i];
        if (x !== undefined && x !== null)
            s += x.toLocaleString();
        if (++i == limit)
            break;
        s += separator;
    }
    return s;
}
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The first parameter to this method is likely to be used in a
future version of this standard; it is recommended that
implementations do not use this parameter position for anything else.

<h3>intrinsic::concat&nbsp;(&nbsp;...items&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>concat</code> method collects the vector elements
from <code>this</code> followed by the vector elements from the additional
<i>items</i>, in order, into a new <code>Vector</code> object.  All the <i>items</i>
must be <code>Vector</code> instances whose base types are subtypes of the base
type of <code>this</code>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>concat</code> method returns a new <code>Vector</code> object with the
same base type as <code>this</code>.

<P class="implsection"><b>Implementation</b>
<PRE><span class="pcounter"></span>intrinsic function concat(...items): Vector.&#60;T>
    helper::concat(items);
</PRE>
<PRE><span class="pcounter"></span>helper function concat(items) {
    let v = new Vector.&#60;T>;
    let k = 0;

    for ( let i=0, limit=length ; i &#60; limit ; i++ )
        v[k++] = this[i];

    for ( let j=0 ; j &#60; items.length ; j++ ) {
        let item = items[j] cast Vector.&#60;T>;
        for ( let i=0, limit=item.length ; i &#60; limit ; i++ )
            v[k++] = item[i];
    }

    return v;
}
</PRE>

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  Need to check a detail of the type system, namely whether
<code>Vector.&lt;T&gt;</code> is a subtype of Vector.&lt;U&gt; if T is a
subtype of U and U is not <code>*</code>.

<h3>intrinsic::every&nbsp;(&nbsp;checker,&nbsp;thisObj=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>every</code> method calls <i>checker</i> on every
vector element of <code>this</code> in increasing index order, stopping as soon
as any call returns <b>false</b>.

<P><span class="pcounter"></span><i>Checker</i> is called with three arguments: the vector element
value, the vector element index, and <code>this</code>.  <i>ThisObj</i> is used as
the <code>this</code> object in the call.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>every</code> method returns <b>true</b> if all the calls to
<i>checker</i> returned true values, otherwise it returns <b>false</b>.

<P class="implsection"><b>Implementation</b>
<PRE><span class="pcounter"></span>intrinsic function every(checker: Checker, thisObj: Object=null): boolean {
    for ( let i=0, limit=length ; i &#60; limit ; i++ )
        if (!checker.call(thisObj, this[i], i, this))
            return false;
    return true;
}
</PRE>

<h3>intrinsic::filter&nbsp;(&nbsp;checker,&nbsp;thisObj=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>filter</code> method calls <i>checker</i> on every
vector element of <code>this</code> in increasing index order, collecting all
the vector elements for which checker returns a true value.

<P><span class="pcounter"></span> <i>Checker</i> is called with three arguments: the vector element
value, the vector element index, and <code>this</code>.  <i>ThisObj</i> is used as
the <code>this</code> object in the call.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>filter</code> method returns a new <code>Vector</code> object with the
same base type as <code>this</code>, containing the elements that were
collected, in the order they were collected.  The length of the new
<code>Vector</code> is equal to the number of values that were collected.

<P class="implsection"><b>Implementation</b>
<PRE><span class="pcounter"></span>intrinsic function filter(checker: Checker, thisObj: Object=null): Vector.&#60;T> {
    var result = new Vector.&#60;T>;
    for ( let i=0, limit=length ; i &#60; limit ; i++ )
        if (checker.call(thisObj, this[i], i, this))
            result[result.length] = this[i];
    return result;
}
</PRE>

<h3>intrinsic::forEach&nbsp;(&nbsp;eacher,&nbsp;thisObj=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>forEach</code> method calls <i>eacher</i> on every
vector element of <code>this</code> in increasing index order, discarding any
return value of <i>eacher</i>.

<P><span class="pcounter"></span> <i>Eacher</i> is called with three arguments: the vector element
value, the vector element index, and <code>this</code>.  <i>ThisObj</i> is used as
the <code>this</code> object in the call.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>forEach</code> method does not return a value.

<P class="implsection"><b>Implementation</b>
<PRE><span class="pcounter"></span>intrinsic function forEach(eacher: Eacher, thisObj: Object=null): void {
    for ( let i=0, limit=length ; i &#60; limit ; i++ )
        eacher.call(thisObj, this[i], i, this);
}
</PRE>

<P><span class="pcounter"></span> The helper function <code>clamp</code> performs clamping of <code>from</code> to the
length of this <code>Vector</code>.

<PRE><span class="pcounter"></span>helper function clamp(val: AnyNumber, len: double): double {
    val = helper::toInteger(val);
    if (val &#60; 0)
        val += len;
    return intrinsic::toUint( Math.min( Math.max( val, 0 ), len ) );
}
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The helper function <code>toInteger</code>, used by <code>clamp</code>, is
described elsewhere; it performs the <code>ToInteger</code> operation of the
3rd Edition.

<h3>intrinsic::indexOf&nbsp;(&nbsp;value,&nbsp;from=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>indexOf</code> method compares <i>value</i> with every
vector element of <code>this</code> in increasing index order, starting at the
index <i>from</i>, stopping when a vector element is equal to <i>value</i>
by the <code>===</code> operator.

<P><span class="pcounter"></span> If <i>from</i> is negative, it is treated as
<code>this.length+<i>from</i></code>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>indexOf</code> method returns the vector index the first
time <i>value</i> is equal to an element, or -1 if no such element is
found.

<P class="implsection"><b>Implementation</b>
<PRE><span class="pcounter"></span>intrinsic function indexOf(value: T, from: AnyNumber=0): AnyNumber {
    let start = helper::clamp( from, length );
    for ( let i=start, limit=length ; i &#60; limit ; i++ )
        if (this[i] === value)
            return i;
    return -1;
}
</PRE>

<h3>intrinsic::join&nbsp;(&nbsp;separator=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>join</code> method concatenates the string
representations of the vector elements of <code>this</code> in increasing index
order, separating the individual strings by occurrences of
<i>separator</i>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>join</code> method returns the concatenated string.

<P class="implsection"><b>Implementation</b>
<PRE><span class="pcounter"></span>intrinsic function join(separator: string=","): string {
    let limit = length;
    let s = "";
    let i = 0;

    for (let i = 0; i &#60; limit; i++) {
        let x = this[i];
        if (i != 0)
            s += separator;
        if (x !== undefined && x !== null)
            s += string(x);
    }
    return s;
}
</PRE>

<h3>intrinsic::lastIndexOf&nbsp;(&nbsp;value,&nbsp;from=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>lastIndexOf</code> method compares <i>value</i> with every
vector element of <code>this</code> in decreasing numerical index order,
starting at the index <i>from</i>, stopping when a vector element is
equal to <i>value</i> by the <code>===</code> operator.

<P><span class="pcounter"></span> If <i>from</i> is negative, it is treated as
<code>this.length+<i>from</i></code>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>lastIndexOf</code> method returns the vector index the first
time <i>value</i> is equal to an element, or -1 if no such element is
found.

<P class="implsection"><b>Implementation</b>
<PRE><span class="pcounter"></span>intrinsic function lastIndexOf(value: T, from: AnyNumber=Infinity): AnyNumber {
    let start = helper::clamp( from, length );
    for ( let i=start ; i >= 0 ; i-- )
        if (this[i] === value)
            return i;
    return -1;
}
</PRE>

<h3>intrinsic::map&nbsp;(&nbsp;mapper,&nbsp;thisObj=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>map</code> method calls <i>mapper</i> on each vector
element of <code>this</code> in increasing numerical index order, collecting
the return values from <i>mapper</i>.

<P><span class="pcounter"></span><i>Mapper</i> is called with three arguments: the vector element
value, the vector element index, and <code>this</code>.  <i>ThisObj</i> is used as
the <code>this</code> object in the call.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>map</code> method returns a new <code>Vector</code> object of the same
base type and length as this <code>Vector</code>.  The element at index <i>i</i>
in the new vector is the value collected from the call to <i>mapper</i>
on <code>this[</code><i>i</i><code>]</code>.

<P class="implsection"><b>Implementation</b>
<PRE><span class="pcounter"></span>intrinsic function map(mapper:Mapper, thisObj:Object=null) {
    var result = new Vector.&#60;T>(length);
    for ( let i=0, limit=length ; i &#60; limit ; i++ )
        result[i] = mapper.call(thisObj, this[i], i, this);
    return result;
}
</PRE>

<h3>intrinsic::pop&nbsp;()</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>pop</code> method extracts the last vector element
from <code>this</code> and removes it by decreasing the value of the <code>length</code>
property of <code>this</code> by 1.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>pop</code> method returns the removed element, or the
appropriate default value for the base type of <code>this</code> if there are
no elements.

<P class="implsection"><b>Implementation</b>
<PRE><span class="pcounter"></span>intrinsic function pop(): T {
    if (length == 0)
        return undefined;

    let v = this[length-1];
    length--;
    return v;
}
</PRE>

<h3>intrinsic::push&nbsp;(&nbsp;...items&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>push</code> method appends the values in <i>items</i>
to this <code>Vector</code>, in the order in which they appear in <i>items</i>.
The <code>length</code> property of this <code>Vector</code> will be incremented by the
length of <i>items</i>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>push</code> method returns the new value of the <code>length</code>
property of this <code>Vector</code>.

<P class="implsection"><b>Implementation</b>
<PRE><span class="pcounter"></span>intrinsic function push(...items): double
    helper::push(items);
</PRE>
<PRE><span class="pcounter"></span>helper function push(items) {
    for ( let i=0, limit=items.length ; i &#60; limit ; i++ )
        this[length] = items[i];
    return length;
}
</PRE>


<h3>intrinsic::reverse&nbsp;()</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>reverse</code> method rearranges the vector elements of
<code>this</code> so as to reverse their order.  The <code>length</code> property of
<code>this</code> remains unchanged.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>reverse</code> method returns <code>this</code>.

<P class="implsection"><b>Implementation</b>
<PRE><span class="pcounter"></span>intrinsic function reverse(): Vector.&#60;T> {
    for ( let i=0, j=length-1 ; i &#60; j ; i++, j-- )
        [this[i], this[j]] = [this[j], this[i]];
    return this;
}
</PRE>

<h3>intrinsic::shift&nbsp;()</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>shift</code> method removes the element called <code>0</code> in
<code>this</code>, moves the element at index <i>i+1</i> to index <i>i</i>, and
decrements the <code>length</code> property of <code>this</code> by 1.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>shift</code> method returns the element that was removed.

<P class="implsection"><b>Implementation</b>
<PRE><span class="pcounter"></span>intrinsic function shift(): T {
    if (length == 0)
        return undefined;
    let v = this[0];
    for ( let i=1, limit=length ; i &#60; limit ; i++ )
        this[i-1] = this[i];
    length--;
    return v;
}
</PRE>

<h3>intrinsic::slice&nbsp;(&nbsp;start=&#x0085;,&nbsp;end=&#x0085;,&nbsp;step=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>slice</code> method extracts the subrange of array
elements from <code>this</code> between <i>start</i> (inclusive) and <i>end</i>
(exclusive) into a new Array.  Each <i>step</i> element is taken.

<P><span class="pcounter"></span> The default value of <i>start</i> is 0.  If it is negative, it is
treated as <code><i>object</i>.length+<i>start</i></code>.

<P><span class="pcounter"></span> The default value of <i>end</i> is Infinity.  If it is negative, it
is treated as <code><i>object</i>.length+<i>end</i></code>.

<P><span class="pcounter"></span> The default value of <i>step</i> is 1.  If it is 0, it is set to 1.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>slice</code> method returns a new <code>Vector</code> object with the
same base type as <code>this</code>, containing the extracted vector elements.

<P class="implsection"><b>Implementation</b>
<PRE><span class="pcounter"></span>intrinsic function slice(start: AnyNumber=0, end: AnyNumber=Infinity, step: AnyNumber=1): Vector.&#60;T> {
    step = helper::toInteger(step);
    if (step == 0)
        step = 1;

    start = helper::clamp(start, length);
    end = helper::clamp(end, length);

    let result = new Vector.&#60;T>;
    if (step > 0)
        for (let i=start; i &#60; end ; i += step)
            result[result.length] = this[i];
    else
        for (let i=start; i > end ; i += step)
            result[result.length] = this[i];

    return result;
}
</PRE>

<h3>intrinsic::some&nbsp;(&nbsp;checker,&nbsp;thisObj=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>some</code> method calls <i>checker</i> on every vector
element in <code>this</code> in increasing index order, stopping as soon as
<i>checker</i> returns a true value.

<P><span class="pcounter"></span><i>Checker</i> is called with three arguments: the vector element
value, the vector element index, and <code>this</code>.  <i>ThisObj</i> is used as
the <code>this</code> object in the call.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>some</code> method returns <b>true</b> when <i>checker</i> returns a
true value, otherwise returns <b>false</b> if all the calls to
<i>checker</i> return false values.

<P class="implsection"><b>Implementation</b>
<PRE><span class="pcounter"></span>intrinsic function some(checker: Checker, thisObj: Object=null): boolean {
    for ( let i=0, limit=length ; i &#60; limit ; i++ )
        if (checker.call(thisObj, this[i], i, this))
            return true;
    return false;
}
</PRE>

<h3>intrinsic::sort&nbsp;(&nbsp;comparefn&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic::<code>sort</code> method sorts the vector elements of
<code>this</code> according to the ordering defined by <code>comparefn</code>.

<P><span class="pcounter"></span> The sort is not necessarily stable (that is, elements that compare
equal do not necessarily remain in their original order).
<i>Comparefn</i> must be a consistent (see <span class="xref">sorting-logic</span>)
function that accepts two arguments <i>x</i> and <i>y</i> of the base type
of <code>this</code> and returns a negative value if <i>x < y</i>, zero if <i>x
= y</i>, or a positive value if <i>x > y</i>.

<p class="note"><b>COMPATIBILITY NOTE</b>&nbsp;&nbsp;  Unlike the case for <code>Array</code>, the <i>comparefn</i> is a required argument.

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #197.) Should we provide a default comparator?

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>sort</code> method returns <code>this</code>.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span>
The <code>sort</code> method calls on the generic sorting engine, passing a
function to compare elements of <i>this</i>.

<PRE><span class="pcounter"></span>intrinsic function sort(comparefn: function(T, T): AnyNumber): Vector.&#60;T> {
    let object = this;
    informative::sortEngine(object,
                            0,
                            length-1,
                            (function (j, k) comparefn(object[j], object[k])));
}
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  For a description of the informative <code>sortEngine</code> method, see
<span class="xref">sorting-logic</span>.

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  The signature of <code>comparefn</code> is probably too constraining,
it will require the client to pass a strongly-typed function.

<h3>intrinsic::splice&nbsp;(&nbsp;start,&nbsp;deleteCount,&nbsp;...items&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>splice</code> method replaces the <i>deleteCount</i> vector
elements of <code>this</code> starting at index <i>start</i> with values
from the <i>items</i>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>splice</code> method returns a new <code>Vector</code> object of the
same base type as <code>this</code>, containing the vector elements that were
removed from <code>this</code>, in order.

<P class="implsection"><b>Implementation</b>
<PRE><span class="pcounter"></span>intrinsic function splice(start: AnyNumber, deleteCount: AnyNumber, ...items): Vector.&#60;T>
    helper::splice(start, deleteCount, items);
</PRE>
<PRE><span class="pcounter"></span>helper function splice(start, deleteCount, items) {
    let first  = helper::clamp( start, length );
    let delcnt = helper::clamp( deleteCount, length-first );

    let result = new Vector.&#60;T>;
    for ( let n=0, i=first ; n &#60; delcnt ; n++, i++ )
        result[result.length] = this[i];

    if (items.length &#60; delcnt) {
        let shift = delcnt - items.length;
        for ( let n=0, i=first; n &#60; shift ; n++, i++ )
            this[i] = this[i+shift];
        length -= shift;
    }
    else {
        let shift = items.length - delcnt;
        for ( let n=shift-1, i=first+shift; n >= 0 ; n--, i-- )
            this[i] = this[i-shift];
    }
    for ( let n=0, i=first ; n &#60; items.length ; n++, i++ )
        this[i] = items[n];

    return result;
}
</PRE>

<h3>intrinsic::unshift&nbsp;(&nbsp;...items&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The instrinsic <code>unshift</code> method inserts the values in
<i>items</i> as new vector elements at the start of <code>this</code>, such that
their order within the vector elements of <code>this</code> is the same as the
order in which they appear in <i>items</i>.  Existing vector elements in
<code>this</code> are shifted upward in the index range, and the <code>length</code>
property of <code>this</code> is updated.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>unshift</code> method returns the new value of the
<code>length</code> property of <code>this</code>.

<P class="implsection"><b>Implementation</b>
<PRE><span class="pcounter"></span>intrinsic function unshift(...items): double
    helper::unshift(items);
</PRE>
<PRE><span class="pcounter"></span>helper function unshift(items) {
    let numitems = items.length;
    let oldlimit = length;
    let newlimit = oldlimit + numitems;

    for ( let i=0 ; i &#60; numitems ; i++ )
        this[newlimit-i] = this[oldlimit-i];
    for ( let i=0 ; i &#60; numitems ; i++ )
        this[i] = items[i];
    return newlength;
}
</PRE>


<h2>Iteration protocol on <code>Vector</code> instances</h2>

<P><span class="pcounter"></span> Iterators are defined on the <code>Vector</code> such that <code>for</code>-<code>in</code>
and <code>for each</code>-<code>in</code> loops always iterate across the vector from
low indices toward high indices.  Only indexed properties defined on
directly on the vector object are visited.

<P class="implsection"><b>Implementation</b>
<PRE><span class="pcounter"></span>iterator function get(deep: boolean = false) : iterator::IteratorType.&#60;uint>
    getKeys(deep);
</PRE>
<PRE><span class="pcounter"></span>iterator function getKeys(deep: boolean = false) : iterator::IteratorType.&#60;uint> {
    let i = 0;
    let a = this;
    return {
        const next:
            function () : double {
                if (i &#60; a.length)
                    return i++;
                throw iterator::StopIteration;
            }
    } : iterator::IteratorType.&#60;uint>;
}
</PRE>
<PRE><span class="pcounter"></span>iterator function getValues(deep: boolean = false) : iterator::IteratorType.&#60;T> {
    let i = 0;
    let a = this;
    return {
        const next:
            function () : T {
                if (i &#60; a.length)
                    return a[i++];
                throw iterator::StopIteration;
        }
    } : iterator::IteratorType.&#60;T>;
}
</PRE>
<PRE><span class="pcounter"></span>iterator function getItems(deep: boolean = false) : iterator::IteratorType.&#60;[uint,T]> {
    let i = 0;
    let a = this;
    return {
        const next:
        function () : T {
            if (i === a.length)
                return [i,a[i++]];
            throw iterator::StopIteration;
        }
    } : iterator::IteratorType.&#60;[uint,T]>;
}
</PRE>


<h2>Value properties of <code>Vector</code> instances</h2>

<h3>length</h3>

<P><span class="pcounter"></span> The property <code>length</code> determines the range of valid indices into
the <code>Vector</code>.  Indices up to but not including <code>length</code> are always
defined.

<P><span class="pcounter"></span> When <code>length</code> is given a new value that is smaller than its old
value then the elements in the vector at the new length and beyond are
removed from the vector.

<P><span class="pcounter"></span> When <code>length</code> is given a new value that is greater than its old
value then the elements in the vector at the old length and beyond are
given a default value that is appropriate to the base type <code>T</code>.

<P><span class="pcounter"></span> If an attempt is made to set <code>length</code> when the <code>fixed</code> property
is <b>true</b> then a <b>RangeError</b> is thrown.

<P><span class="pcounter"></span> If an attempt is made to set <code>length</code> to any value that is not a
nonnegative integer less than 2<SUP>32</SUP> then a <b>RangeError</b> is
thrown.


<h3>fixed</h3>

<P><span class="pcounter"></span> The boolean property <code>fixed</code> determines whether the <code>Vector</code>
has fixed length.

<P><span class="pcounter"></span> If <code>fixed</code> has the value <b>true</b> then any attempt to change
<code>length</code> will result in in a <b>RangeError</b> being thrown.

<P><span class="pcounter"></span> The value of <code>fixed</code> is not constant, so vectors can be of fixed
length and variable length at different times.


<h3>Numerically named properties</h3>

<P><span class="pcounter"></span> A <code>Vector</code> contains all properties whose names are nonnegative
integers below the value of the <code>Vector</code>'s <code>length</code> property.

<P><span class="pcounter"></span> If an attempt is made to read a property whose name is a number that
is not a nonnegative integer below <code>length</code> then a <b>RangeError</b> is thrown.

<P><span class="pcounter"></span> If an attempt is made to write a property whose name is a number that is not
a nonnegative integer below <code>length</code> then one of two things happen:
<UL>
  <LI> If the <code>fixed</code> property has the value <code>true</code>, or if the
  number is not a nonnegative integer, or if the number is nonnegative but
  not the same value as the value of <code>length</code>, or if <code>length</code> is 
  already 2<SUP>32</SUP>-1, then a <b>RangeError</b> is thrown.

  <LI> Otherwise, the property is defined on the vector and 
  the <code>length</code> property is incremented by 1.
</UL>

<h2>Methods on the <code>Vector</code> prototype object</h2>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The methods on the <code>Vector</code> prototype object perform a small
amount of type conversion and delegate to the corresponding intrinsic
methods.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The methods on the <code>Vector</code> prototype object return what their
corresponding intrinsic methods return.

<P class="implsection"><b>Implementation</b>
<PRE><span class="pcounter"></span>prototype function toString(this:Vector.&#60;*>)
    this.intrinsic::toString();
</PRE>
<PRE><span class="pcounter"></span>prototype function toLocaleString(this:Vector.&#60;*>)
    this.intrinsic::toLocaleString();
</PRE>
<PRE><span class="pcounter"></span>prototype function concat(this:Vector.&#60;*>, ...items)
    this.helper::concat(items);
</PRE>
<PRE><span class="pcounter"></span>prototype function every(this:Vector.&#60;*>, checker, thisObj=undefined)
    (this.intrinsic::every(checker, thisObj is Object) ? thisObj : null);
</PRE>
<PRE><span class="pcounter"></span>prototype function filter(this:Vector.&#60;*>, checker, thisObj=undefined)
    (this.intrinsic::filter(checker, thisObj is Object) ? thisObj : null);
</PRE>
<PRE><span class="pcounter"></span>prototype function forEach(this:Vector.&#60;*>, eacher, thisObj=undefined)
    (this.intrinsic::forEach(checker, thisObj is Object) ? thisObj : null);
</PRE>
<PRE><span class="pcounter"></span>prototype function indexOf(this:Vector.&#60;*>, value, from=undefined)
    this.intrinsic::indexOf(value, Number(from));
</PRE>
<PRE><span class="pcounter"></span>prototype function join(this:Vector.&#60;*>, separator=undefined)
    this.intrinsic::join(separator == undefined ? "," : string(separator));
</PRE>
<PRE><span class="pcounter"></span>prototype function lastIndexOf(this:Vector.&#60;*>, value, from=undefined)
    this.intrinsic::indexOf(value, from == undefined ? Infinity : Number(from));
</PRE>
<PRE><span class="pcounter"></span>prototype function map(this:Vector.&#60;*>, mapper, thisObj=undefined)
    (this.intrinsic::map(mapper, thisObj is Object) ? thisObj : null);
</PRE>
<PRE><span class="pcounter"></span>prototype function pop(this:Vector.&#60;*>)
    this.intrinsic::pop();
</PRE>
<PRE><span class="pcounter"></span>prototype function push(this:Vector.&#60;*>, ...items)
    this.helper::push(items);
</PRE>
<PRE><span class="pcounter"></span>prototype function reverse(this:Vector.&#60;*>)
    this.intrinsic::reverse();
</PRE>
<PRE><span class="pcounter"></span>prototype function shift(this:Vector.&#60;*>)
    this.intrinsic::shift();
</PRE>
<PRE><span class="pcounter"></span>prototype function slice(this:Vector.&#60;*>, start, end, step)
    this.intrinsic::slice(Number(start), Number(end), Number(step));
</PRE>
<PRE><span class="pcounter"></span>prototype function some(this:Vector.&#60;*>, checker, thisObj=undefined)
    (this.intrinsic::some(checker, thisObj is Object) ? thisObj : null);
</PRE>
<PRE><span class="pcounter"></span>prototype function sort(this:Vector.&#60;*>, comparefn)
    this.intrinsic::sort(comparefn);
</PRE>
<PRE><span class="pcounter"></span>prototype function splice(this:Vector.&#60;*>, start, deleteCount, ...items)
    this.helper::splice(Number(start), Number(deleteCount), items);
</PRE>
<PRE><span class="pcounter"></span>prototype function unshift(this:Vector.&#60;*>, ...items)
    this.helper::unshift(items);
</PRE>






</body>
</html>
